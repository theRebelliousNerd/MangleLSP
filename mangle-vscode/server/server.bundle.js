"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports3.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (exports3.URI = URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports3.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports3.uinteger = uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (exports3.Position = Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports3.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports3.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports3.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports3.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports3.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports3.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports3.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports3.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports3.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports3.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports3.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports3.Diagnostic = Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports3.Command = Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports3.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports3.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports3.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports3.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports3.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports3.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports3.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports3.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        (function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        })()
      );
      var ChangeAnnotations = (
        /** @class */
        (function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        })()
      );
      var WorkspaceChange = (
        /** @class */
        (function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        })()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports3.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports3.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports3.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports3.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports3.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports3.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports3.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports3.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports3.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports3.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports3.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports3.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports3.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports3.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports3.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports3.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports3.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports3.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports3.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports3.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports3.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports3.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports3.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports3.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports3.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports3.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports3.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports3.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports3.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports3.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports3.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports3.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports3.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports3.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports3.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports3.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports3.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports3.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports3.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports3.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports3.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports3.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports3.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports3.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports3.WorkspaceFolder = WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument2(uri, languageId, version, content);
        }
        TextDocument3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument3.applyEdits = applyEdits;
        function mergeSort2(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare);
          mergeSort2(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 || (exports3.TextDocument = TextDocument2 = {}));
      var FullTextDocument2 = (
        /** @class */
        (function() {
          function FullTextDocument3(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument3.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        })()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports2.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_12 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_12.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection;
  }
});

// node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path = require("path");
    var fs = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path.join(prefix, "node_modules");
          } else {
            return path.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        } else {
          return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem || (exports2.FileSystem = FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
          nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures || (exports2.ProposedFeatures = ProposedFeatures = {}));
  }
});

// node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var node_util_1 = require("node:util");
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_12 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files || (exports2.Files = Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_12.ConnectionStrategy.is(arg1) || node_12.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection;
    function _createConnection(input, output, options, factories) {
      let stdio = false;
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_12.IPCMessageReader(process);
            output = new node_12.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            stdio = true;
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_12.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_12.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_12.createProtocolConnection)(input, output, logger, options);
        if (stdio) {
          patchConsole(logger);
        }
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
    function patchConsole(logger) {
      function serialize(args) {
        return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
      }
      const counters = /* @__PURE__ */ new Map();
      console.assert = function assert(assertion, ...args) {
        if (assertion) {
          return;
        }
        if (args.length === 0) {
          logger.error("Assertion failed");
        } else {
          const [message, ...rest] = args;
          logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
        }
      };
      console.count = function count(label = "default") {
        const message = String(label);
        let counter = counters.get(message) ?? 0;
        counter += 1;
        counters.set(message, counter);
        logger.log(`${message}: ${message}`);
      };
      console.countReset = function countReset(label) {
        if (label === void 0) {
          counters.clear();
        } else {
          counters.delete(String(label));
        }
      };
      console.debug = function debug(...args) {
        logger.log(serialize(args));
      };
      console.dir = function dir(arg, options) {
        logger.log((0, node_util_1.inspect)(arg, options));
      };
      console.log = function log(...args) {
        logger.log(serialize(args));
      };
      console.error = function error(...args) {
        logger.error(serialize(args));
      };
      console.trace = function trace(...args) {
        const stack = new Error().stack.replace(/(.+\n){2}/, "");
        let message = "Trace";
        if (args.length !== 0) {
          message += `: ${serialize(args)}`;
        }
        logger.log(`${message}
${stack}`);
      };
      console.warn = function warn(...args) {
        logger.warn(serialize(args));
      };
    }
  }
});

// node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  TextDocument: () => TextDocument
});
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument, TextDocument;
var init_main = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument = class _FullTextDocument {
      constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(changes, version) {
        for (const change of changes) {
          if (_FullTextDocument.isIncremental(change)) {
            const range = getWellformedRange(change.range);
            const startOffset = this.offsetAt(range.start);
            const endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            const startLine = Math.max(range.start.line, 0);
            const endLine = Math.max(range.end.line, 0);
            let lineOffsets = this._lineOffsets;
            const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            const diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (_FullTextDocument.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          const mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
          return lineOffset;
        }
        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
      }
      ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
          offset--;
        }
        return offset;
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
      static isIncremental(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      static isFull(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
    };
    (function(TextDocument2) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument2.create = create;
      function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
          document.update(changes, version);
          return document;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument2.update = update;
      function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
          const diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
          const startOffset = document.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument2.applyEdits = applyEdits;
    })(TextDocument || (TextDocument = {}));
  }
});

// server/parser/ast.js
var require_ast = __commonJS({
  "server/parser/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DESCRIPTORS = exports2.TYPE_BOUNDS = exports2.COMPARISON_PREDICATES = void 0;
    exports2.pointRange = pointRange;
    exports2.spanRange = spanRange;
    exports2.containsPosition = containsPosition;
    exports2.mergeRanges = mergeRanges;
    exports2.createName = createName;
    exports2.createString = createString;
    exports2.createBytes = createBytes;
    exports2.createNumber = createNumber;
    exports2.createFloat64 = createFloat64;
    exports2.createTime = createTime;
    exports2.createDuration = createDuration;
    exports2.createList = createList;
    exports2.createVariable = createVariable;
    exports2.createPredicateSym = createPredicateSym;
    exports2.createFunctionSym = createFunctionSym;
    exports2.createAtom = createAtom;
    exports2.createNegAtom = createNegAtom;
    exports2.createEq = createEq;
    exports2.createIneq = createIneq;
    exports2.createApplyFn = createApplyFn;
    exports2.createClause = createClause;
    exports2.createDecl = createDecl;
    exports2.isBuiltinPredicate = isBuiltinPredicate;
    exports2.isFunction = isFunction;
    exports2.predicateKey = predicateKey;
    exports2.functionKey = functionKey;
    exports2.isVariable = isVariable;
    exports2.isConstant = isConstant;
    exports2.isAtom = isAtom;
    exports2.isNegAtom = isNegAtom;
    exports2.isApplyFn = isApplyFn;
    exports2.isTemporalLiteral = isTemporalLiteral;
    exports2.isTemporalAtom = isTemporalAtom;
    exports2.isEternalInterval = isEternalInterval;
    exports2.isDeclExternal = isDeclExternal;
    exports2.isDeclTemporal = isDeclTemporal;
    exports2.isDeclMaybeTemporal = isDeclMaybeTemporal;
    exports2.getDeclModes = getDeclModes;
    exports2.isComparisonAtom = isComparisonAtom;
    exports2.isLtAtom = isLtAtom;
    exports2.isLeAtom = isLeAtom;
    exports2.isGtAtom = isGtAtom;
    exports2.isGeAtom = isGeAtom;
    exports2.collectVariables = collectVariables;
    exports2.collectClauseVariables = collectClauseVariables;
    exports2.termToString = termToString;
    exports2.clauseToString = clauseToString;
    exports2.temporalBoundToString = temporalBoundToString;
    exports2.temporalIntervalToString = temporalIntervalToString;
    exports2.temporalOperatorToString = temporalOperatorToString;
    function pointRange(pos) {
      return { start: pos, end: pos };
    }
    function spanRange(start, end) {
      return { start, end };
    }
    function containsPosition(range, pos) {
      if (pos.line < range.start.line || pos.line > range.end.line)
        return false;
      if (pos.line === range.start.line && pos.column < range.start.column)
        return false;
      if (pos.line === range.end.line && pos.column >= range.end.column)
        return false;
      return true;
    }
    function mergeRanges(a, b) {
      let start;
      if (a.start.line < b.start.line || a.start.line === b.start.line && a.start.column <= b.start.column) {
        start = a.start;
      } else {
        start = b.start;
      }
      let end;
      if (a.end.line > b.end.line || a.end.line === b.end.line && a.end.column >= b.end.column) {
        end = a.end;
      } else {
        end = b.end;
      }
      return { start, end };
    }
    function createName(symbol, range) {
      if (!symbol.startsWith("/")) {
        throw new Error(`Name constant must start with '/': ${symbol}`);
      }
      return { type: "Constant", constantType: "name", symbol, range };
    }
    function createString(value, range) {
      return { type: "Constant", constantType: "string", symbol: value, range };
    }
    function createBytes(value, range) {
      return { type: "Constant", constantType: "bytes", symbol: value, range };
    }
    function createNumber(value, range) {
      return { type: "Constant", constantType: "number", numValue: value, range };
    }
    function createFloat64(value, range) {
      return { type: "Constant", constantType: "float64", floatValue: value, range };
    }
    function createTime(nanos, range) {
      return { type: "Constant", constantType: "time", numValue: nanos, range };
    }
    function createDuration(nanos, range) {
      return { type: "Constant", constantType: "duration", numValue: nanos, range };
    }
    function createList(items, range) {
      if (items.length === 0) {
        return { type: "Constant", constantType: "list", range };
      }
      let result = { type: "Constant", constantType: "list", range };
      for (let i = items.length - 1; i >= 0; i--) {
        result = { type: "Constant", constantType: "list", fst: items[i], snd: result, range };
      }
      return result;
    }
    function createVariable(symbol, range) {
      return { type: "Variable", symbol, range };
    }
    function createPredicateSym(symbol, arity) {
      return { symbol, arity };
    }
    function createFunctionSym(symbol, arity) {
      return { symbol, arity };
    }
    function createAtom(predicate, args, range) {
      return { type: "Atom", predicate, args, range };
    }
    function createNegAtom(atom, range) {
      return { type: "NegAtom", atom, range };
    }
    function createEq(left, right, range) {
      return { type: "Eq", left, right, range };
    }
    function createIneq(left, right, range) {
      return { type: "Ineq", left, right, range };
    }
    function createApplyFn(fn, args, range) {
      return { type: "ApplyFn", function: fn, args, range };
    }
    function createClause(head, premises, transform, range, headTime = null) {
      return { type: "Clause", head, premises, transform, headTime, range };
    }
    function createDecl(declaredAtom, descr, bounds, constraints, range) {
      return { type: "Decl", declaredAtom, descr, bounds, constraints, range };
    }
    function isBuiltinPredicate(sym) {
      return sym.symbol.startsWith(":");
    }
    function isFunction(sym) {
      return sym.symbol.startsWith("fn:");
    }
    function predicateKey(sym) {
      return `${sym.symbol}/${sym.arity}`;
    }
    function functionKey(sym) {
      return `${sym.symbol}/${sym.arity}`;
    }
    function isVariable(term) {
      return "type" in term && term.type === "Variable";
    }
    function isConstant(term) {
      return "type" in term && term.type === "Constant";
    }
    function isAtom(term) {
      return "type" in term && term.type === "Atom";
    }
    function isNegAtom(term) {
      return "type" in term && term.type === "NegAtom";
    }
    function isApplyFn(term) {
      return "type" in term && term.type === "ApplyFn";
    }
    function isTemporalLiteral(term) {
      return "type" in term && term.type === "TemporalLiteral";
    }
    function isTemporalAtom(term) {
      return "type" in term && term.type === "TemporalAtom";
    }
    function isEternalInterval(interval) {
      return interval.start.boundType === "negativeInfinity" && interval.end.boundType === "positiveInfinity";
    }
    function isDeclExternal(decl) {
      return decl.descr?.some((d) => d.predicate.symbol === exports2.DESCRIPTORS.EXTERNAL) ?? false;
    }
    function isDeclTemporal(decl) {
      return decl.descr?.some((d) => d.predicate.symbol === exports2.DESCRIPTORS.TEMPORAL) ?? false;
    }
    function isDeclMaybeTemporal(decl) {
      return decl.descr?.some((d) => d.predicate.symbol === exports2.DESCRIPTORS.MAYBE_TEMPORAL) ?? false;
    }
    function getDeclModes(decl) {
      return decl.descr?.filter((d) => d.predicate.symbol === exports2.DESCRIPTORS.MODE) ?? [];
    }
    exports2.COMPARISON_PREDICATES = [":lt", ":le", ":gt", ":ge"];
    exports2.TYPE_BOUNDS = {
      ANY: "/any",
      BOT: "/bot",
      NUMBER: "/number",
      FLOAT64: "/float64",
      STRING: "/string",
      BYTES: "/bytes",
      NAME: "/name",
      TIME: "/time",
      DURATION: "/duration",
      BOOL: "/bool"
    };
    exports2.DESCRIPTORS = {
      EXTERNAL: "external",
      EXTENSIONAL: "extensional",
      MODE: "mode",
      REFLECTS: "reflects",
      SYNTHETIC: "synthetic",
      PRIVATE: "private",
      DOC: "doc",
      ARG: "arg",
      NAME: "name",
      DESUGARED: "desugared",
      FUNDEP: "fundep",
      MERGE_PREDICATE: "merge",
      DEFERRED_PREDICATE: "deferred",
      TEMPORAL: "temporal",
      MAYBE_TEMPORAL: "internal:maybe_temporal"
    };
    function isComparisonAtom(term) {
      return isAtom(term) && exports2.COMPARISON_PREDICATES.includes(term.predicate.symbol);
    }
    function isLtAtom(term) {
      return isAtom(term) && term.predicate.symbol === ":lt";
    }
    function isLeAtom(term) {
      return isAtom(term) && term.predicate.symbol === ":le";
    }
    function isGtAtom(term) {
      return isAtom(term) && term.predicate.symbol === ":gt";
    }
    function isGeAtom(term) {
      return isAtom(term) && term.predicate.symbol === ":ge";
    }
    function collectVariables(term) {
      const vars = /* @__PURE__ */ new Set();
      function visit(t) {
        if (isVariable(t)) {
          vars.add(t.symbol);
        } else if (isAtom(t)) {
          t.args.forEach(visit);
        } else if (isNegAtom(t)) {
          visit(t.atom);
        } else if (isTemporalLiteral(t)) {
          visit(t.literal);
          if (t.interval) {
            if (t.interval.start.variable)
              vars.add(t.interval.start.variable.symbol);
            if (t.interval.end.variable)
              vars.add(t.interval.end.variable.symbol);
          }
        } else if (isApplyFn(t)) {
          t.args.forEach(visit);
        } else if ("left" in t && "right" in t) {
          visit(t.left);
          visit(t.right);
        }
      }
      visit(term);
      return vars;
    }
    function collectClauseVariables(clause) {
      const vars = /* @__PURE__ */ new Set();
      clause.head.args.forEach((arg) => {
        for (const v of collectVariables(arg)) {
          vars.add(v);
        }
      });
      if (clause.headTime) {
        if (clause.headTime.start.variable)
          vars.add(clause.headTime.start.variable.symbol);
        if (clause.headTime.end.variable)
          vars.add(clause.headTime.end.variable.symbol);
      }
      if (clause.premises) {
        clause.premises.forEach((premise) => {
          for (const v of collectVariables(premise)) {
            vars.add(v);
          }
        });
      }
      if (clause.transform) {
        let transform = clause.transform;
        while (transform) {
          for (const stmt of transform.statements) {
            if (stmt.variable) {
              vars.add(stmt.variable.symbol);
            }
            for (const v of collectVariables(stmt.fn)) {
              vars.add(v);
            }
          }
          transform = transform.next;
        }
      }
      return vars;
    }
    function termToString(term) {
      if (isConstant(term)) {
        switch (term.constantType) {
          case "name":
            return term.symbol ?? "";
          case "string":
            return `"${term.symbol ?? ""}"`;
          case "bytes":
            return `b"${term.symbol ?? ""}"`;
          case "number":
            return String(term.numValue ?? 0);
          case "float64":
            return String(term.floatValue ?? 0);
          case "time":
            return `time(${term.numValue ?? 0})`;
          case "duration":
            return `duration(${term.numValue ?? 0})`;
          case "list":
            if (!term.fst)
              return "[]";
            const elements = [];
            let current = term;
            while (current && current.fst) {
              elements.push(termToString(current.fst));
              current = current.snd;
            }
            return `[${elements.join(", ")}]`;
          case "map":
          case "struct":
            return term.constantType === "map" ? "[...]" : "{...}";
          case "pair":
            return `fn:pair(${term.fst ? termToString(term.fst) : ""}, ${term.snd ? termToString(term.snd) : ""})`;
        }
      }
      if (isVariable(term)) {
        return term.symbol;
      }
      if (isAtom(term)) {
        const args = term.args.map(termToString).join(", ");
        return `${term.predicate.symbol}(${args})`;
      }
      if (isNegAtom(term)) {
        return `!${termToString(term.atom)}`;
      }
      if (isTemporalLiteral(term)) {
        let result = "";
        if (term.operator) {
          result += temporalOperatorToString(term.operator) + " ";
        }
        result += termToString(term.literal);
        if (term.interval && !isEternalInterval(term.interval)) {
          result += temporalIntervalToString(term.interval);
        }
        return result;
      }
      if (isTemporalAtom(term)) {
        let result = termToString(term.atom);
        if (term.interval && !isEternalInterval(term.interval)) {
          result += temporalIntervalToString(term.interval);
        }
        return result;
      }
      if (isApplyFn(term)) {
        const args = term.args.map(termToString).join(", ");
        return `${term.function.symbol}(${args})`;
      }
      if ("left" in term && "right" in term) {
        const left = termToString(term.left);
        const right = termToString(term.right);
        switch (term.type) {
          case "Eq":
            return `${left} = ${right}`;
          case "Ineq":
            return `${left} != ${right}`;
          case "Lt":
            return `${left} < ${right}`;
          case "Le":
            return `${left} <= ${right}`;
          case "Gt":
            return `${left} > ${right}`;
          case "Ge":
            return `${left} >= ${right}`;
        }
      }
      return "?";
    }
    function clauseToString(clause) {
      let head = termToString(clause.head);
      if (clause.headTime && !isEternalInterval(clause.headTime)) {
        head += temporalIntervalToString(clause.headTime);
      }
      if (!clause.premises) {
        return `${head}.`;
      }
      const premises = clause.premises.map(termToString).join(", ");
      if (!clause.transform) {
        return `${head} :- ${premises}.`;
      }
      const transformParts = [];
      let transform = clause.transform;
      while (transform) {
        const stmts = transform.statements.map((stmt) => {
          if (stmt.variable) {
            return `let ${stmt.variable.symbol} = ${termToString(stmt.fn)}`;
          } else {
            return `do ${termToString(stmt.fn)}`;
          }
        }).join(", ");
        transformParts.push(stmts);
        transform = transform.next;
      }
      return `${head} :- ${premises} |> ${transformParts.join(" |> ")}.`;
    }
    var TEMPORAL_OP_SYMBOLS = {
      "diamondMinus": "<-",
      "diamondPlus": "<+",
      "boxMinus": "[-",
      "boxPlus": "[+"
    };
    function temporalBoundToString(bound) {
      switch (bound.boundType) {
        case "variable":
          return bound.variable?.symbol ?? "_";
        case "negativeInfinity":
        case "positiveInfinity":
          return "_";
        case "now":
          return "now";
        case "timestamp":
          if (bound.rawText)
            return bound.rawText;
          if (bound.value !== void 0) {
            const ms = bound.value / 1e6;
            return new Date(ms).toISOString();
          }
          return "?";
        case "duration":
          if (bound.rawText)
            return bound.rawText;
          if (bound.value !== void 0) {
            return formatDurationNanos(bound.value);
          }
          return "?";
        default:
          return "?";
      }
    }
    function formatDurationNanos(nanos) {
      const ms = 1e6;
      const sec = 1e9;
      const min = sec * 60;
      const hour = min * 60;
      const day = hour * 24;
      if (nanos === 0)
        return "0s";
      if (nanos % day === 0)
        return `${nanos / day}d`;
      if (nanos % hour === 0)
        return `${nanos / hour}h`;
      if (nanos % min === 0)
        return `${nanos / min}m`;
      if (nanos % sec === 0)
        return `${nanos / sec}s`;
      if (nanos % ms === 0)
        return `${nanos / ms}ms`;
      return `${nanos}ns`;
    }
    function temporalIntervalToString(interval) {
      if (isEternalInterval(interval))
        return "";
      const startStr = temporalBoundToString(interval.start);
      const endStr = temporalBoundToString(interval.end);
      if (startStr === endStr) {
        return `@[${startStr}]`;
      }
      return `@[${startStr}, ${endStr}]`;
    }
    function temporalOperatorToString(op) {
      const symbol = TEMPORAL_OP_SYMBOLS[op.operatorType];
      if (op.interval) {
        const startStr = temporalBoundToString(op.interval.start);
        const endStr = temporalBoundToString(op.interval.end);
        return `${symbol}[${startStr}, ${endStr}]`;
      }
      return symbol;
    }
  }
});

// node_modules/antlr4ng/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/antlr4ng/dist/index.cjs"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      ATN: () => ATN,
      ATNConfig: () => ATNConfig,
      ATNConfigSet: () => ATNConfigSet,
      ATNDeserializer: () => ATNDeserializer,
      ATNSerializer: () => ATNSerializer,
      ATNSimulator: () => ATNSimulator,
      ATNState: () => ATNState,
      AbstractParseTreeVisitor: () => AbstractParseTreeVisitor,
      AbstractPredicateTransition: () => AbstractPredicateTransition,
      ActionTransition: () => ActionTransition,
      ArrayPredictionContext: () => ArrayPredictionContext,
      AtomTransition: () => AtomTransition,
      BailErrorStrategy: () => BailErrorStrategy,
      BaseErrorListener: () => BaseErrorListener,
      BasicBlockStartState: () => BasicBlockStartState,
      BasicState: () => BasicState,
      BitSet: () => BitSet,
      BlockEndState: () => BlockEndState,
      BlockStartState: () => BlockStartState,
      BufferedTokenStream: () => BufferedTokenStream,
      CannotInvokeStartRuleError: () => CannotInvokeStartRuleError,
      CharStream: () => CharStream,
      CharStreamImpl: () => CharStreamImpl,
      Chunk: () => Chunk,
      CodePointTransitions: () => CodePointTransitions,
      CommonToken: () => CommonToken,
      CommonTokenFactory: () => CommonTokenFactory,
      CommonTokenStream: () => CommonTokenStream,
      ConsoleErrorListener: () => ConsoleErrorListener,
      DFA: () => DFA,
      DFASerializer: () => DFASerializer,
      DFAState: () => DFAState,
      DecisionInfo: () => DecisionInfo,
      DecisionState: () => DecisionState,
      DefaultErrorStrategy: () => DefaultErrorStrategy,
      DiagnosticErrorListener: () => DiagnosticErrorListener,
      DoubleDict: () => DoubleDict,
      EmptyPredictionContext: () => EmptyPredictionContext,
      EpsilonTransition: () => EpsilonTransition,
      ErrorNode: () => ErrorNode,
      FailedPredicateException: () => FailedPredicateException,
      HashMap: () => HashMap,
      HashSet: () => HashSet,
      InputMismatchException: () => InputMismatchException,
      IntStream: () => IntStream,
      InterpreterDataReader: () => InterpreterDataReader,
      InterpreterRuleContext: () => InterpreterRuleContext,
      Interval: () => Interval,
      IntervalSet: () => IntervalSet,
      LL1Analyzer: () => LL1Analyzer,
      Lexer: () => Lexer,
      LexerATNConfig: () => LexerATNConfig,
      LexerATNSimulator: () => LexerATNSimulator,
      LexerActionExecutor: () => LexerActionExecutor,
      LexerActionType: () => LexerActionType,
      LexerChannelAction: () => LexerChannelAction,
      LexerCustomAction: () => LexerCustomAction,
      LexerDFASerializer: () => LexerDFASerializer,
      LexerIndexedCustomAction: () => LexerIndexedCustomAction,
      LexerInterpreter: () => LexerInterpreter,
      LexerModeAction: () => LexerModeAction,
      LexerMoreAction: () => LexerMoreAction,
      LexerNoViableAltException: () => LexerNoViableAltException,
      LexerPopModeAction: () => LexerPopModeAction,
      LexerPushModeAction: () => LexerPushModeAction,
      LexerSkipAction: () => LexerSkipAction,
      LexerTypeAction: () => LexerTypeAction,
      ListTokenSource: () => ListTokenSource,
      LoopEndState: () => LoopEndState,
      MurmurHash: () => MurmurHash,
      NoViableAltException: () => NoViableAltException,
      NotSetTransition: () => NotSetTransition,
      OrderedATNConfigSet: () => OrderedATNConfigSet,
      OrderedHashMap: () => OrderedHashMap,
      OrderedHashSet: () => OrderedHashSet,
      ParseCancellationException: () => ParseCancellationException,
      ParseInfo: () => ParseInfo,
      ParseTreeMatch: () => ParseTreeMatch,
      ParseTreePattern: () => ParseTreePattern,
      ParseTreePatternMatcher: () => ParseTreePatternMatcher,
      ParseTreeWalker: () => ParseTreeWalker,
      Parser: () => Parser,
      ParserATNSimulator: () => ParserATNSimulator,
      ParserInterpreter: () => ParserInterpreter,
      ParserRuleContext: () => ParserRuleContext,
      PlusBlockStartState: () => PlusBlockStartState,
      PlusLoopbackState: () => PlusLoopbackState,
      PrecedencePredicateTransition: () => PrecedencePredicateTransition,
      PredPrediction: () => PredPrediction,
      PredicateTransition: () => PredicateTransition,
      PredictionContext: () => PredictionContext,
      PredictionContextCache: () => PredictionContextCache,
      PredictionMode: () => PredictionMode,
      ProfilingATNSimulator: () => ProfilingATNSimulator,
      ProxyErrorListener: () => ProxyErrorListener,
      RangeTransition: () => RangeTransition,
      RecognitionException: () => RecognitionException,
      Recognizer: () => Recognizer,
      RuleStartState: () => RuleStartState,
      RuleStopState: () => RuleStopState,
      RuleTagToken: () => RuleTagToken,
      RuleTransition: () => RuleTransition,
      RuntimeMetaData: () => RuntimeMetaData,
      SemanticContext: () => SemanticContext,
      SetTransition: () => SetTransition,
      SingletonPredictionContext: () => SingletonPredictionContext,
      StarBlockStartState: () => StarBlockStartState,
      StarLoopEntryState: () => StarLoopEntryState,
      StarLoopbackState: () => StarLoopbackState,
      StartRuleDoesNotConsumeFullPatternError: () => StartRuleDoesNotConsumeFullPatternError,
      TagChunk: () => TagChunk,
      TerminalNode: () => TerminalNode,
      TextChunk: () => TextChunk,
      Token: () => Token,
      TokenStreamRewriter: () => TokenStreamRewriter,
      TokenTagToken: () => TokenTagToken,
      TokensStartState: () => TokensStartState,
      TraceListener: () => TraceListener,
      Transition: () => Transition,
      Trees: () => Trees,
      UnbufferedTokenStream: () => UnbufferedTokenStream,
      Vocabulary: () => Vocabulary,
      WildcardTransition: () => WildcardTransition,
      XPath: () => XPath,
      XPathElement: () => XPathElement,
      XPathLexer: () => XPathLexer,
      XPathLexerErrorListener: () => XPathLexerErrorListener,
      XPathRuleAnywhereElement: () => XPathRuleAnywhereElement,
      XPathRuleElement: () => XPathRuleElement,
      XPathTokenAnywhereElement: () => XPathTokenAnywhereElement,
      XPathTokenElement: () => XPathTokenElement,
      XPathWildcardAnywhereElement: () => XPathWildcardAnywhereElement,
      XPathWildcardElement: () => XPathWildcardElement,
      arrayToString: () => arrayToString,
      combineCommonParents: () => combineCommonParents,
      createSingletonPredictionContext: () => createSingletonPredictionContext,
      equalArrays: () => equalArrays,
      equalNumberArrays: () => equalNumberArrays,
      escapeWhitespace: () => escapeWhitespace,
      getCachedPredictionContext: () => getCachedPredictionContext,
      isComparable: () => isComparable,
      isToken: () => isToken,
      isWritableToken: () => isWritableToken,
      merge: () => merge,
      mergeRoot: () => mergeRoot,
      mergeSingletons: () => mergeSingletons,
      predictionContextFromRuleContext: () => predictionContextFromRuleContext
    });
    module2.exports = __toCommonJS2(src_exports);
    var IntStream;
    ((IntStream2) => {
      IntStream2.EOF = -1;
      IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
    })(IntStream || (IntStream = {}));
    var Token;
    ((Token2) => {
      Token2.INVALID_TYPE = 0;
      Token2.EPSILON = -2;
      Token2.MIN_USER_TOKEN_TYPE = 1;
      Token2.EOF = IntStream.EOF;
      Token2.DEFAULT_CHANNEL = 0;
      Token2.HIDDEN_CHANNEL = 1;
      Token2.MIN_USER_CHANNEL_VALUE = 2;
    })(Token || (Token = {}));
    var isToken = /* @__PURE__ */ __name((candidate) => {
      const token = candidate;
      return token.tokenSource !== void 0 && token.channel !== void 0;
    }, "isToken");
    var BitSet = class {
      static {
        __name(this, "BitSet");
      }
      data;
      /**
       * Creates a new bit set. All bits are initially `false`.
       *
       * @param data Optional initial data.
       */
      constructor(data) {
        if (data) {
          this.data = new Uint32Array(data.map((value) => {
            return value >>> 0;
          }));
        } else {
          this.data = new Uint32Array(1);
        }
      }
      /**
       * @returns an iterator over all set bits.
       */
      [Symbol.iterator]() {
        const length = this.data.length;
        let currentIndex = 0;
        let currentWord = this.data[currentIndex];
        const words = this.data;
        return {
          [Symbol.iterator]() {
            return this;
          },
          next: /* @__PURE__ */ __name(() => {
            while (currentIndex < length) {
              if (currentWord !== 0) {
                const t = currentWord & -currentWord;
                const value = (currentIndex << 5) + this.bitCount(t - 1);
                currentWord ^= t;
                return { done: false, value };
              } else {
                currentIndex++;
                if (currentIndex < length) {
                  currentWord = words[currentIndex];
                }
              }
            }
            return { done: true, value: void 0 };
          }, "next")
        };
      }
      /**
       * Sets a single bit or all of the bits in this `BitSet` to `false`.
       *
       * @param index the index of the bit to be cleared, or undefined to clear all bits.
       */
      clear(index) {
        if (index === void 0) {
          this.data = new Uint32Array();
        } else {
          this.resize(index);
          this.data[index >>> 5] &= ~(1 << index);
        }
      }
      /**
       * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
       * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
       * set argument has the value `true`.
       *
       * @param set the bit set to be ORed with.
       */
      or(set) {
        const minCount = Math.min(this.data.length, set.data.length);
        for (let k = 0; k < minCount; ++k) {
          this.data[k] |= set.data[k];
        }
        if (this.data.length < set.data.length) {
          this.resize((set.data.length << 5) - 1);
          const c = set.data.length;
          for (let k = minCount; k < c; ++k) {
            this.data[k] = set.data[k];
          }
        }
      }
      /**
       * Returns the value of the bit with the specified index. The value is `true` if the bit with the index `bitIndex`
       * is currently set in this `BitSet`; otherwise, the result is `false`.
       *
       * @param index the bit index
       *
       * @returns the value of the bit with the specified index.
       */
      get(index) {
        if (index < 0) {
          throw new RangeError("index cannot be negative");
        }
        const slot = index >>> 5;
        if (slot >= this.data.length) {
          return false;
        }
        return (this.data[slot] & 1 << index % 32) !== 0;
      }
      /**
       * @returns the number of set bits.
       */
      get length() {
        let result = 0;
        const c = this.data.length;
        const w = this.data;
        for (let i = 0; i < c; i++) {
          result += this.bitCount(w[i]);
        }
        return result;
      }
      /**
       * @returns an array with indices of set bits.
       */
      values() {
        const result = new Array(this.length);
        let pos = 0;
        const length = this.data.length;
        for (let k = 0; k < length; ++k) {
          let w = this.data[k];
          while (w !== 0) {
            const t = w & -w;
            result[pos++] = (k << 5) + this.bitCount(t - 1);
            w ^= t;
          }
        }
        return result;
      }
      /**
       * @returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
       * If no such bit exists then undefined is returned.
       *
       * @param fromIndex the index to start checking from (inclusive)
       */
      nextSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("index cannot be negative");
        }
        for (const index of this) {
          if (index >= fromIndex) {
            return index;
          }
        }
        return void 0;
      }
      /**
       * Sets the bit at the specified index to `true`.
       *
       * @param index a bit index
       */
      set(index) {
        if (index < 0) {
          throw new RangeError("index cannot be negative");
        }
        this.resize(index);
        this.data[index >>> 5] |= 1 << index % 32;
      }
      /**
       * @returns a string representation of this bit set.
       */
      toString() {
        return "{" + this.values().join(", ") + "}";
      }
      resize(index) {
        const count = index + 32 >>> 5;
        if (count <= this.data.length) {
          return;
        }
        const data = new Uint32Array(count);
        data.set(this.data);
        data.fill(0, this.data.length);
        this.data = data;
      }
      bitCount(v) {
        v = v - (v >> 1 & 1431655765);
        v = (v & 858993459) + (v >> 2 & 858993459);
        v = v + (v >> 4) & 252645135;
        v = v + (v >> 8);
        v = v + (v >> 16);
        return v & 63;
      }
    };
    var c1 = 3432918353;
    var c2 = 461845907;
    var r1 = 15;
    var r2 = 13;
    var m = 5;
    var n = 3864292196;
    var MurmurHash = class _MurmurHash {
      static {
        __name(this, "MurmurHash");
      }
      static defaultSeed = 701;
      constructor() {
      }
      /**
       * Initialize the hash using the specified {@code seed}.
       *
       * @param seed the seed
       *
       * @returns the intermediate hash value
       */
      static initialize(seed = _MurmurHash.defaultSeed) {
        return seed;
      }
      static updateFromComparable(hash, value) {
        return this.update(hash, value?.hashCode() ?? 0);
      }
      /**
       * Update the intermediate hash value for the next input {@code value}.
       *
       * @param hash The intermediate hash value.
       * @param value the value to add to the current hash.
       *
       * @returns the updated intermediate hash value
       */
      static update(hash, value) {
        value = Math.imul(value, c1);
        value = value << r1 | value >>> 32 - r1;
        value = Math.imul(value, c2);
        hash = hash ^ value;
        hash = hash << r2 | hash >>> 32 - r2;
        hash = Math.imul(hash, m) + n;
        return hash;
      }
      /**
       * Apply the final computation steps to the intermediate value {@code hash}
       * to form the final result of the MurmurHash 3 hash function.
       *
       * @param hash The intermediate hash value.
       * @param entryCount The number of values added to the hash.
       *
       * @returns the final hash result
       */
      static finish(hash, entryCount) {
        hash ^= entryCount * 4;
        hash ^= hash >>> 16;
        hash = Math.imul(hash, 2246822507);
        hash ^= hash >>> 13;
        hash = Math.imul(hash, 3266489909);
        hash ^= hash >>> 16;
        return hash;
      }
      /**
       * An all-in-one convenience method to compute a hash for a single value.
       *
       * @param value The value to hash.
       * @param seed The seed for the hash value.
       *
       * @returns The computed hash.
       */
      static hashCode(value, seed) {
        return _MurmurHash.finish(_MurmurHash.update(seed ?? _MurmurHash.defaultSeed, value), 1);
      }
    };
    var ObjectEqualityComparator = class _ObjectEqualityComparator {
      static {
        __name(this, "ObjectEqualityComparator");
      }
      static instance = new _ObjectEqualityComparator();
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return obj.hashCode();
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        }
        return a.equals(b);
      }
    };
    var DefaultEqualityComparator = class _DefaultEqualityComparator {
      static {
        __name(this, "DefaultEqualityComparator");
      }
      static instance = new _DefaultEqualityComparator();
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return ObjectEqualityComparator.instance.hashCode(obj);
      }
      equals(a, b) {
        if (a == null) {
          return b == null;
        }
        if (typeof a === "string" || typeof a === "number") {
          return a === b;
        }
        return ObjectEqualityComparator.instance.equals(a, b);
      }
    };
    var HashSet = class _HashSet {
      static {
        __name(this, "HashSet");
      }
      static defaultLoadFactor = 0.75;
      static initialCapacity = 16;
      // must be power of 2
      comparator;
      buckets;
      threshold;
      /** How many elements in set */
      itemCount = 0;
      constructor(comparatorOrSet, initialCapacity = _HashSet.initialCapacity) {
        if (comparatorOrSet instanceof _HashSet) {
          this.comparator = comparatorOrSet.comparator;
          this.buckets = comparatorOrSet.buckets.slice(0);
          for (let i = 0; i < this.buckets.length; i++) {
            const bucket = this.buckets[i];
            if (bucket) {
              this.buckets[i] = bucket.slice(0);
            }
          }
          this.itemCount = comparatorOrSet.itemCount;
          this.threshold = comparatorOrSet.threshold;
        } else {
          this.comparator = comparatorOrSet ?? DefaultEqualityComparator.instance;
          this.buckets = this.createBuckets(initialCapacity);
          this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);
        }
      }
      /**
       * Add `o` to set if not there; return existing value if already
       * there. This method performs the same operation as {@link #add} aside from
       * the return value.
       *
       * @param o the object to add to the set.
       *
       * @returns An existing element that equals to `o` if already in set, otherwise `o`.
       */
      getOrAdd(o) {
        if (this.itemCount > this.threshold) {
          this.expand();
        }
        const b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          bucket = [o];
          this.buckets[b] = bucket;
          ++this.itemCount;
          return o;
        }
        for (const existing of bucket) {
          if (this.comparator.equals(existing, o)) {
            return existing;
          }
        }
        bucket.push(o);
        ++this.itemCount;
        return o;
      }
      get(o) {
        if (o == null) {
          return o;
        }
        const b = this.getBucket(o);
        const bucket = this.buckets[b];
        if (!bucket) {
          return void 0;
        }
        for (const e of bucket) {
          if (this.comparator.equals(e, o)) {
            return e;
          }
        }
        return void 0;
      }
      /**
       * Removes the specified element from this set if it is present.
       *
       * @param o object to be removed from this set, if present.
       *
       * @returns `true` if the set contained the specified element.
       */
      remove(o) {
        if (o == null) {
          return false;
        }
        const b = this.getBucket(o);
        const bucket = this.buckets[b];
        if (!bucket) {
          return false;
        }
        for (let i = 0; i < bucket.length; i++) {
          const existing = bucket[i];
          if (this.comparator.equals(existing, o)) {
            bucket.splice(i, 1);
            --this.itemCount;
            return true;
          }
        }
        return false;
      }
      hashCode() {
        let hash = MurmurHash.initialize();
        for (const bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (const o of bucket) {
            if (o == null) {
              break;
            }
            hash = MurmurHash.update(hash, this.comparator.hashCode(o));
          }
        }
        hash = MurmurHash.finish(hash, this.size);
        return hash;
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof _HashSet)) {
          return false;
        }
        if (o.size !== this.size) {
          return false;
        }
        return this.containsAll(o);
      }
      add(t) {
        const existing = this.getOrAdd(t);
        return existing === t;
      }
      contains(o) {
        return this.containsFast(o);
      }
      containsFast(obj) {
        if (obj == null) {
          return false;
        }
        return this.get(obj) !== void 0;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      toArray() {
        const a = new Array(this.size);
        let i = 0;
        for (const bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (const o of bucket) {
            if (o == null) {
              break;
            }
            a[i++] = o;
          }
        }
        return a;
      }
      containsAll(collection) {
        if (collection instanceof _HashSet) {
          for (const bucket of collection.buckets) {
            if (bucket == null) {
              continue;
            }
            for (const o of bucket) {
              if (o == null) {
                break;
              }
              if (!this.containsFast(o)) {
                return false;
              }
            }
          }
        } else {
          for (const o of collection) {
            if (!this.containsFast(o)) {
              return false;
            }
          }
        }
        return true;
      }
      addAll(c) {
        let changed = false;
        for (const o of c) {
          const existing = this.getOrAdd(o);
          if (existing !== o) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.buckets = this.createBuckets(_HashSet.initialCapacity);
        this.itemCount = 0;
        this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);
      }
      toString() {
        if (this.size === 0) {
          return "{}";
        }
        let buf = "{";
        let first = true;
        for (const bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (const o of bucket) {
            if (o == null) {
              break;
            }
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += o.toString();
          }
        }
        buf += "}";
        return buf;
      }
      toTableString() {
        let buf = "";
        for (const bucket of this.buckets) {
          if (bucket == null) {
            buf += "null\n";
            continue;
          }
          buf += "[";
          let first = true;
          for (const o of bucket) {
            if (first) {
              first = false;
            } else {
              buf += " ";
            }
            if (o == null) {
              buf += "_";
            } else {
              buf += o.toString();
            }
          }
          buf += "]\n";
        }
        return buf;
      }
      getBucket(o) {
        const hash = this.comparator.hashCode(o);
        const b = hash & this.buckets.length - 1;
        return b;
      }
      expand() {
        const old = this.buckets;
        const newCapacity = this.buckets.length * 2;
        const newTable = this.createBuckets(newCapacity);
        this.buckets = newTable;
        this.threshold = Math.floor(newCapacity * _HashSet.defaultLoadFactor);
        for (const bucket of old) {
          if (!bucket) {
            continue;
          }
          for (const o of bucket) {
            const b = this.getBucket(o);
            let newBucket = this.buckets[b];
            if (!newBucket) {
              newBucket = [];
              this.buckets[b] = newBucket;
            }
            newBucket.push(o);
          }
        }
      }
      get size() {
        return this.itemCount;
      }
      get isEmpty() {
        return this.itemCount === 0;
      }
      /**
       * Return an array of `T[]` with length `capacity`.
       *
       * @param capacity the length of the array to return
       * @returns the newly constructed array
       */
      createBuckets(capacity) {
        return new Array(capacity);
      }
    };
    var Interval = class _Interval {
      static {
        __name(this, "Interval");
      }
      static INVALID_INTERVAL = new _Interval(-1, -2);
      static INTERVAL_POOL_MAX_VALUE = 1e3;
      static cache = [];
      start;
      stop;
      cachedHashCode;
      constructor(start, stop) {
        this.start = start;
        this.stop = stop;
        this.cachedHashCode = Math.imul(651 + start, 31) + stop;
      }
      /**
       * Creates a new interval from the given values.
       *
       * Interval objects are used readonly so share all with the
       * same single value a==b up to some max size. Use an array as a perfect hash.
       * Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
       * Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
       * have a..a (set with 1 element).
       *
       * @param a The start of the interval.
       * @param b The end of the interval (inclusive).
       *
       * @returns A cached or new interval.
       */
      static of(a, b) {
        if (a !== b || a < 0 || a > _Interval.INTERVAL_POOL_MAX_VALUE) {
          return new _Interval(a, b);
        }
        if (!_Interval.cache[a]) {
          _Interval.cache[a] = new _Interval(a, a);
        }
        return _Interval.cache[a];
      }
      equals(o) {
        return this.start === o.start && this.stop === o.stop;
      }
      hashCode() {
        return this.cachedHashCode;
      }
      /** Does this start completely before other? Disjoint */
      startsBeforeDisjoint(other) {
        return this.start < other.start && this.stop < other.start;
      }
      /** Does this start at or before other? Nondisjoint */
      startsBeforeNonDisjoint(other) {
        return this.start <= other.start && this.stop >= other.start;
      }
      /** Does this.start start after other.stop? May or may not be disjoint */
      startsAfter(other) {
        return this.start > other.start;
      }
      /** Does this start completely after other? Disjoint */
      startsAfterDisjoint(other) {
        return this.start > other.stop;
      }
      /** Does this start after other? NonDisjoint */
      startsAfterNonDisjoint(other) {
        return this.start > other.start && this.start <= other.stop;
      }
      /** Are both ranges disjoint? I.e., no overlap? */
      disjoint(other) {
        return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
      }
      /** Are two intervals adjacent such as 0..41 and 42..42? */
      adjacent(other) {
        return this.start === other.stop + 1 || this.stop === other.start - 1;
      }
      properlyContains(other) {
        return other.start >= this.start && other.stop <= this.stop;
      }
      /** Return the interval computed from combining this and other */
      union(other) {
        return _Interval.of(Math.min(this.start, other.start), Math.max(this.stop, other.stop));
      }
      /** Return the interval in common between this and o */
      intersection(other) {
        return _Interval.of(Math.max(this.start, other.start), Math.min(this.stop, other.stop));
      }
      /**
       * Return the interval with elements from this not in other;
       *  other must not be totally enclosed (properly contained)
       *  within this, which would result in two disjoint intervals
       *  instead of the single one returned by this method.
       */
      differenceNotProperlyContained(other) {
        let diff = null;
        if (other.startsBeforeNonDisjoint(this)) {
          diff = _Interval.of(Math.max(this.start, other.stop + 1), this.stop);
        } else if (other.startsAfterNonDisjoint(this)) {
          diff = _Interval.of(this.start, other.start - 1);
        }
        return diff;
      }
      toString() {
        return `${this.start}..${this.stop}`;
      }
      get length() {
        if (this.stop < this.start) {
          return 0;
        }
        return this.stop - this.start + 1;
      }
    };
    var Vocabulary = class _Vocabulary {
      static {
        __name(this, "Vocabulary");
      }
      static EMPTY_NAMES = [];
      /**
       * Gets an empty {@link Vocabulary} instance.
       *
       *
       * No literal or symbol names are assigned to token types, so
       * {@link #getDisplayName(int)} returns the numeric value for all tokens
       * except {@link Token#EOF}.
       */
      static EMPTY_VOCABULARY = new _Vocabulary(_Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES);
      maxTokenType;
      literalNames;
      symbolicNames;
      displayNames;
      /**
       * Constructs a new instance of {@link Vocabulary} from the specified
       * literal, symbolic, and display token names.
       *
       * @param literalNames The literal names assigned to tokens, or `null`
       * if no literal names are assigned.
       * @param symbolicNames The symbolic names assigned to tokens, or
       * `null` if no symbolic names are assigned.
       * @param displayNames The display names assigned to tokens, or `null`
       * to use the values in `literalNames` and `symbolicNames` as
       * the source of display names, as described in
       * {@link #getDisplayName(int)}.
       */
      constructor(literalNames, symbolicNames, displayNames) {
        this.literalNames = literalNames ?? _Vocabulary.EMPTY_NAMES;
        this.symbolicNames = symbolicNames ?? _Vocabulary.EMPTY_NAMES;
        this.displayNames = displayNames ?? _Vocabulary.EMPTY_NAMES;
        this.maxTokenType = Math.max(this.displayNames.length, Math.max(
          this.literalNames.length,
          this.symbolicNames.length
        )) - 1;
      }
      /**
       * Returns a {@link Vocabulary} instance from the specified set of token
       * names. This method acts as a compatibility layer for the single
       * `tokenNames` array generated by previous releases of ANTLR.
       *
       * The resulting vocabulary instance returns `null` for
       * {@link getLiteralName getLiteralName(int)} and {@link getSymbolicName getSymbolicName(int)}, and the
       * value from `tokenNames` for the display names.
       *
       * @param tokenNames The token names, or `null` if no token names are
       * available.
       * @returns A {@link Vocabulary} instance which uses `tokenNames` for
       * the display names of tokens.
       */
      static fromTokenNames(tokenNames) {
        if (tokenNames == null || tokenNames.length === 0) {
          return _Vocabulary.EMPTY_VOCABULARY;
        }
        const literalNames = [...tokenNames];
        const symbolicNames = [...tokenNames];
        for (let i = 0; i < tokenNames.length; i++) {
          const tokenName = tokenNames[i];
          if (tokenName == null) {
            continue;
          }
          if (tokenName.length > 0) {
            const firstChar = tokenName.codePointAt(0);
            if (firstChar === 39) {
              symbolicNames[i] = null;
              continue;
            } else if (firstChar >= 65 && firstChar <= 90) {
              literalNames[i] = null;
              continue;
            }
          }
          literalNames[i] = null;
          symbolicNames[i] = null;
        }
        return new _Vocabulary(literalNames, symbolicNames, tokenNames);
      }
      getMaxTokenType() {
        return this.maxTokenType;
      }
      getLiteralName(tokenType) {
        if (tokenType >= 0 && tokenType < this.literalNames.length) {
          return this.literalNames[tokenType];
        }
        return null;
      }
      getSymbolicName(tokenType) {
        if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
          return this.symbolicNames[tokenType];
        }
        if (tokenType === Token.EOF) {
          return "EOF";
        }
        return null;
      }
      getDisplayName(tokenType) {
        if (tokenType >= 0 && tokenType < this.displayNames.length) {
          const displayName = this.displayNames[tokenType];
          if (displayName != null) {
            return displayName;
          }
        }
        const literalName = this.getLiteralName(tokenType);
        if (literalName != null) {
          return literalName;
        }
        const symbolicName = this.getSymbolicName(tokenType);
        if (symbolicName != null) {
          return symbolicName;
        }
        return `${tokenType}`;
      }
      getLiteralNames() {
        return this.literalNames;
      }
      getSymbolicNames() {
        return this.symbolicNames;
      }
      getDisplayNames() {
        return this.displayNames;
      }
    };
    var IntervalSet = class _IntervalSet {
      static {
        __name(this, "IntervalSet");
      }
      /** The list of sorted, disjoint intervals. */
      intervals = [];
      cachedHashCode;
      constructor(set) {
        if (set) {
          if (Array.isArray(set)) {
            for (const el of set) {
              this.addOne(el);
            }
          } else {
            this.addSet(set);
          }
        }
      }
      /** Create a set with all ints within range [a..b] (inclusive) */
      static of(a, b) {
        const s = new _IntervalSet();
        s.addRange(a, b);
        return s;
      }
      /** Combine all sets in the array and return the union of them */
      static or(sets) {
        const result = new _IntervalSet();
        for (const set of sets) {
          result.addSet(set);
        }
        return result;
      }
      [Symbol.iterator]() {
        return this.intervals[Symbol.iterator]();
      }
      get(index) {
        return this.intervals[index];
      }
      /**
       * Returns the minimum value contained in the set if not isNil().
       *
       * @returns the minimum value contained in the set.
       */
      get minElement() {
        if (this.intervals.length === 0) {
          return Token.INVALID_TYPE;
        }
        return this.intervals[0].start;
      }
      /**
       * Returns the maximum value contained in the set if not isNil().
       *
       * @returns the maximum value contained in the set.
       */
      get maxElement() {
        if (this.intervals.length === 0) {
          return Token.INVALID_TYPE;
        }
        return this.intervals[this.intervals.length - 1].stop;
      }
      clear() {
        this.cachedHashCode = void 0;
        this.intervals = [];
      }
      /**
       * Add a single element to the set.  An isolated element is stored
       *  as a range el..el.
       */
      addOne(v) {
        this.addInterval(new Interval(v, v));
      }
      /**
       * Add interval; i.e., add all integers from a to b to set.
       *  If b < a, do nothing.
       *  Keep list in sorted order (by left range value).
       *  If overlap, combine ranges. For example,
       *  If this is {1..5, 10..20}, adding 6..7 yields
       *  {1..5, 6..7, 10..20}. Adding 4..8 yields {1..8, 10..20}.
       */
      addRange(l, h) {
        this.addInterval(new Interval(l, h));
      }
      addInterval(addition) {
        this.cachedHashCode = void 0;
        if (this.intervals.length === 0) {
          this.intervals.push(addition);
        } else {
          for (let pos = 0; pos < this.intervals.length; pos++) {
            const existing = this.intervals[pos];
            if (addition.equals(existing)) {
              return;
            }
            if (addition.adjacent(existing) || !addition.disjoint(existing)) {
              const bigger = addition.union(existing);
              this.intervals[pos] = bigger;
              for (let sub = pos + 1; sub < this.intervals.length; ) {
                const next = this.intervals[sub];
                if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                  break;
                }
                this.intervals.splice(sub, 1);
                this.intervals[pos] = bigger.union(next);
              }
              return;
            }
            if (addition.startsBeforeDisjoint(existing)) {
              this.intervals.splice(pos, 0, addition);
              return;
            }
          }
          this.intervals.push(addition);
        }
      }
      addSet(other) {
        other.intervals.forEach((toAdd) => {
          return this.addInterval(toAdd);
        }, this);
        return this;
      }
      complementWithVocabulary(vocabulary) {
        const result = new _IntervalSet();
        if (!vocabulary) {
          return result;
        }
        if (vocabulary.length === 0) {
          return result;
        }
        result.addSet(vocabulary);
        return result.subtract(this);
      }
      complement(minElement, maxElement) {
        const result = new _IntervalSet();
        result.addInterval(new Interval(minElement, maxElement));
        return result.subtract(this);
      }
      /** combine all sets in the array returned the or'd value */
      or(sets) {
        const result = new _IntervalSet();
        result.addSet(this);
        sets.forEach((set) => {
          return result.addSet(set);
        });
        return result;
      }
      and(other) {
        if (other.length === 0) {
          return new _IntervalSet();
        }
        const myIntervals = this.intervals;
        const theirIntervals = other.intervals;
        let intersection;
        const mySize = myIntervals.length;
        const theirSize = theirIntervals.length;
        let i = 0;
        let j = 0;
        while (i < mySize && j < theirSize) {
          const mine = myIntervals[i];
          const theirs = theirIntervals[j];
          if (mine.startsBeforeDisjoint(theirs)) {
            i++;
          } else if (theirs.startsBeforeDisjoint(mine)) {
            j++;
          } else if (mine.properlyContains(theirs)) {
            if (!intersection) {
              intersection = new _IntervalSet();
            }
            intersection.addInterval(mine.intersection(theirs));
            j++;
          } else if (theirs.properlyContains(mine)) {
            if (!intersection) {
              intersection = new _IntervalSet();
            }
            intersection.addInterval(mine.intersection(theirs));
            i++;
          } else if (!mine.disjoint(theirs)) {
            if (!intersection) {
              intersection = new _IntervalSet();
            }
            intersection.addInterval(mine.intersection(theirs));
            if (mine.startsAfterNonDisjoint(theirs)) {
              j++;
            } else if (theirs.startsAfterNonDisjoint(mine)) {
              i++;
            }
          }
        }
        if (!intersection) {
          return new _IntervalSet();
        }
        return intersection;
      }
      /**
       * Compute the set difference between two interval sets. The specific
       * operation is `left - right`. If either of the input sets is
       * `null`, it is treated as though it was an empty set.
       */
      subtract(other) {
        if (this.length === 0) {
          return new _IntervalSet();
        }
        const result = new _IntervalSet(this);
        if (other.length === 0) {
          return result;
        }
        let resultI = 0;
        let rightI = 0;
        while (resultI < result.intervals.length && rightI < other.intervals.length) {
          const resultInterval = result.intervals[resultI];
          const rightInterval = other.intervals[rightI];
          if (rightInterval.stop < resultInterval.start) {
            rightI++;
            continue;
          }
          if (rightInterval.start > resultInterval.stop) {
            resultI++;
            continue;
          }
          let beforeCurrent;
          let afterCurrent;
          if (rightInterval.start > resultInterval.start) {
            beforeCurrent = new Interval(resultInterval.start, rightInterval.start - 1);
          }
          if (rightInterval.stop < resultInterval.stop) {
            afterCurrent = new Interval(rightInterval.stop + 1, resultInterval.stop);
          }
          if (beforeCurrent) {
            if (afterCurrent) {
              result.intervals[resultI] = beforeCurrent;
              result.intervals.splice(resultI + 1, 0, afterCurrent);
              resultI++;
              rightI++;
            } else {
              result.intervals[resultI] = beforeCurrent;
              resultI++;
            }
          } else {
            if (afterCurrent) {
              result.intervals[resultI] = afterCurrent;
              rightI++;
            } else {
              result.intervals.splice(resultI, 1);
            }
          }
        }
        return result;
      }
      contains(el) {
        const n2 = this.intervals.length;
        let l = 0;
        let r = n2 - 1;
        while (l <= r) {
          const m2 = Math.floor((l + r) / 2);
          const interval = this.intervals[m2];
          if (interval.stop < el) {
            l = m2 + 1;
          } else if (interval.start > el) {
            r = m2 - 1;
          } else {
            return true;
          }
        }
        return false;
      }
      removeRange(toRemove) {
        this.cachedHashCode = void 0;
        if (toRemove.start === toRemove.stop) {
          this.removeOne(toRemove.start);
        } else if (this.intervals !== null) {
          let pos = 0;
          for (const existing of this.intervals) {
            if (toRemove.stop <= existing.start) {
              return;
            } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
              this.intervals[pos] = new Interval(existing.start, toRemove.start);
              const x = new Interval(toRemove.stop, existing.stop);
              this.intervals.splice(pos, 0, x);
              return;
            } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
              this.intervals.splice(pos, 1);
              pos = pos - 1;
            } else if (toRemove.start < existing.stop) {
              this.intervals[pos] = new Interval(existing.start, toRemove.start);
            } else if (toRemove.stop < existing.stop) {
              this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
            }
            pos += 1;
          }
        }
      }
      removeOne(value) {
        this.cachedHashCode = void 0;
        for (let i = 0; i < this.intervals.length; i++) {
          const existing = this.intervals[i];
          if (value < existing.start) {
            return;
          } else if (value === existing.start && value === existing.stop) {
            this.intervals.splice(i, 1);
            return;
          } else if (value === existing.start) {
            this.intervals[i] = new Interval(existing.start + 1, existing.stop);
            return;
          } else if (value === existing.stop) {
            this.intervals[i] = new Interval(existing.start, existing.stop - 1);
            return;
          } else if (value < existing.stop) {
            const replace = new Interval(existing.start, value - 1);
            this.intervals[i] = new Interval(value + 1, existing.stop);
            this.intervals.splice(i, 0, replace);
            return;
          }
        }
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          for (const interval of this.intervals) {
            hash = MurmurHash.update(hash, interval.start);
            hash = MurmurHash.update(hash, interval.stop);
          }
          this.cachedHashCode = MurmurHash.finish(hash, this.intervals.length * 2);
        }
        return this.cachedHashCode;
      }
      /**
       * Are two IntervalSets equal? Because all intervals are sorted and disjoint, equals is a simple linear walk over
       * both lists to make sure they are the same. Interval.equals() is used by the List.equals() method to check
       * the ranges.
       */
      equals(other) {
        if (this === other) {
          return true;
        }
        if (this.intervals.length !== other.intervals.length) {
          return false;
        }
        for (let i = 0; i < this.intervals.length; i++) {
          if (!this.intervals[i].equals(other.intervals[i])) {
            return false;
          }
        }
        return true;
      }
      toString(elementsAreChar) {
        if (this.intervals.length === 0) {
          return "{}";
        }
        let result = "";
        if (this.length > 1) {
          result += "{";
        }
        for (let i = 0; i < this.intervals.length; ++i) {
          const interval = this.intervals[i];
          const start = interval.start;
          const stop = interval.stop;
          if (start === stop) {
            if (start === Token.EOF) {
              result += "<EOF>";
            } else if (elementsAreChar) {
              result += "'" + String.fromCodePoint(start) + "'";
            } else {
              result += start;
            }
          } else {
            if (elementsAreChar) {
              result += "'" + String.fromCodePoint(start) + "'..'" + String.fromCodePoint(stop) + "'";
            } else {
              result += start + ".." + stop;
            }
          }
          if (i < this.intervals.length - 1) {
            result += ", ";
          }
        }
        if (this.length > 1) {
          result += "}";
        }
        return result;
      }
      toStringWithVocabulary(vocabulary) {
        if (this.intervals.length === 0) {
          return "{}";
        }
        let result = "";
        if (this.length > 1) {
          result += "{";
        }
        for (let i = 0; i < this.intervals.length; ++i) {
          const interval = this.intervals[i];
          const start = interval.start;
          const stop = interval.stop;
          if (start === stop) {
            if (start === Token.EOF) {
              result += "<EOF>";
            } else {
              result += this.elementName(vocabulary, start);
            }
          } else {
            for (let i2 = start; i2 <= stop; ++i2) {
              if (i2 > start) {
                result += ", ";
              }
              result += this.elementName(vocabulary, i2);
            }
          }
          if (i < this.intervals.length - 1) {
            result += ", ";
          }
        }
        if (this.length > 1) {
          result += "}";
        }
        return result;
      }
      toStringWithRuleNames(ruleNames) {
        if (this.intervals.length === 0) {
          return "{}";
        }
        let result = "";
        if (this.length > 1) {
          result += "{";
        }
        const vocabulary = Vocabulary.fromTokenNames(ruleNames);
        for (let i = 0; i < this.intervals.length; ++i) {
          const interval = this.intervals[i];
          const start = interval.start;
          const stop = interval.stop;
          if (start === stop) {
            if (start === Token.EOF) {
              result += "<EOF>";
            } else {
              result += this.elementName(vocabulary, start);
            }
          } else {
            for (let i2 = start; i2 <= stop; ++i2) {
              if (i2 > start) {
                result += ", ";
              }
              result += this.elementName(vocabulary, i2);
            }
          }
          if (i < this.intervals.length - 1) {
            result += ", ";
          }
        }
        if (this.length > 1) {
          result += "}";
        }
        return result;
      }
      toArray() {
        const data = [];
        for (const interval of this.intervals) {
          for (let j = interval.start; j <= interval.stop; j++) {
            data.push(j);
          }
        }
        return data;
      }
      /** @returns the number of elements in this set. */
      get length() {
        let result = 0;
        for (const interval of this.intervals) {
          result += interval.length;
        }
        return result;
      }
      elementName(vocabulary, token) {
        if (token === Token.EOF) {
          return "<EOF>";
        }
        if (token === Token.EPSILON) {
          return "<EPSILON>";
        }
        return vocabulary.getDisplayName(token);
      }
    };
    var isComparable = /* @__PURE__ */ __name((candidate) => {
      return typeof candidate.equals === "function";
    }, "isComparable");
    var valueToString = /* @__PURE__ */ __name((v) => {
      return v === null ? "null" : v;
    }, "valueToString");
    var arrayToString = /* @__PURE__ */ __name((value) => {
      return Array.isArray(value) ? "[" + value.map(valueToString).join(", ") + "]" : "null";
    }, "arrayToString");
    var equalArrays = /* @__PURE__ */ __name((a, b) => {
      if (a === b) {
        return true;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        const left = a[i];
        const right = b[i];
        if (left === right) {
          continue;
        }
        if (!left || !left.equals(right)) {
          return false;
        }
      }
      return true;
    }, "equalArrays");
    var equalNumberArrays = /* @__PURE__ */ __name((a, b) => {
      if (a === b) {
        return true;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }, "equalNumberArrays");
    var escapeWhitespace = /* @__PURE__ */ __name((s, escapeSpaces = false) => {
      s = s.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
      if (escapeSpaces) {
        s = s.replace(/ /g, "\xB7");
      }
      return s;
    }, "escapeWhitespace");
    var SemanticContext = class _SemanticContext {
      static {
        __name(this, "SemanticContext");
      }
      cachedHashCode;
      static andContext(a, b) {
        if (a === null || a === _SemanticContext.NONE) {
          return b;
        }
        if (b === null || b === _SemanticContext.NONE) {
          return a;
        }
        const result = new AND(a, b);
        if (result.operands.length === 1) {
          return result.operands[0];
        }
        return result;
      }
      static orContext(a, b) {
        if (a === null) {
          return b;
        }
        if (b === null) {
          return a;
        }
        if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) {
          return _SemanticContext.NONE;
        }
        const result = new OR(a, b);
        if (result.operands.length === 1) {
          return result.operands[0];
        } else {
          return result;
        }
      }
      static filterPrecedencePredicates(set) {
        const result = [];
        for (const context of set) {
          if (context instanceof _SemanticContext.PrecedencePredicate) {
            result.push(context);
          }
        }
        return result;
      }
      /**
       * Evaluate the precedence predicates for the context and reduce the result.
       *
       * @param _parser The parser instance.
       * @param _parserCallStack The current parser context object.
       * @returns The simplified semantic context after precedence predicates are
       * evaluated, which will be one of the following values.
       * - {@link NONE}: if the predicate simplifies to `true` after
       * precedence predicates are evaluated.
       * - `null`: if the predicate simplifies to `false` after
       * precedence predicates are evaluated.
       * - `this`: if the semantic context is not changed as a result of
       * precedence predicate evaluation.
       * - A non-`null` {@link SemanticContext}: the new simplified
       * semantic context after precedence predicates are evaluated.
       */
      evalPrecedence(_parser, _parserCallStack) {
        return this;
      }
    };
    var AND = class _AND extends SemanticContext {
      static {
        __name(this, "AND");
      }
      operands;
      /**
       * A semantic context which is true whenever none of the contained contexts
       * is false
       */
      constructor(a, b) {
        super();
        const operands = new HashSet();
        if (a instanceof _AND) {
          a.operands.forEach((o) => {
            operands.add(o);
          });
        } else {
          operands.add(a);
        }
        if (b instanceof _AND) {
          b.operands.forEach((o) => {
            operands.add(o);
          });
        } else {
          operands.add(b);
        }
        const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);
        if (precedencePredicates.length > 0) {
          let reduced = null;
          precedencePredicates.forEach((p) => {
            if (reduced === null || p.precedence < reduced.precedence) {
              reduced = p;
            }
          });
          if (reduced) {
            operands.add(reduced);
          }
        }
        this.operands = operands.toArray();
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _AND)) {
          return false;
        }
        return equalArrays(this.operands, other.operands);
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          for (const operand of this.operands) {
            hash = MurmurHash.updateFromComparable(hash, operand);
          }
          hash = MurmurHash.update(hash, 3813686060);
          this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);
        }
        return this.cachedHashCode;
      }
      /**
       * {@inheritDoc}
       *
       *
       * The evaluation of predicates by this context is short-circuiting, but
       * unordered.
       */
      evaluate(parser, parserCallStack) {
        for (const operand of this.operands) {
          if (!operand.evaluate(parser, parserCallStack)) {
            return false;
          }
        }
        return true;
      }
      evalPrecedence(parser, parserCallStack) {
        let differs = false;
        const operands = [];
        for (const context of this.operands) {
          const evaluated = context.evalPrecedence(parser, parserCallStack);
          differs ||= evaluated !== context;
          if (evaluated === null) {
            return null;
          } else if (evaluated !== SemanticContext.NONE) {
            operands.push(evaluated);
          }
        }
        if (!differs) {
          return this;
        }
        if (operands.length === 0) {
          return SemanticContext.NONE;
        }
        let result = null;
        operands.forEach((o) => {
          result = result === null ? o : SemanticContext.andContext(result, o);
        });
        return result;
      }
      toString() {
        const s = this.operands.map((o) => {
          return o.toString();
        });
        return (s.length > 3 ? s.slice(3) : s).join("&&");
      }
    };
    var OR = class _OR extends SemanticContext {
      static {
        __name(this, "OR");
      }
      operands;
      /**
       * A semantic context which is true whenever at least one of the contained
       * contexts is true
       */
      constructor(a, b) {
        super();
        const operands = new HashSet();
        if (a instanceof _OR) {
          a.operands.forEach((o) => {
            operands.add(o);
          });
        } else {
          operands.add(a);
        }
        if (b instanceof _OR) {
          b.operands.forEach((o) => {
            operands.add(o);
          });
        } else {
          operands.add(b);
        }
        const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);
        if (precedencePredicates.length > 0) {
          const s = precedencePredicates.sort((a2, b2) => {
            return a2.compareTo(b2);
          });
          const reduced = s[s.length - 1];
          operands.add(reduced);
        }
        this.operands = operands.toArray();
      }
      equals(other) {
        if (this === other) {
          return true;
        } else if (!(other instanceof _OR)) {
          return false;
        } else {
          return equalArrays(this.operands, other.operands);
        }
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          for (const operand of this.operands) {
            hash = MurmurHash.updateFromComparable(hash, operand);
          }
          hash = MurmurHash.update(hash, 3383313031);
          this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);
        }
        return this.cachedHashCode;
      }
      /**
       * The evaluation of predicates by this context is short-circuiting, but unordered.
       */
      evaluate(parser, parserCallStack) {
        for (const operand of this.operands) {
          if (operand.evaluate(parser, parserCallStack)) {
            return true;
          }
        }
        return false;
      }
      evalPrecedence(parser, parserCallStack) {
        let differs = false;
        const operands = [];
        for (const context of this.operands) {
          const evaluated = context.evalPrecedence(parser, parserCallStack);
          differs ||= evaluated !== context;
          if (evaluated === SemanticContext.NONE) {
            return SemanticContext.NONE;
          } else if (evaluated !== null) {
            operands.push(evaluated);
          }
        }
        if (!differs) {
          return this;
        }
        if (operands.length === 0) {
          return null;
        }
        let result = null;
        operands.forEach((o) => {
          result = result === null ? o : SemanticContext.orContext(result, o);
        });
        return result;
      }
      toString() {
        const s = this.operands.map((o) => {
          return o.toString();
        });
        return (s.length > 3 ? s.slice(3) : s).join("||");
      }
    };
    ((SemanticContext2) => {
      class Predicate extends SemanticContext2 {
        static {
          __name(this, "Predicate");
        }
        ruleIndex;
        predIndex;
        isCtxDependent;
        // e.g., $i ref in pred
        constructor(ruleIndex, predIndex, isCtxDependent) {
          super();
          this.ruleIndex = ruleIndex ?? -1;
          this.predIndex = predIndex ?? -1;
          this.isCtxDependent = isCtxDependent ?? false;
        }
        evaluate(parser, outerContext) {
          const localctx = this.isCtxDependent ? outerContext : null;
          return parser.sempred(localctx, this.ruleIndex, this.predIndex);
        }
        hashCode() {
          if (this.cachedHashCode === void 0) {
            let hashCode = MurmurHash.initialize();
            hashCode = MurmurHash.update(hashCode, this.ruleIndex);
            hashCode = MurmurHash.update(hashCode, this.predIndex);
            hashCode = MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
            hashCode = MurmurHash.finish(hashCode, 3);
            this.cachedHashCode = hashCode;
          }
          return this.cachedHashCode;
        }
        equals(other) {
          if (this === other) {
            return true;
          }
          return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
        }
        toString() {
          return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
        }
      }
      SemanticContext2.Predicate = Predicate;
      class PrecedencePredicate extends SemanticContext2 {
        static {
          __name(this, "PrecedencePredicate");
        }
        precedence;
        constructor(precedence) {
          super();
          this.precedence = precedence ?? 0;
        }
        evaluate(parser, outerContext) {
          return parser.precpred(outerContext, this.precedence);
        }
        evalPrecedence(parser, outerContext) {
          if (parser.precpred(outerContext ?? null, this.precedence)) {
            return SemanticContext2.NONE;
          }
          return null;
        }
        compareTo(other) {
          return this.precedence - other.precedence;
        }
        hashCode() {
          return 31 + this.precedence;
        }
        equals(other) {
          if (this === other) {
            return true;
          }
          return this.precedence === other.precedence;
        }
        toString() {
          return "{" + this.precedence + ">=prec}?";
        }
      }
      SemanticContext2.PrecedencePredicate = PrecedencePredicate;
      SemanticContext2.NONE = new Predicate();
    })(SemanticContext || (SemanticContext = {}));
    var ATNConfig = class _ATNConfig {
      static {
        __name(this, "ATNConfig");
      }
      /** The ATN state associated with this configuration */
      state;
      /** What alt (or lexer rule) is predicted by this configuration */
      alt;
      /**
       * We cannot execute predicates dependent upon local context unless
       * we know for sure we are in the correct context. Because there is
       * no way to do this efficiently, we simply cannot evaluate
       * dependent predicates unless we are in the rule that initially
       * invokes the ATN simulator.
       *
       * closure() tracks the depth of how far we dip into the outer context:
       * depth > 0.
       */
      reachesIntoOuterContext = false;
      // Not used in hash code.
      precedenceFilterSuppressed = false;
      // Not used in hash code.
      get semanticContext() {
        return this.#semanticContext;
      }
      cachedHashCode;
      // Shared with LexerATNConfig.
      /**
       * The syntactic context is a graph-structured stack node whose
       * path(s) to the root is the rule invocation(s)
       * chain used to arrive at the state.  The semantic context is
       * the tree of semantic predicates encountered before reaching
       * an ATN state
       */
      #context = null;
      #semanticContext;
      /** Never create config classes directly. Use the factory methods below. */
      constructor(c, state, context, semanticContext) {
        this.state = state;
        this.alt = c.alt;
        this.context = context;
        this.#semanticContext = semanticContext ?? SemanticContext.NONE;
        this.reachesIntoOuterContext = c.reachesIntoOuterContext;
        if (c.precedenceFilterSuppressed !== void 0) {
          this.precedenceFilterSuppressed = c.precedenceFilterSuppressed;
        }
      }
      static duplicate(old, semanticContext) {
        return new _ATNConfig(old, old.state, old.context, semanticContext ?? old.semanticContext);
      }
      static createWithContext(state, alt, context, semanticContext) {
        return new _ATNConfig({ alt }, state, context, semanticContext);
      }
      static createWithConfig(state, config, context) {
        return new _ATNConfig(config, state, context ?? config.context, config.semanticContext);
      }
      static createWithSemanticContext(state, c, semanticContext) {
        return new _ATNConfig(c, state ?? c.state, c.context, semanticContext);
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hashCode = MurmurHash.initialize(7);
          hashCode = MurmurHash.update(hashCode, this.state.stateNumber);
          hashCode = MurmurHash.update(hashCode, this.alt);
          hashCode = MurmurHash.updateFromComparable(hashCode, this.#context);
          hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);
          hashCode = MurmurHash.finish(hashCode, 4);
          this.cachedHashCode = hashCode;
        }
        return this.cachedHashCode;
      }
      /**
       * The stack of invoking states leading to the rule/states associated
       * with this config.  We track only those contexts pushed during
       * execution of the ATN simulator.
       */
      get context() {
        return this.#context;
      }
      set context(context) {
        this.#context = context;
        this.cachedHashCode = void 0;
      }
      /**
       * An ATN configuration is equal to another if both have
       * the same state, they predict the same alternative, and
       * syntactic/semantic contexts are the same.
       */
      equals(other) {
        if (this === other) {
          return true;
        }
        return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
      }
      toString(_recog, showAlt = true) {
        let alt = "";
        if (showAlt) {
          alt = "," + this.alt;
        }
        return "(" + this.state + alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext ? ",up=" + this.reachesIntoOuterContext : "") + ")";
      }
    };
    var ATNState = class _ATNState {
      static {
        __name(this, "ATNState");
      }
      static INVALID_STATE_NUMBER = -1;
      static INVALID_TYPE = 0;
      static BASIC = 1;
      static RULE_START = 2;
      static BLOCK_START = 3;
      static PLUS_BLOCK_START = 4;
      static STAR_BLOCK_START = 5;
      static TOKEN_START = 6;
      static RULE_STOP = 7;
      static BLOCK_END = 8;
      static STAR_LOOP_BACK = 9;
      static STAR_LOOP_ENTRY = 10;
      static PLUS_LOOP_BACK = 11;
      static LOOP_END = 12;
      static stateType = _ATNState.INVALID_STATE_NUMBER;
      stateNumber = 0;
      ruleIndex = 0;
      // at runtime, we don't have Rule objects
      epsilonOnlyTransitions = false;
      /** Used to cache lookahead during parsing, not used during construction */
      nextTokenWithinRule;
      /** Track the transitions emanating from this ATN state. */
      transitions = [];
      hashCode() {
        return this.stateNumber;
      }
      equals(other) {
        return this.stateNumber === other.stateNumber;
      }
      toString() {
        return `${this.stateNumber}`;
      }
      addTransitionAtIndex(index, transition) {
        if (this.transitions.length === 0) {
          this.epsilonOnlyTransitions = transition.isEpsilon;
        } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {
          this.epsilonOnlyTransitions = false;
        }
        this.transitions.splice(index, 0, transition);
      }
      addTransition(transition) {
        if (this.transitions.length === 0) {
          this.epsilonOnlyTransitions = transition.isEpsilon;
        } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {
          this.epsilonOnlyTransitions = false;
        }
        this.transitions.push(transition);
      }
      setTransition(i, e) {
        this.transitions.splice(i, 1, e);
      }
      removeTransition(index) {
        const t = this.transitions.splice(index, 1);
        return t[0];
      }
    };
    var PredictionContext = class _PredictionContext {
      static {
        __name(this, "PredictionContext");
      }
      /**
       * Represents `$` in an array in full context mode, when `$`
       * doesn't mean wildcard: `$ + x = [$,x]`. Here,
       * `$` = {@link EMPTY_RETURN_STATE}.
       */
      static EMPTY_RETURN_STATE = 2147483647;
      static traceATNSimulator = false;
      cachedHashCode;
      constructor(cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
      }
      static calculateEmptyHashCode() {
        let hash = MurmurHash.initialize(31);
        hash = MurmurHash.finish(hash, 0);
        return hash;
      }
      static calculateHashCodeSingle(parent, returnState) {
        let hash = MurmurHash.initialize(31);
        hash = MurmurHash.updateFromComparable(hash, parent);
        hash = MurmurHash.update(hash, returnState);
        hash = MurmurHash.finish(hash, 2);
        return hash;
      }
      static calculateHashCodeList(parents, returnStates) {
        let hash = MurmurHash.initialize(31);
        for (const parent of parents) {
          hash = MurmurHash.updateFromComparable(hash, parent);
        }
        for (const returnState of returnStates) {
          hash = MurmurHash.update(hash, returnState);
        }
        hash = MurmurHash.finish(hash, 2 * parents.length);
        return hash;
      }
      isEmpty() {
        return false;
      }
      hasEmptyPath() {
        return this.getReturnState(this.length - 1) === _PredictionContext.EMPTY_RETURN_STATE;
      }
      hashCode() {
        return this.cachedHashCode;
      }
      toString(_recog) {
        return "";
      }
    };
    var SingletonPredictionContext = class _SingletonPredictionContext extends PredictionContext {
      static {
        __name(this, "SingletonPredictionContext");
      }
      parent;
      returnState;
      constructor(parent, returnState) {
        super(
          parent ? PredictionContext.calculateHashCodeSingle(parent, returnState) : PredictionContext.calculateEmptyHashCode()
        );
        this.parent = parent ?? null;
        this.returnState = returnState;
      }
      getParent(_index) {
        return this.parent;
      }
      getReturnState(_index) {
        return this.returnState;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _SingletonPredictionContext)) {
          return false;
        }
        if (this.hashCode() !== other.hashCode()) {
          return false;
        }
        if (this.returnState !== other.returnState) {
          return false;
        }
        if (this.parent == null) {
          return other.parent == null;
        }
        return this.parent.equals(other.parent);
      }
      toString() {
        const up = this.parent === null ? "" : this.parent.toString();
        if (up.length === 0) {
          if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
            return "$";
          }
          return "" + this.returnState;
        } else {
          return "" + this.returnState + " " + up;
        }
      }
      get length() {
        return 1;
      }
    };
    var EmptyPredictionContext = class _EmptyPredictionContext extends SingletonPredictionContext {
      static {
        __name(this, "EmptyPredictionContext");
      }
      /**
       * Represents `$` in local context prediction, which means wildcard.
       * `*+x = *`.
       */
      static instance = new _EmptyPredictionContext();
      constructor() {
        super(void 0, PredictionContext.EMPTY_RETURN_STATE);
      }
      isEmpty() {
        return true;
      }
      getParent() {
        return null;
      }
      getReturnState() {
        return this.returnState;
      }
      equals(other) {
        return this === other;
      }
      toString() {
        return "$";
      }
    };
    var Transition = class {
      static {
        __name(this, "Transition");
      }
      static INVALID = 0;
      static EPSILON = 1;
      static RANGE = 2;
      static RULE = 3;
      static PREDICATE = 4;
      // e.g., {isType(input.LT(1))}
      static ATOM = 5;
      static ACTION = 6;
      static SET = 7;
      // ~(A|B) or ~atom, wildcard, which convert to next
      static NOT_SET = 8;
      static WILDCARD = 9;
      static PRECEDENCE = 10;
      /** The target of this transition. */
      target;
      constructor(target) {
        this.target = target;
      }
      /**
       * Determines if the transition is an "epsilon" transition.
       *
       * The default implementation returns `false`.
       *
       * @returns `true` if traversing this transition in the ATN does not
       * consume an input symbol; otherwise, `false` if traversing this
       * transition consumes (matches) an input symbol.
       */
      get isEpsilon() {
        return false;
      }
      get label() {
        return null;
      }
      toString() {
        return "";
      }
    };
    var SetTransition = class extends Transition {
      static {
        __name(this, "SetTransition");
      }
      set;
      constructor(target, set) {
        super(target);
        if (set) {
          this.set = set;
        } else {
          this.set = IntervalSet.of(Token.INVALID_TYPE, Token.INVALID_TYPE);
        }
      }
      get transitionType() {
        return Transition.SET;
      }
      get label() {
        return this.set;
      }
      matches(symbol, _minVocabSymbol, _maxVocabSymbol) {
        return this.set.contains(symbol);
      }
      toString() {
        return this.set.toString();
      }
    };
    var NotSetTransition = class extends SetTransition {
      static {
        __name(this, "NotSetTransition");
      }
      get transitionType() {
        return Transition.NOT_SET;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
      }
      toString() {
        return "~" + super.toString();
      }
    };
    var MapKeyEqualityComparator = class {
      static {
        __name(this, "MapKeyEqualityComparator");
      }
      keyComparator;
      constructor(keyComparator) {
        this.keyComparator = keyComparator;
      }
      hashCode(obj) {
        return this.keyComparator.hashCode(obj.key);
      }
      equals(a, b) {
        return this.keyComparator.equals(a.key, b.key);
      }
    };
    var HashMap = class _HashMap {
      static {
        __name(this, "HashMap");
      }
      backingStore;
      constructor(keyComparer) {
        if (keyComparer instanceof _HashMap) {
          this.backingStore = new HashSet(keyComparer.backingStore);
        } else {
          keyComparer = keyComparer ?? DefaultEqualityComparator.instance;
          this.backingStore = new HashSet(new MapKeyEqualityComparator(keyComparer));
        }
      }
      clear() {
        this.backingStore.clear();
      }
      containsKey(key) {
        return this.backingStore.contains({ key });
      }
      get(key) {
        const bucket = this.backingStore.get({ key });
        if (!bucket) {
          return void 0;
        }
        return bucket.value;
      }
      get isEmpty() {
        return this.backingStore.isEmpty;
      }
      /**
       * Sets the value for a key in the map. If the key is not present in the map, it is added.
       * If the key is present, the value is updated and the old value is returned.
       *
       * @param key The key to set.
       * @param value The value to set.
       *
       * @returns The old value for the key, if present.
       */
      set(key, value) {
        const element = this.backingStore.get({ key, value });
        let result;
        if (!element) {
          this.backingStore.add({ key, value });
        } else {
          result = element.value;
          element.value = value;
        }
        return result;
      }
      /**
       * Sets the value for a key in the map if the key is not already present. Otherwise the value is not changed and
       * the old value is returned.
       *
       * @param key The key to set.
       * @param value The value to set.
       *
       * @returns The current value for the key, if present.
       */
      setIfAbsent(key, value) {
        const element = this.backingStore.get({ key, value });
        let result;
        if (!element) {
          this.backingStore.add({ key, value });
        } else {
          result = element.value;
        }
        return result;
      }
      keys() {
        return this.backingStore.toArray().map((bucket) => {
          return bucket.key;
        });
      }
      values() {
        return this.backingStore.toArray().map((bucket) => {
          return bucket.value;
        });
      }
      get size() {
        return this.backingStore.size;
      }
      hashCode() {
        return this.backingStore.hashCode();
      }
      equals(o) {
        return this.backingStore.equals(o.backingStore);
      }
    };
    var TerminalNode = class {
      static {
        __name(this, "TerminalNode");
      }
      parent = null;
      symbol;
      constructor(symbol) {
        this.symbol = symbol;
      }
      getChild(_i) {
        return null;
      }
      getSymbol() {
        return this.symbol;
      }
      getPayload() {
        return this.symbol;
      }
      getSourceInterval() {
        if (this.symbol === null) {
          return Interval.INVALID_INTERVAL;
        }
        const tokenIndex = this.symbol.tokenIndex;
        return new Interval(tokenIndex, tokenIndex);
      }
      getChildCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitTerminal(this);
      }
      getText() {
        return this.symbol?.text ?? "";
      }
      toString() {
        if (this.symbol?.type === Token.EOF) {
          return "<EOF>";
        } else {
          return this.symbol?.text ?? "";
        }
      }
      toStringTree() {
        return this.toString();
      }
    };
    var ErrorNode = class extends TerminalNode {
      static {
        __name(this, "ErrorNode");
      }
      accept(visitor) {
        return visitor.visitErrorNode(this);
      }
    };
    var CommonToken = class _CommonToken {
      static {
        __name(this, "CommonToken");
      }
      /**
       * An empty tuple which is used as the default value of
       * {@link source} for tokens that do not have a source.
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static EMPTY_SOURCE = [null, null];
      /**
       * These properties share a field to reduce the memory footprint of
       * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from
       * the same source and input stream share a reference to the same
       * {@link Pair} containing these values.
       */
      source;
      tokenIndex;
      start;
      stop;
      /**
       * This is the backing field for {@link #getType} and {@link #setType}.
       */
      type;
      /**
       * The (one-based) line number on which the 1st character of this token was.
       */
      line;
      /**
       * The zero-based index of the first character position in its line.
       */
      column;
      /**
       * The token's channel.
       */
      channel;
      /**
       * This is the backing field for {@link getText} when the token text is
       * explicitly set in the constructor or via {@link setText}.
       */
      #text;
      constructor(details) {
        this.type = details.type;
        this.source = details.source;
        this.tokenIndex = details.tokenIndex ?? -1;
        this.line = details.line ?? 0;
        this.column = details.column ?? -1;
        this.channel = details.channel ?? Token.DEFAULT_CHANNEL;
        this.start = details.start ?? 0;
        this.stop = details.stop ?? 0;
        this.#text = details.text;
        if (details.line === void 0 && details.source[0] !== null) {
          this.line = details.source[0].line;
        }
        if (details.column === void 0 && details.source[0] !== null) {
          this.column = details.source[0].column;
        }
      }
      /**
       * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
       *
       * If `token` is also a {@link CommonToken} instance, the newly
       * constructed token will share a reference to the {@link #text} field and
       * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will
       * be assigned the result of calling {@link getText}, and {@link source}
       * will be constructed from the result of {@link Token.getTokenSource} and
       * {@link Token#getInputStream}.
       *
       * @param token The token to copy.
       */
      static fromToken(token) {
        const source = [token.tokenSource, token.inputStream];
        return new _CommonToken({
          type: token.type,
          line: token.line,
          tokenIndex: token.tokenIndex,
          column: token.column,
          channel: token.channel,
          start: token.start,
          stop: token.stop,
          text: token.text,
          source
        });
      }
      /**
       * Constructs a new {@link CommonToken} with the specified token type and text.
       *
       * @param type The token type.
       * @param text The text of the token.
       */
      static fromType(type, text) {
        return new _CommonToken({ type, text, source: _CommonToken.EMPTY_SOURCE });
      }
      static fromSource(source, type, channel, start, stop) {
        return new _CommonToken({ type, channel, start, stop, source });
      }
      get tokenSource() {
        return this.source[0];
      }
      get inputStream() {
        return this.source[1];
      }
      set inputStream(input) {
        this.source[1] = input;
      }
      /**
       * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
       *
       * If `oldToken` is also a {@link CommonToken} instance, the newly
       * constructed token will share a reference to the {@link text} field and
       * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will
       * be assigned the result of calling {@link getText}, and {@link source}
       * will be constructed from the result of {@link Token.getTokenSource} and
       * {@link Token.getInputStream}.
       */
      clone() {
        const t = new _CommonToken({
          source: this.source,
          type: this.type,
          channel: this.channel,
          start: this.start,
          stop: this.stop,
          tokenIndex: this.tokenIndex,
          line: this.line,
          column: this.column,
          text: this.#text
        });
        return t;
      }
      toString(recognizer) {
        let channelStr = "";
        if (this.channel > 0) {
          channelStr = ",channel=" + this.channel;
        }
        let text = this.text;
        if (text) {
          text = text.replace(/\n/g, "\\n");
          text = text.replace(/\r/g, "\\r");
          text = text.replace(/\t/g, "\\t");
        } else {
          text = "<no text>";
        }
        let typeString = String(this.type);
        if (recognizer) {
          typeString = recognizer.vocabulary.getDisplayName(this.type) ?? "<unknown>";
        }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + text + "',<" + typeString + ">" + channelStr + "," + this.line + ":" + this.column + "]";
      }
      get text() {
        if (this.#text !== void 0) {
          return this.#text;
        }
        const input = this.inputStream;
        if (!input) {
          return void 0;
        }
        const n2 = input.size;
        if (this.start < n2 && this.stop < n2) {
          return input.getTextFromRange(this.start, this.stop);
        }
        return "<EOF>";
      }
      set text(text) {
        this.#text = text;
      }
      // WritableToken implementation
      setText(text) {
        this.#text = text;
      }
      setType(ttype) {
        this.type = ttype;
      }
      setLine(line) {
        this.line = line;
      }
      setCharPositionInLine(pos) {
        this.column = pos;
      }
      setChannel(channel) {
        this.channel = channel;
      }
      setTokenIndex(index) {
        this.tokenIndex = index;
      }
    };
    var Trees = class _Trees {
      static {
        __name(this, "Trees");
      }
      /**
       * Print out a whole tree in LISP form. {@link getNodeText} is used on the
       * node payloads to get the text for the nodes.  Detect
       * parse trees and extract data appropriately.
       */
      static toStringTree(tree, ruleNames, recog) {
        ruleNames = ruleNames ?? null;
        if (recog) {
          ruleNames = recog.ruleNames;
        }
        let s = _Trees.getNodeText(tree, ruleNames);
        s = escapeWhitespace(s, false);
        const c = tree.getChildCount();
        if (c === 0) {
          return s;
        }
        let res = "(" + s + " ";
        if (c > 0) {
          s = _Trees.toStringTree(tree.getChild(0), ruleNames);
          res = res.concat(s);
        }
        for (let i = 1; i < c; i++) {
          s = _Trees.toStringTree(tree.getChild(i), ruleNames);
          res = res.concat(" " + s);
        }
        res = res.concat(")");
        return res;
      }
      static getNodeText(t, ruleNames, recog) {
        ruleNames = ruleNames ?? null;
        if (recog) {
          ruleNames = recog.ruleNames;
        }
        if (ruleNames !== null) {
          if (t instanceof ParserRuleContext) {
            const context = t.ruleContext;
            const altNumber = context.getAltNumber();
            if (altNumber !== 0) {
              return ruleNames[t.ruleIndex] + ":" + altNumber;
            }
            return ruleNames[t.ruleIndex];
          } else if (t instanceof ErrorNode) {
            return t.toString();
          } else if (t instanceof TerminalNode) {
            return t.symbol.text;
          }
        }
        const payload = t.getPayload();
        if (isToken(payload)) {
          return payload.text;
        }
        return String(t.getPayload());
      }
      /**
       * Return ordered list of all children of this node
       */
      static getChildren(t) {
        const list = [];
        for (let i = 0; i < t.getChildCount(); i++) {
          list.push(t.getChild(i));
        }
        return list;
      }
      /**
       * Return a list of all ancestors of this node.  The first node of
       * list is the root and the last is the parent of this node.
       */
      static getAncestors(t) {
        if (t.parent === null) {
          return [];
        }
        let ancestors = [];
        let p = t.parent;
        while (p !== null) {
          ancestors = [p].concat(ancestors);
          p = p.parent;
        }
        return ancestors;
      }
      /**
       * Return true if t is u's parent or a node on path to root from u.
       */
      static isAncestorOf(t, u) {
        if (t === null || u === null || t.parent === null) {
          return false;
        }
        let p = u.parent;
        while (p !== null) {
          if (t === p) {
            return true;
          }
          p = p.parent;
        }
        return false;
      }
      static findAllTokenNodes(t, ttype) {
        return _Trees.findAllNodes(t, ttype, true);
      }
      static findAllRuleNodes(t, ruleIndex) {
        return _Trees.findAllNodes(t, ruleIndex, false);
      }
      static findAllNodes(t, index, findTokens) {
        const nodes = [];
        _Trees.doFindAllNodes(t, index, findTokens, nodes);
        return nodes;
      }
      static descendants(t) {
        let nodes = [t];
        for (let i = 0; i < t.getChildCount(); i++) {
          nodes = nodes.concat(_Trees.descendants(t.getChild(i)));
        }
        return nodes;
      }
      /**
       * Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
       * inclusively using post order traversal. Recursive depth-first-search.
       */
      static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
        const n2 = t.getChildCount();
        for (let i = 0; i < n2; i++) {
          const child = t.getChild(i);
          const r = this.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
          if (r !== null) {
            return r;
          }
        }
        if (t instanceof ParserRuleContext) {
          if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
          (t.stop === null || stopTokenIndex <= t.stop.tokenIndex)) {
            return t;
          }
        }
        return null;
      }
      /**
       * Replace any subtree siblings of root that are completely to left
       * or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
       * node. The source interval for t is not altered to suit smaller range!
       *
       * WARNING: destructive to t.
       */
      static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
        if (t === null) {
          return;
        }
        for (let i = 0; i < t.getChildCount(); i++) {
          const child = t.getChild(i);
          const range = child.getSourceInterval();
          if (t instanceof ParserRuleContext && (range.stop < startIndex || range.start > stopIndex)) {
            if (this.isAncestorOf(child, root)) {
              const abbrev = CommonToken.fromType(Token.INVALID_TYPE, "...");
              t.children[i] = new TerminalNode(abbrev);
            }
          }
        }
      }
      static doFindAllNodes(t, index, findTokens, nodes) {
        if (findTokens && t instanceof TerminalNode) {
          if (t.symbol?.type === index) {
            nodes.push(t);
          }
        } else if (!findTokens && t instanceof ParserRuleContext) {
          if (t.ruleIndex === index) {
            nodes.push(t);
          }
        }
        for (let i = 0; i < t.getChildCount(); i++) {
          _Trees.doFindAllNodes(t.getChild(i), index, findTokens, nodes);
        }
      }
    };
    var ParserRuleContext = class _ParserRuleContext {
      static {
        __name(this, "ParserRuleContext");
      }
      static empty = new _ParserRuleContext(null);
      start = null;
      stop = null;
      children = [];
      /**
       * What state invoked the rule associated with this context?
       *  The "return address" is the followState of invokingState
       *  If parent is null, this should be -1 this context object represents
       *  the start rule.
       */
      invokingState;
      parent;
      /**
       * A rule context is a record of a single rule invocation. It knows
       * which context invoked it, if any. If there is no parent context, then
       * naturally the invoking state is not valid.  The parent link
       * provides a chain upwards from the current rule invocation to the root
       * of the invocation tree, forming a stack. We actually carry no
       * information about the rule associated with this context (except
       * when parsing). We keep only the state number of the invoking state from
       * the ATN submachine that invoked this. Contrast this with the s
       * pointer inside ParserRuleContext that tracks the current state
       * being "executed" for the current rule.
       *
       * The parent contexts are useful for computing lookahead sets and
       * getting error information.
       *
       * These objects are used during parsing and prediction.
       * For the special case of parsers, we use the subclass
       * ParserRuleContext.
       */
      constructor(parent, invokingStateNumber = -1) {
        this.parent = parent;
        this.invokingState = invokingStateNumber;
      }
      /** Copy a context */
      copyFrom(ctx) {
        this.parent = ctx.parent;
        this.invokingState = ctx.invokingState;
        this.children.slice(0, this.children.length);
        this.start = ctx.start;
        this.stop = ctx.stop;
        if (ctx.children) {
          ctx.children.forEach((child) => {
            if (child instanceof ErrorNode) {
              this.children.push(child);
              child.parent = this;
            }
          });
        }
      }
      // Double dispatch methods for listeners
      enterRule(_listener) {
      }
      exitRule(_listener) {
      }
      addChild(child) {
        this.children.push(child);
        return child;
      }
      /**
       * Used by enterOuterAlt to toss out a RuleContext previously added as
       * we entered a rule. If we have label, we will need to remove
       * generic ruleContext object.
       */
      removeLastChild() {
        this.children.pop();
      }
      addTokenNode(token) {
        const node = new TerminalNode(token);
        this.children.push(node);
        node.parent = this;
        return node;
      }
      addErrorNode(errorNode) {
        errorNode.parent = this;
        this.children.push(errorNode);
        return errorNode;
      }
      getChild(i, type) {
        if (i < 0 || i >= this.children.length) {
          return null;
        }
        if (!type) {
          return this.children[i];
        }
        for (const child of this.children) {
          if (child instanceof type) {
            if (i === 0) {
              return child;
            } else {
              i -= 1;
            }
          }
        }
        return null;
      }
      getToken(ttype, i) {
        if (i < 0 || i >= this.children.length) {
          return null;
        }
        for (const child of this.children) {
          if ("symbol" in child) {
            if (child.symbol?.type === ttype) {
              if (i === 0) {
                return child;
              } else {
                i -= 1;
              }
            }
          }
        }
        return null;
      }
      getTokens(ttype) {
        const tokens = [];
        for (const child of this.children) {
          if ("symbol" in child) {
            if (child.symbol?.type === ttype) {
              tokens.push(child);
            }
          }
        }
        return tokens;
      }
      // XXX: base the child type selection on the rule index, not the class.
      getRuleContext(index, ctxType) {
        return this.getChild(index, ctxType);
      }
      // XXX: base the child type selection on the rule index, not the class.
      getRuleContexts(ctxType) {
        const contexts = [];
        for (const child of this.children) {
          if (child instanceof ctxType) {
            contexts.push(child);
          }
        }
        return contexts;
      }
      getChildCount() {
        return this.children.length;
      }
      getSourceInterval() {
        if (this.start === null) {
          return Interval.INVALID_INTERVAL;
        }
        if (this.stop === null || this.stop.tokenIndex < this.start.tokenIndex) {
          return new Interval(this.start.tokenIndex, this.start.tokenIndex - 1);
        }
        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
      }
      depth() {
        let n2 = 0;
        let p = this;
        while (p !== null) {
          p = p.parent;
          n2 += 1;
        }
        return n2;
      }
      /**
       * A context is empty if there is no invoking state; meaning nobody call
       * current context.
       */
      isEmpty() {
        return this.invokingState === -1;
      }
      get ruleContext() {
        return this;
      }
      get ruleIndex() {
        return -1;
      }
      getPayload() {
        return this;
      }
      getText() {
        if (this.children.length === 0) {
          return "";
        }
        return this.children.map((child) => {
          return child.getText();
        }).join("");
      }
      /**
       * For rule associated with this parse tree internal node, return
       * the outer alternative number used to match the input. Default
       * implementation does not compute nor store this alt num. Create
       * a subclass of ParserRuleContext with backing field and set
       * option contextSuperClass.
       * to set it.
       */
      getAltNumber() {
        return ATN.INVALID_ALT_NUMBER;
      }
      /**
       * Set the outer alternative number for this context node. Default
       * implementation does nothing to avoid backing field overhead for
       * trees that don't need it.  Create
       * a subclass of ParserRuleContext with backing field and set
       * option contextSuperClass.
       */
      setAltNumber(_altNumber) {
      }
      accept(visitor) {
        return visitor.visitChildren(this);
      }
      toStringTree(...args) {
        if (args.length < 2) {
          return Trees.toStringTree(this, null, args[0]);
        }
        return Trees.toStringTree(this, args[0], args[1]);
      }
      toString(ruleNames, stop) {
        ruleNames = ruleNames ?? null;
        stop = stop ?? null;
        let p = this;
        let s = "[";
        while (p !== null && p !== stop) {
          if (ruleNames === null) {
            if (!p.isEmpty()) {
              s += p.invokingState;
            }
          } else {
            const ri = p.ruleIndex;
            const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
            s += ruleName;
          }
          if (p.parent !== null && (ruleNames !== null || !p.parent.isEmpty())) {
            s += " ";
          }
          p = p.parent;
        }
        s += "]";
        return s;
      }
    };
    var ArrayPredictionContext = class _ArrayPredictionContext extends PredictionContext {
      static {
        __name(this, "ArrayPredictionContext");
      }
      parents = [];
      returnStates = [];
      constructor(parents, returnStates) {
        super(PredictionContext.calculateHashCodeList(parents, returnStates));
        this.parents = parents;
        this.returnStates = returnStates;
        return this;
      }
      isEmpty() {
        return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
      }
      get length() {
        return this.returnStates.length;
      }
      getParent(index) {
        return this.parents[index];
      }
      getReturnState(index) {
        return this.returnStates[index];
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _ArrayPredictionContext) || this.hashCode() !== other.hashCode()) {
          return false;
        }
        return equalNumberArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
      }
      toString() {
        if (this.isEmpty()) {
          return "[]";
        }
        const entries = [];
        for (let i = 0; i < this.returnStates.length; i++) {
          if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
            entries.push("$");
            continue;
          }
          entries.push(this.returnStates[i].toString());
          if (this.parents[i]) {
            entries.push(this.parents[i].toString());
          } else {
            entries.push("null");
          }
        }
        return `[${entries.join(", ")}]`;
      }
    };
    var createSingletonPredictionContext = /* @__PURE__ */ __name((parent, returnState) => {
      if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
        return EmptyPredictionContext.instance;
      } else {
        return new SingletonPredictionContext(parent, returnState);
      }
    }, "createSingletonPredictionContext");
    var predictionContextFromRuleContext = /* @__PURE__ */ __name((atn, outerContext) => {
      if (!outerContext) {
        outerContext = ParserRuleContext.empty;
      }
      if (!outerContext.parent || outerContext === ParserRuleContext.empty) {
        return EmptyPredictionContext.instance;
      }
      const parent = predictionContextFromRuleContext(atn, outerContext.parent);
      const state = atn.states[outerContext.invokingState];
      const transition = state.transitions[0];
      return createSingletonPredictionContext(parent, transition.followState.stateNumber);
    }, "predictionContextFromRuleContext");
    var getCachedPredictionContext = /* @__PURE__ */ __name((context, contextCache, visited) => {
      if (context.isEmpty()) {
        return context;
      }
      let existing = visited.get(context);
      if (existing) {
        return existing;
      }
      existing = contextCache.get(context);
      if (existing) {
        visited.set(context, existing);
        return existing;
      }
      let changed = false;
      let parents = [];
      for (let i = 0; i < parents.length; i++) {
        const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
        if (changed || parent !== context.getParent(i)) {
          if (!changed) {
            parents = [];
            for (let j = 0; j < context.length; j++) {
              parents[j] = context.getParent(j);
            }
            changed = true;
          }
          parents[i] = parent;
        }
      }
      if (!changed) {
        contextCache.add(context);
        visited.set(context, context);
        return context;
      }
      let updated;
      if (parents.length === 0) {
        updated = EmptyPredictionContext.instance;
      } else if (parents.length === 1) {
        updated = createSingletonPredictionContext(parents[0] ?? void 0, context.getReturnState(0));
      } else {
        updated = new ArrayPredictionContext(parents, context.returnStates);
      }
      contextCache.add(updated);
      visited.set(updated, updated);
      visited.set(context, updated);
      return updated;
    }, "getCachedPredictionContext");
    var merge = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
      if (a === b || a.equals(b)) {
        return a;
      }
      if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
        return mergeSingletons(a, b, rootIsWildcard, mergeCache);
      }
      if (rootIsWildcard) {
        if (a instanceof EmptyPredictionContext) {
          return a;
        }
        if (b instanceof EmptyPredictionContext) {
          return b;
        }
      }
      if (a instanceof SingletonPredictionContext) {
        a = new ArrayPredictionContext([a.parent], [a.returnState]);
      }
      if (b instanceof SingletonPredictionContext) {
        b = new ArrayPredictionContext([b.parent], [b.returnState]);
      }
      return mergeArrays(a, b, rootIsWildcard, mergeCache);
    }, "merge");
    var mergeArrays = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
      if (mergeCache) {
        let previous = mergeCache.get(a, b);
        if (previous) {
          return previous;
        }
        previous = mergeCache.get(b, a);
        if (previous) {
          return previous;
        }
      }
      let i = 0;
      let j = 0;
      let k = 0;
      let mergedReturnStates = new Array(a.returnStates.length + b.returnStates.length).fill(0);
      let mergedParents = new Array(a.returnStates.length + b.returnStates.length).fill(null);
      while (i < a.returnStates.length && j < b.returnStates.length) {
        const aParent = a.parents[i];
        const bParent = b.parents[j];
        if (a.returnStates[i] === b.returnStates[j]) {
          const payload = a.returnStates[i];
          const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && aParent === null && bParent === null;
          const axAx = aParent !== null && bParent !== null && aParent === bParent;
          if (bothDollars || axAx) {
            mergedParents[k] = aParent;
            mergedReturnStates[k] = payload;
          } else {
            mergedParents[k] = merge(aParent, bParent, rootIsWildcard, mergeCache);
            mergedReturnStates[k] = payload;
          }
          i += 1;
          j += 1;
        } else if (a.returnStates[i] < b.returnStates[j]) {
          mergedParents[k] = aParent;
          mergedReturnStates[k] = a.returnStates[i];
          i += 1;
        } else {
          mergedParents[k] = bParent;
          mergedReturnStates[k] = b.returnStates[j];
          j += 1;
        }
        k += 1;
      }
      if (i < a.returnStates.length) {
        for (let p = i; p < a.returnStates.length; p++) {
          mergedParents[k] = a.parents[p];
          mergedReturnStates[k] = a.returnStates[p];
          k += 1;
        }
      } else {
        for (let p = j; p < b.returnStates.length; p++) {
          mergedParents[k] = b.parents[p];
          mergedReturnStates[k] = b.returnStates[p];
          k += 1;
        }
      }
      if (k < mergedParents.length) {
        if (k === 1) {
          const aNew = createSingletonPredictionContext(mergedParents[0] ?? void 0, mergedReturnStates[0]);
          if (mergeCache !== null) {
            mergeCache.set(a, b, aNew);
          }
          return aNew;
        }
        mergedParents = mergedParents.slice(0, k);
        mergedReturnStates = mergedReturnStates.slice(0, k);
      }
      const merged = new ArrayPredictionContext(mergedParents, mergedReturnStates);
      if (merged.equals(a)) {
        if (mergeCache !== null) {
          mergeCache.set(a, b, a);
        }
        if (PredictionContext.traceATNSimulator) {
          console.log("mergeArrays a=" + a + ",b=" + b + " -> a");
        }
        return a;
      }
      if (merged.equals(b)) {
        if (mergeCache !== null) {
          mergeCache.set(a, b, b);
        }
        return b;
      }
      combineCommonParents(mergedParents);
      if (mergeCache !== null) {
        mergeCache.set(a, b, merged);
      }
      if (PredictionContext.traceATNSimulator) {
        console.log("mergeArrays a=" + a + ",b=" + b + " -> " + merged);
      }
      return merged;
    }, "mergeArrays");
    var combineCommonParents = /* @__PURE__ */ __name((parents) => {
      const uniqueParents = new HashMap(ObjectEqualityComparator.instance);
      for (const parent of parents) {
        if (parent) {
          if (!uniqueParents.containsKey(parent)) {
            uniqueParents.set(parent, parent);
          }
        }
      }
      for (let q = 0; q < parents.length; q++) {
        if (parents[q]) {
          parents[q] = uniqueParents.get(parents[q]) ?? null;
        }
      }
    }, "combineCommonParents");
    var mergeSingletons = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
      if (mergeCache !== null) {
        let previous = mergeCache.get(a, b);
        if (previous !== null) {
          return previous;
        }
        previous = mergeCache.get(b, a);
        if (previous !== null) {
          return previous;
        }
      }
      const rootMerge = mergeRoot(a, b, rootIsWildcard);
      if (rootMerge !== null) {
        if (mergeCache !== null) {
          mergeCache.set(a, b, rootMerge);
        }
        return rootMerge;
      }
      if (a.returnState === b.returnState) {
        const parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
        if (parent === a.parent) {
          return a;
        }
        if (parent === b.parent) {
          return b;
        }
        const spc = createSingletonPredictionContext(parent, a.returnState);
        if (mergeCache !== null) {
          mergeCache.set(a, b, spc);
        }
        return spc;
      } else {
        let singleParent = null;
        if (a === b || a.parent !== null && a.parent.equals(b.parent)) {
          singleParent = a.parent;
        }
        if (singleParent !== null) {
          const payloads2 = [a.returnState, b.returnState];
          if (a.returnState > b.returnState) {
            payloads2[0] = b.returnState;
            payloads2[1] = a.returnState;
          }
          const parents2 = [singleParent, singleParent];
          const apc = new ArrayPredictionContext(parents2, payloads2);
          if (mergeCache !== null) {
            mergeCache.set(a, b, apc);
          }
          return apc;
        }
        const payloads = [a.returnState, b.returnState];
        let parents = [a.parent, b.parent];
        if (a.returnState > b.returnState) {
          payloads[0] = b.returnState;
          payloads[1] = a.returnState;
          parents = [b.parent, a.parent];
        }
        const aNew = new ArrayPredictionContext(parents, payloads);
        if (mergeCache !== null) {
          mergeCache.set(a, b, aNew);
        }
        return aNew;
      }
    }, "mergeSingletons");
    var mergeRoot = /* @__PURE__ */ __name((a, b, rootIsWildcard) => {
      if (rootIsWildcard) {
        if (a === EmptyPredictionContext.instance || b === EmptyPredictionContext.instance) {
          return EmptyPredictionContext.instance;
        }
      } else {
        if (a === EmptyPredictionContext.instance && b === EmptyPredictionContext.instance) {
          return EmptyPredictionContext.instance;
        }
        if (a === EmptyPredictionContext.instance) {
          const payloads = [
            b.returnState,
            PredictionContext.EMPTY_RETURN_STATE
          ];
          const parents = [b.parent, null];
          return new ArrayPredictionContext(parents, payloads);
        }
        if (b === EmptyPredictionContext.instance) {
          const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];
          const parents = [a.parent, null];
          return new ArrayPredictionContext(parents, payloads);
        }
      }
      return null;
    }, "mergeRoot");
    var LL1Analyzer = class _LL1Analyzer {
      constructor(atn) {
        this.atn = atn;
      }
      static {
        __name(this, "LL1Analyzer");
      }
      /**
       * Special value added to the lookahead sets to indicate that we hit
       * a predicate during analysis if `seeThruPreds==false`.
       */
      static hitPredicate = Token.INVALID_TYPE;
      /**
       * Calculates the SLL(1) expected lookahead set for each outgoing transition
       * of an {@link ATNState}. The returned array has one element for each
       * outgoing transition in `s`. If the closure from transition
       * _i_ leads to a semantic predicate before matching a symbol, the
       * element at index *i* of the result will be `undefined`.
       *
       * @param s the ATN state
       * @returns the expected symbols for each outgoing transition of `s`.
       */
      getDecisionLookahead(s) {
        const count = s.transitions.length;
        const look = new Array(count);
        for (let alt = 0; alt < count; alt++) {
          const set = new IntervalSet();
          const lookBusy = new HashSet();
          this.doLook(
            s.transitions[alt].target,
            void 0,
            EmptyPredictionContext.instance,
            set,
            lookBusy,
            new BitSet(),
            false,
            false
          );
          if (set.length > 0 && !set.contains(_LL1Analyzer.hitPredicate)) {
            look[alt] = set;
          }
        }
        return look;
      }
      /**
       * Compute set of tokens that can follow `s` in the ATN in the
       * specified `ctx`.
       *
       * If `ctx` is `null` and the end of the rule containing
       * `s` is reached, {@link Token//EPSILON} is added to the result set.
       * If `ctx` is not `null` and the end of the outermost rule is
       * reached, {@link Token//EOF} is added to the result set.
       *
       * @param s the ATN state
       * @param stopState the ATN state to stop at. This can be a
       * {@link BlockEndState} to detect epsilon paths through a closure.
       * @param ctx the complete parser context, or `null` if the context
       * should be ignored
       *
       * @returns The set of tokens that can follow `s` in the ATN in the
       * specified `ctx`.
       */
      look(s, stopState, ctx) {
        const r = new IntervalSet();
        const lookContext = ctx ? predictionContextFromRuleContext(this.atn, ctx) : null;
        this.doLook(s, stopState, lookContext, r, new HashSet(), new BitSet(), true, true);
        return r;
      }
      /**
       * Compute set of tokens that can follow `s` in the ATN in the
       * specified `ctx`.
       *
       * If `ctx` is `null` and `stopState` or the end of the
       * rule containing `s` is reached, {@link Token//EPSILON} is added to
       * the result set. If `ctx` is not `null` and `addEOF` is
       * `true` and `stopState` or the end of the outermost rule is
       * reached, {@link Token//EOF} is added to the result set.
       *
       * @param s the ATN state.
       * @param stopState the ATN state to stop at. This can be a
       * {@link BlockEndState} to detect epsilon paths through a closure.
       * @param ctx The outer context, or `null` if the outer context should
       * not be used.
       * @param look The result lookahead set.
       * @param lookBusy A set used for preventing epsilon closures in the ATN
       * from causing a stack overflow. Outside code should pass
       * `new CustomizedSet<ATNConfig>` for this argument.
       * @param calledRuleStack A set used for preventing left recursion in the
       * ATN from causing a stack overflow. Outside code should pass
       * `new BitSet()` for this argument.
       * @param seeThruPreds `true` to true semantic predicates as
       * implicitly `true` and "see through them", otherwise `false`
       * to treat semantic predicates as opaque and add {@link hitPredicate} to the
       * result if one is encountered.
       * @param addEOF Add {@link Token//EOF} to the result if the end of the
       * outermost context is reached. This parameter has no effect if `ctx`
       * is `null`.
       */
      doLook(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
        const c = ATNConfig.createWithContext(s, 0, ctx);
        if (lookBusy.get(c)) {
          return;
        }
        lookBusy.add(c);
        if (s === stopState) {
          if (!ctx) {
            look.addOne(Token.EPSILON);
            return;
          } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
          }
        }
        if (s.constructor.stateType === ATNState.RULE_STOP) {
          if (!ctx) {
            look.addOne(Token.EPSILON);
            return;
          } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
          }
          if (ctx !== EmptyPredictionContext.instance) {
            const removed = calledRuleStack.get(s.ruleIndex);
            try {
              calledRuleStack.clear(s.ruleIndex);
              for (let i = 0; i < ctx.length; i++) {
                const returnState = this.atn.states[ctx.getReturnState(i)];
                this.doLook(
                  returnState,
                  stopState,
                  ctx.getParent(i),
                  look,
                  lookBusy,
                  calledRuleStack,
                  seeThruPreds,
                  addEOF
                );
              }
            } finally {
              if (removed) {
                calledRuleStack.set(s.ruleIndex);
              }
            }
            return;
          }
        }
        for (const t of s.transitions) {
          switch (t.transitionType) {
            case Transition.RULE: {
              if (calledRuleStack.get(t.target.ruleIndex)) {
                continue;
              }
              const newContext = createSingletonPredictionContext(
                ctx ?? void 0,
                t.followState.stateNumber
              );
              try {
                calledRuleStack.set(t.target.ruleIndex);
                this.doLook(
                  t.target,
                  stopState,
                  newContext,
                  look,
                  lookBusy,
                  calledRuleStack,
                  seeThruPreds,
                  addEOF
                );
              } finally {
                calledRuleStack.clear(t.target.ruleIndex);
              }
              break;
            }
            case Transition.PREDICATE:
            case Transition.PRECEDENCE: {
              if (seeThruPreds) {
                this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              } else {
                look.addOne(_LL1Analyzer.hitPredicate);
              }
              break;
            }
            case Transition.WILDCARD: {
              look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
              break;
            }
            default: {
              if (t.isEpsilon) {
                this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              } else {
                let set = t.label;
                if (set) {
                  if (t instanceof NotSetTransition) {
                    set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                  }
                  look.addSet(set);
                }
              }
              break;
            }
          }
        }
      }
    };
    var ATN = class {
      static {
        __name(this, "ATN");
      }
      static INVALID_ALT_NUMBER = 0;
      /** Represents the type of recognizer an ATN applies to */
      static LEXER = 0;
      static PARSER = 1;
      /**
       * Used for runtime deserialization of ATNs from strings
       * The type of the ATN.
       */
      grammarType;
      /** The maximum value for any symbol recognized by a transition in the ATN. */
      maxTokenType;
      states = [];
      /**
       * Each subrule/rule is a decision point and we must track them so we
       * can go back later and build DFA predictors for them.  This includes
       * all the rules, subrules, optional blocks, ()+, ()* etc...
       */
      decisionToState = [];
      /** Maps from rule index to starting state number. */
      ruleToStartState = [];
      // Initialized by the ATN deserializer.
      /** Maps from rule index to stop state number. */
      ruleToStopState = [];
      // Initialized by the ATN deserializer.
      modeNameToStartState = /* @__PURE__ */ new Map();
      /**
       * For lexer ATNs, this maps the rule index to the resulting token type.
       * For parser ATNs, this maps the rule index to the generated bypass token
       * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
       * deserialization option was specified; otherwise, this is `null`
       */
      ruleToTokenType = [];
      // Initialized by the ATN deserializer.
      /**
       * For lexer ATNs, this is an array of {@link LexerAction} objects which may
       * be referenced by action transitions in the ATN
       */
      lexerActions = [];
      modeToStartState = [];
      analyzer;
      constructor(grammarType, maxTokenType) {
        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
        this.analyzer = new LL1Analyzer(this);
      }
      /**
       * Compute the set of valid tokens that can occur starting in state `s`.
       * If `ctx` is null, the set of tokens will not include what can follow
       * the rule surrounding `s`. In other words, the set will be
       * restricted to tokens reachable staying within `s`'s rule.
       */
      nextTokens(atnState, ctx) {
        if (!ctx && atnState.nextTokenWithinRule) {
          return atnState.nextTokenWithinRule;
        }
        const next = this.analyzer.look(atnState, void 0, ctx);
        if (!ctx) {
          atnState.nextTokenWithinRule = next;
        }
        return next;
      }
      addState(state) {
        if (state) {
          state.stateNumber = this.states.length;
        }
        this.states.push(state);
      }
      removeState(state) {
        this.states[state.stateNumber] = null;
      }
      defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length - 1;
        return s.decision;
      }
      getDecisionState(decision) {
        if (this.decisionToState.length === 0) {
          return null;
        } else {
          return this.decisionToState[decision];
        }
      }
      getNumberOfDecisions() {
        return this.decisionToState.length;
      }
      /**
       * Computes the set of input symbols which could follow ATN state number
       * `stateNumber` in the specified full `context`. This method
       * considers the complete parser context, but does not evaluate semantic
       * predicates (i.e. all predicates encountered during the calculation are
       * assumed true). If a path in the ATN exists from the starting state to the
       * {@link RuleStopState} of the outermost context without matching any
       * symbols, {@link Token//EOF} is added to the returned set.
       *
       * If `context` is `null`, it is treated as
       * {@link ParserRuleContext//EMPTY}.
       *
       * @param stateNumber the ATN state number
       * @param context the full parse context
       *
       * @returns {IntervalSet} The set of potentially valid input symbols which could follow the
       * specified state in the specified context.
       *
       * @throws IllegalArgumentException if the ATN does not contain a state with
       * number `stateNumber`
       */
      getExpectedTokens(stateNumber, context) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
          throw new Error("Invalid state number.");
        }
        const s = this.states[stateNumber];
        let following = this.nextTokens(s);
        if (!following.contains(Token.EPSILON)) {
          return following;
        }
        let ctx = context;
        const expected = new IntervalSet();
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
          const invokingState = this.states[ctx.invokingState];
          const rt = invokingState.transitions[0];
          following = this.nextTokens(rt.followState);
          expected.addSet(following);
          expected.removeOne(Token.EPSILON);
          ctx = ctx.parent;
        }
        if (following.contains(Token.EPSILON)) {
          expected.addOne(Token.EOF);
        }
        return expected;
      }
    };
    var KeyTypeEqualityComparer = class _KeyTypeEqualityComparer {
      static {
        __name(this, "KeyTypeEqualityComparer");
      }
      static instance = new _KeyTypeEqualityComparer();
      hashCode(config) {
        let hashCode = 7;
        hashCode = 31 * hashCode + config.state.stateNumber;
        hashCode = 31 * hashCode + config.alt;
        hashCode = 31 * hashCode + config.semanticContext.hashCode();
        return hashCode;
      }
      equals(a, b) {
        if (a === b) {
          return true;
        }
        return a.state.stateNumber === b.state.stateNumber && a.alt === b.alt && a.semanticContext.equals(b.semanticContext);
      }
    };
    var ATNConfigSet = class {
      static {
        __name(this, "ATNConfigSet");
      }
      /**
       * The reason that we need this is because we don't want the hash map to use
       * the standard hash code and equals. We need all configurations with the
       * same
       * `(s,i,_,semctx)` to be equal. Unfortunately, this key effectively
       * doubles
       * the number of objects associated with ATNConfigs. The other solution is
       * to
       * use a hash table that lets us specify the equals/hashCode operation.
       * All configs but hashed by (s, i, _, pi) not including context. Wiped out
       * when we go readonly as this set becomes a DFA state
       */
      configLookup = new HashSet(KeyTypeEqualityComparer.instance);
      // Track the elements as they are added to the set; supports get(i).
      configs = [];
      uniqueAlt = 0;
      /**
       * Used in parser and lexer. In lexer, it indicates we hit a pred
       * while computing a closure operation. Don't make a DFA state from this
       */
      hasSemanticContext = false;
      dipsIntoOuterContext = false;
      /**
       * Indicates that this configuration set is part of a full context
       * LL prediction. It will be used to determine how to merge $. With SLL
       * it's a wildcard whereas it is not for LL context merge
       */
      fullCtx = false;
      /**
       * Indicates that the set of configurations is read-only. Do not
       * allow any code to manipulate the set; DFA states will point at
       * the sets and they must not change. This does not protect the other
       * fields; in particular, conflictingAlts is set after
       * we've made this readonly
       */
      readOnly = false;
      conflictingAlts = null;
      /**
       * Tracks the first config that has a rule stop state. Avoids frequent linear search for that, when adding
       * a DFA state in the lexer ATN simulator.
       */
      firstStopState;
      #cachedHashCode = -1;
      constructor(fullCtxOrOldSet) {
        if (fullCtxOrOldSet !== void 0) {
          if (typeof fullCtxOrOldSet === "boolean") {
            this.fullCtx = fullCtxOrOldSet ?? true;
          } else {
            const old = fullCtxOrOldSet;
            this.addAll(old.configs);
            this.uniqueAlt = old.uniqueAlt;
            this.conflictingAlts = old.conflictingAlts;
            this.hasSemanticContext = old.hasSemanticContext;
            this.dipsIntoOuterContext = old.dipsIntoOuterContext;
          }
        }
      }
      [Symbol.iterator]() {
        return this.configs[Symbol.iterator]();
      }
      /**
       * Adding a new config means merging contexts with existing configs for
       * `(s, i, pi, _)`, where `s` is the {@link ATNConfig.state}, `i` is the {@link ATNConfig.alt}, and
       * `pi` is the {@link ATNConfig.semanticContext}. We use `(s,i,pi)` as key.
       *
       * This method updates {@link dipsIntoOuterContext} and
       * {@link hasSemanticContext} when necessary.
       */
      add(config, mergeCache = null) {
        if (this.readOnly) {
          throw new Error("This set is readonly");
        }
        if (!this.firstStopState && config.state.constructor.stateType === ATNState.RULE_STOP) {
          this.firstStopState = config;
        }
        this.hasSemanticContext ||= config.semanticContext !== SemanticContext.NONE;
        this.dipsIntoOuterContext ||= config.reachesIntoOuterContext;
        const existing = this.configLookup.getOrAdd(config);
        if (existing === config) {
          this.#cachedHashCode = -1;
          this.configs.push(config);
          return;
        }
        const rootIsWildcard = !this.fullCtx;
        const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
        existing.reachesIntoOuterContext ||= config.reachesIntoOuterContext;
        existing.precedenceFilterSuppressed ||= config.precedenceFilterSuppressed;
        existing.context = merged;
      }
      /** Return a List holding list of configs */
      get elements() {
        return this.configs;
      }
      /**
       * Gets the complete set of represented alternatives for the configuration set.
       *
       * @returns the set of represented alternatives in this configuration set
       */
      getAlts() {
        const alts = new BitSet();
        for (const config of this.configs) {
          alts.set(config.alt);
        }
        return alts;
      }
      getPredicates() {
        const preds = [];
        for (const config of this.configs) {
          if (config.semanticContext !== SemanticContext.NONE) {
            preds.push(config.semanticContext);
          }
        }
        return preds;
      }
      getStates() {
        const states = new HashSet();
        for (const config of this.configs) {
          states.add(config.state);
        }
        return states;
      }
      optimizeConfigs(interpreter) {
        if (this.readOnly) {
          throw new Error("This set is readonly");
        }
        if (this.configLookup.size === 0) {
          return;
        }
        for (const config of this.configs) {
          config.context = interpreter.getCachedContext(config.context);
        }
      }
      addAll(coll) {
        for (const config of coll) {
          this.add(config);
        }
        return false;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext && equalArrays(this.configs, other.configs)) {
          return true;
        }
        return false;
      }
      hashCode() {
        if (this.#cachedHashCode === -1) {
          this.#cachedHashCode = this.computeHashCode();
        }
        return this.#cachedHashCode;
      }
      get length() {
        return this.configs.length;
      }
      isEmpty() {
        return this.configs.length === 0;
      }
      contains(item) {
        if (this.configLookup === null) {
          throw new Error("This method is not implemented for readonly sets.");
        }
        return this.configLookup.contains(item);
      }
      containsFast(item) {
        if (this.configLookup === null) {
          throw new Error("This method is not implemented for readonly sets.");
        }
        return this.configLookup.contains(item);
      }
      clear() {
        if (this.readOnly) {
          throw new Error("This set is readonly");
        }
        this.configs = [];
        this.#cachedHashCode = -1;
        this.configLookup = new HashSet(KeyTypeEqualityComparer.instance);
      }
      setReadonly(readOnly) {
        this.readOnly = readOnly;
        if (readOnly) {
          this.configLookup = null;
        }
      }
      toString() {
        return arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
      }
      computeHashCode() {
        let hash = MurmurHash.initialize();
        this.configs.forEach((config) => {
          hash = MurmurHash.update(hash, config.hashCode());
        });
        hash = MurmurHash.finish(hash, this.configs.length);
        return hash;
      }
    };
    var BasicState = class extends ATNState {
      static {
        __name(this, "BasicState");
      }
      static stateType = ATNState.BASIC;
    };
    var DecisionState = class extends ATNState {
      static {
        __name(this, "DecisionState");
      }
      decision = -1;
      nonGreedy = false;
    };
    var BlockStartState = class extends DecisionState {
      static {
        __name(this, "BlockStartState");
      }
      endState;
    };
    var BlockEndState = class extends ATNState {
      static {
        __name(this, "BlockEndState");
      }
      static stateType = ATNState.BLOCK_END;
      startState;
    };
    var LoopEndState = class extends ATNState {
      static {
        __name(this, "LoopEndState");
      }
      static stateType = ATNState.LOOP_END;
      loopBackState;
    };
    var RuleStartState = class extends ATNState {
      static {
        __name(this, "RuleStartState");
      }
      static stateType = ATNState.RULE_START;
      stopState;
      isLeftRecursiveRule = false;
    };
    var RuleStopState = class extends ATNState {
      static {
        __name(this, "RuleStopState");
      }
      static stateType = ATNState.RULE_STOP;
    };
    var TokensStartState = class extends DecisionState {
      static {
        __name(this, "TokensStartState");
      }
      static stateType = ATNState.TOKEN_START;
    };
    var PlusLoopbackState = class extends DecisionState {
      static {
        __name(this, "PlusLoopbackState");
      }
      static stateType = ATNState.PLUS_LOOP_BACK;
    };
    var StarLoopbackState = class extends ATNState {
      static {
        __name(this, "StarLoopbackState");
      }
      static stateType = ATNState.STAR_LOOP_BACK;
    };
    var StarLoopEntryState = class extends DecisionState {
      static {
        __name(this, "StarLoopEntryState");
      }
      static stateType = ATNState.STAR_LOOP_ENTRY;
      // This is always set during ATN deserialization
      loopBackState;
      /**
       * Indicates whether this state can benefit from a precedence DFA during SLL
       * decision making.
       *
       * This is a computed property that is calculated during ATN deserialization
       * and stored for use in {@link ParserATNSimulator} and
       * {@link ParserInterpreter}.
       *
       * @see `DFA.isPrecedenceDfa`
       */
      precedenceRuleDecision = false;
    };
    var PlusBlockStartState = class extends BlockStartState {
      static {
        __name(this, "PlusBlockStartState");
      }
      static stateType = ATNState.PLUS_BLOCK_START;
      loopBackState;
    };
    var StarBlockStartState = class extends BlockStartState {
      static {
        __name(this, "StarBlockStartState");
      }
      static stateType = ATNState.STAR_BLOCK_START;
    };
    var BasicBlockStartState = class extends BlockStartState {
      static {
        __name(this, "BasicBlockStartState");
      }
      static stateType = ATNState.BLOCK_START;
    };
    var AtomTransition = class extends Transition {
      static {
        __name(this, "AtomTransition");
      }
      /** The token type or character value; or, signifies special label. */
      labelValue;
      #label;
      constructor(target, label) {
        super(target);
        this.labelValue = label;
        this.#label = IntervalSet.of(label, label);
      }
      get label() {
        return this.#label;
      }
      get transitionType() {
        return Transition.ATOM;
      }
      matches(symbol) {
        return this.labelValue === symbol;
      }
      toString() {
        return this.labelValue.toString();
      }
    };
    var RuleTransition = class extends Transition {
      static {
        __name(this, "RuleTransition");
      }
      ruleIndex;
      precedence;
      followState;
      constructor(ruleStart, ruleIndex, precedence, followState) {
        super(ruleStart);
        this.ruleIndex = ruleIndex;
        this.precedence = precedence;
        this.followState = followState;
      }
      get isEpsilon() {
        return true;
      }
      get transitionType() {
        return Transition.RULE;
      }
      matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
        return false;
      }
    };
    var RangeTransition = class extends Transition {
      static {
        __name(this, "RangeTransition");
      }
      start;
      stop;
      #label = new IntervalSet();
      constructor(target, start, stop) {
        super(target);
        this.start = start;
        this.stop = stop;
        this.#label.addRange(start, stop);
      }
      get label() {
        return this.#label;
      }
      get transitionType() {
        return Transition.RANGE;
      }
      matches(symbol, _minVocabSymbol, _maxVocabSymbol) {
        return symbol >= this.start && symbol <= this.stop;
      }
      toString() {
        return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
      }
    };
    var ActionTransition = class extends Transition {
      static {
        __name(this, "ActionTransition");
      }
      ruleIndex;
      actionIndex;
      isCtxDependent;
      constructor(target, ruleIndex, actionIndex, isCtxDependent) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex ?? -1;
        this.isCtxDependent = isCtxDependent ?? false;
      }
      get isEpsilon() {
        return true;
      }
      get transitionType() {
        return Transition.ACTION;
      }
      matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
        return false;
      }
      toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
      }
    };
    var EpsilonTransition = class extends Transition {
      static {
        __name(this, "EpsilonTransition");
      }
      #outermostPrecedenceReturn;
      constructor(target, outermostPrecedenceReturn = -1) {
        super(target);
        this.#outermostPrecedenceReturn = outermostPrecedenceReturn;
      }
      /**
       * @returns the rule index of a precedence rule for which this transition is
       * returning from, where the precedence value is 0; otherwise, -1.
       *
       * @see ATNConfig.isPrecedenceFilterSuppressed()
       * @see ParserATNSimulator.applyPrecedenceFilter(ATNConfigSet)
       * @since 4.4.1
       */
      get outermostPrecedenceReturn() {
        return this.#outermostPrecedenceReturn;
      }
      get isEpsilon() {
        return true;
      }
      get transitionType() {
        return Transition.EPSILON;
      }
      matches() {
        return false;
      }
      toString() {
        return "epsilon";
      }
    };
    var WildcardTransition = class extends Transition {
      static {
        __name(this, "WildcardTransition");
      }
      get transitionType() {
        return Transition.WILDCARD;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
      }
      toString() {
        return ".";
      }
    };
    var AbstractPredicateTransition = class extends Transition {
      static {
        __name(this, "AbstractPredicateTransition");
      }
      constructor(target) {
        super(target);
      }
    };
    var PredicateTransition = class extends AbstractPredicateTransition {
      static {
        __name(this, "PredicateTransition");
      }
      ruleIndex;
      predIndex;
      isCtxDependent;
      // e.g., $i ref in pred
      constructor(target, ruleIndex, predIndex, isCtxDependent) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get isEpsilon() {
        return true;
      }
      matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
        return false;
      }
      get transitionType() {
        return Transition.PREDICATE;
      }
      getPredicate() {
        return new SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
      }
      toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
      }
    };
    var PrecedencePredicateTransition = class extends AbstractPredicateTransition {
      static {
        __name(this, "PrecedencePredicateTransition");
      }
      precedence;
      constructor(target, precedence) {
        super(target);
        this.precedence = precedence;
      }
      get isEpsilon() {
        return true;
      }
      matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
        return false;
      }
      getPredicate() {
        return new SemanticContext.PrecedencePredicate(this.precedence);
      }
      get transitionType() {
        return Transition.PRECEDENCE;
      }
      toString() {
        return this.precedence + " >= _p";
      }
    };
    var LexerActionType = {
      /** The type of a {@link LexerChannelAction} action. */
      CHANNEL: 0,
      /** The type of a {@link LexerCustomAction} action */
      CUSTOM: 1,
      /** The type of a {@link LexerModeAction} action. */
      MODE: 2,
      /** The type of a {@link LexerMoreAction} action. */
      MORE: 3,
      /** The type of a {@link LexerPopModeAction} action. */
      POP_MODE: 4,
      /** The type of a {@link LexerPushModeAction} action. */
      PUSH_MODE: 5,
      /** The type of a {@link LexerSkipAction} action. */
      SKIP: 6,
      /** The type of a {@link LexerTypeAction} action. */
      TYPE: 7
    };
    var LexerSkipAction = class _LexerSkipAction {
      static {
        __name(this, "LexerSkipAction");
      }
      /** Provides a singleton instance of this parameter-less lexer action. */
      static instance = new _LexerSkipAction();
      actionType;
      isPositionDependent = false;
      constructor() {
        this.actionType = LexerActionType.SKIP;
      }
      equals(obj) {
        return obj === this;
      }
      hashCode() {
        return LexerActionType.SKIP;
      }
      execute(lexer) {
        lexer.skip();
      }
      toString() {
        return "skip";
      }
    };
    var LexerChannelAction = class _LexerChannelAction {
      static {
        __name(this, "LexerChannelAction");
      }
      channel;
      actionType;
      isPositionDependent = false;
      cachedHashCode;
      constructor(channel) {
        this.actionType = LexerActionType.CHANNEL;
        this.channel = channel;
      }
      /**
       * This action is implemented by calling {@link Lexer.setChannel} with the
       * value provided by {@link getChannel}.
       */
      execute(lexer) {
        lexer.channel = this.channel;
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          hash = MurmurHash.update(hash, this.actionType);
          hash = MurmurHash.update(hash, this.channel);
          this.cachedHashCode = MurmurHash.finish(hash, 2);
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _LexerChannelAction)) {
          return false;
        }
        return this.channel === other.channel;
      }
      toString() {
        return "channel(" + this.channel + ")";
      }
    };
    var LexerCustomAction = class _LexerCustomAction {
      static {
        __name(this, "LexerCustomAction");
      }
      ruleIndex;
      actionIndex;
      actionType;
      isPositionDependent = true;
      cachedHashCode;
      /**
       * Constructs a custom lexer action with the specified rule and action indexes.
       *
       * @param ruleIndex The rule index to use for calls to {@link Recognizer.action}.
       * @param actionIndex The action index to use for calls to {@link Recognizer.action}.
       */
      constructor(ruleIndex, actionIndex) {
        this.actionType = LexerActionType.CUSTOM;
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
      }
      /**
       * Custom actions are implemented by calling {@link Lexer.action} with the
       * appropriate rule and action indexes.
       */
      execute(lexer) {
        lexer.action(null, this.ruleIndex, this.actionIndex);
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          hash = MurmurHash.update(hash, this.actionType);
          hash = MurmurHash.update(hash, this.ruleIndex);
          hash = MurmurHash.update(hash, this.actionIndex);
          this.cachedHashCode = MurmurHash.finish(hash, 3);
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _LexerCustomAction)) {
          return false;
        }
        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
      }
    };
    var LexerMoreAction = class _LexerMoreAction {
      static {
        __name(this, "LexerMoreAction");
      }
      static instance = new _LexerMoreAction();
      actionType;
      isPositionDependent = false;
      constructor() {
        this.actionType = LexerActionType.MORE;
      }
      equals(obj) {
        return obj === this;
      }
      hashCode() {
        return LexerActionType.MORE;
      }
      /**
       * This action is implemented by calling {@link Lexer.popMode}.
       */
      execute(lexer) {
        lexer.more();
      }
      toString() {
        return "more";
      }
    };
    var LexerTypeAction = class _LexerTypeAction {
      static {
        __name(this, "LexerTypeAction");
      }
      type;
      actionType;
      isPositionDependent = false;
      cachedHashCode;
      constructor(type) {
        this.actionType = LexerActionType.TYPE;
        this.type = type;
      }
      execute(lexer) {
        lexer.type = this.type;
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          hash = MurmurHash.update(hash, this.actionType);
          hash = MurmurHash.update(hash, this.type);
          this.cachedHashCode = MurmurHash.finish(hash, 2);
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _LexerTypeAction)) {
          return false;
        }
        return this.type === other.type;
      }
      toString() {
        return "type(" + this.type + ")";
      }
    };
    var LexerPushModeAction = class _LexerPushModeAction {
      static {
        __name(this, "LexerPushModeAction");
      }
      mode;
      actionType;
      isPositionDependent = false;
      cachedHashCode;
      constructor(mode) {
        this.actionType = LexerActionType.PUSH_MODE;
        this.mode = mode;
      }
      /**
       * This action is implemented by calling {@link Lexer.pushMode} with the
       * value provided by {@link getMode}.
       */
      execute(lexer) {
        lexer.pushMode(this.mode);
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          hash = MurmurHash.update(hash, this.actionType);
          hash = MurmurHash.update(hash, this.mode);
          this.cachedHashCode = MurmurHash.finish(hash, 2);
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _LexerPushModeAction)) {
          return false;
        }
        return this.mode === other.mode;
      }
      toString() {
        return "pushMode(" + this.mode + ")";
      }
    };
    var LexerPopModeAction = class _LexerPopModeAction {
      static {
        __name(this, "LexerPopModeAction");
      }
      static instance = new _LexerPopModeAction();
      actionType;
      isPositionDependent = false;
      constructor() {
        this.actionType = LexerActionType.POP_MODE;
      }
      equals(obj) {
        return obj === this;
      }
      hashCode() {
        return LexerActionType.POP_MODE;
      }
      /**
       * This action is implemented by calling {@link Lexer//popMode}.
       */
      execute(lexer) {
        lexer.popMode();
      }
      toString() {
        return "popMode";
      }
    };
    var LexerModeAction = class _LexerModeAction {
      static {
        __name(this, "LexerModeAction");
      }
      mode;
      actionType;
      isPositionDependent = false;
      cachedHashCode;
      constructor(mode) {
        this.actionType = LexerActionType.MODE;
        this.mode = mode;
      }
      /**
       * This action is implemented by calling {@link Lexer.mode} with the
       * value provided by {@link getMode}.
       */
      execute(lexer) {
        lexer.mode = this.mode;
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          hash = MurmurHash.update(hash, this.actionType);
          hash = MurmurHash.update(hash, this.mode);
          this.cachedHashCode = MurmurHash.finish(hash, 2);
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _LexerModeAction)) {
          return false;
        }
        return this.mode === other.mode;
      }
      toString() {
        return "mode(" + this.mode + ")";
      }
    };
    var ATNDeserializer = class _ATNDeserializer {
      static {
        __name(this, "ATNDeserializer");
      }
      static SERIALIZED_VERSION = 4;
      static stateTypeMapper = /* @__PURE__ */ new Map([
        [ATNState.INVALID_TYPE, void 0],
        [ATNState.BASIC, BasicState],
        [ATNState.RULE_START, RuleStartState],
        [ATNState.BLOCK_START, BasicBlockStartState],
        [ATNState.PLUS_BLOCK_START, PlusBlockStartState],
        [ATNState.STAR_BLOCK_START, StarBlockStartState],
        [ATNState.TOKEN_START, TokensStartState],
        [ATNState.RULE_STOP, RuleStopState],
        [ATNState.BLOCK_END, BlockEndState],
        [ATNState.STAR_LOOP_BACK, StarLoopbackState],
        [ATNState.STAR_LOOP_ENTRY, StarLoopEntryState],
        [ATNState.PLUS_LOOP_BACK, PlusLoopbackState],
        [ATNState.LOOP_END, LoopEndState]
      ]);
      static lexerActionFactoryMapper = /* @__PURE__ */ new Map([
        [LexerActionType.CHANNEL, (data1) => {
          return new LexerChannelAction(data1);
        }],
        [LexerActionType.CUSTOM, (data1, data2) => {
          return new LexerCustomAction(data1, data2);
        }],
        [LexerActionType.MODE, (data1) => {
          return new LexerModeAction(data1);
        }],
        [LexerActionType.MORE, () => {
          return LexerMoreAction.instance;
        }],
        [LexerActionType.POP_MODE, () => {
          return LexerPopModeAction.instance;
        }],
        [LexerActionType.PUSH_MODE, (data1) => {
          return new LexerPushModeAction(data1);
        }],
        [LexerActionType.SKIP, () => {
          return LexerSkipAction.instance;
        }],
        [LexerActionType.TYPE, (data1) => {
          return new LexerTypeAction(data1);
        }]
      ]);
      data = [];
      pos = 0;
      deserializationOptions;
      actionFactories;
      constructor(options) {
        if (!options) {
          options = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: false };
        }
        this.deserializationOptions = options;
      }
      deserialize(data) {
        this.data = data;
        this.checkVersion();
        const atn = this.readATN();
        this.readStates(atn);
        this.readRules(atn);
        this.readModes(atn);
        const sets = [];
        this.readSets(atn, sets);
        this.readEdges(atn, sets);
        this.readDecisions(atn);
        this.readLexerActions(atn);
        this.markPrecedenceDecisions(atn);
        this.verifyATN(atn);
        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATN.PARSER) {
          this.generateRuleBypassTransitions(atn);
          this.verifyATN(atn);
        }
        return atn;
      }
      checkVersion() {
        const version = this.data[this.pos++];
        if (version !== _ATNDeserializer.SERIALIZED_VERSION) {
          throw new Error("Could not deserialize ATN with version " + version + " (expected " + _ATNDeserializer.SERIALIZED_VERSION + ").");
        }
      }
      readATN() {
        const grammarType = this.data[this.pos++];
        const maxTokenType = this.data[this.pos++];
        return new ATN(grammarType, maxTokenType);
      }
      readStates(atn) {
        let j;
        let stateNumber;
        const loopBackStateNumbers = [];
        const endStateNumbers = [];
        const stateCount = this.data[this.pos++];
        for (let i = 0; i < stateCount; i++) {
          const stateType = this.data[this.pos++];
          if (stateType === ATNState.INVALID_TYPE) {
            atn.addState(null);
            continue;
          }
          const ruleIndex = this.data[this.pos++];
          const s = this.stateFactory(stateType, ruleIndex);
          if (stateType === ATNState.LOOP_END) {
            const loopBackStateNumber = this.data[this.pos++];
            loopBackStateNumbers.push([s, loopBackStateNumber]);
          } else if (s instanceof BlockStartState) {
            const endStateNumber = this.data[this.pos++];
            endStateNumbers.push([s, endStateNumber]);
          }
          atn.addState(s);
        }
        for (j = 0; j < loopBackStateNumbers.length; j++) {
          const pair = loopBackStateNumbers[j];
          pair[0].loopBackState = atn.states[pair[1]] ?? void 0;
        }
        for (j = 0; j < endStateNumbers.length; j++) {
          const pair = endStateNumbers[j];
          pair[0].endState = atn.states[pair[1]];
        }
        const numNonGreedyStates = this.data[this.pos++];
        for (j = 0; j < numNonGreedyStates; j++) {
          stateNumber = this.data[this.pos++];
          atn.states[stateNumber].nonGreedy = true;
        }
        const numPrecedenceStates = this.data[this.pos++];
        for (j = 0; j < numPrecedenceStates; j++) {
          stateNumber = this.data[this.pos++];
          atn.states[stateNumber].isLeftRecursiveRule = true;
        }
      }
      readRules(atn) {
        let i;
        const ruleCount = this.data[this.pos++];
        if (atn.grammarType === ATN.LEXER) {
          atn.ruleToTokenType = new Array(ruleCount);
          atn.ruleToTokenType.fill(0);
        }
        atn.ruleToStartState = new Array(ruleCount);
        atn.ruleToStartState.fill(null);
        for (i = 0; i < ruleCount; i++) {
          const s = this.data[this.pos++];
          atn.ruleToStartState[i] = atn.states[s];
          if (atn.grammarType === ATN.LEXER) {
            const tokenType = this.data[this.pos++];
            atn.ruleToTokenType[i] = tokenType;
          }
        }
        atn.ruleToStopState = new Array(ruleCount);
        atn.ruleToStopState.fill(null);
        for (i = 0; i < atn.states.length; i++) {
          const state = atn.states[i];
          if (!(state instanceof RuleStopState)) {
            continue;
          }
          atn.ruleToStopState[state.ruleIndex] = state;
          atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
      }
      readModes(atn) {
        const modeCount = this.data[this.pos++];
        for (let i = 0; i < modeCount; i++) {
          const s = this.data[this.pos++];
          atn.modeToStartState.push(atn.states[s]);
        }
      }
      readSets(atn, sets) {
        const m2 = this.data[this.pos++];
        for (let i = 0; i < m2; i++) {
          const intervalSet = new IntervalSet();
          sets.push(intervalSet);
          const n2 = this.data[this.pos++];
          const containsEof = this.data[this.pos++];
          if (containsEof !== 0) {
            intervalSet.addOne(-1);
          }
          for (let j = 0; j < n2; j++) {
            const i1 = this.data[this.pos++];
            const i2 = this.data[this.pos++];
            intervalSet.addRange(i1, i2);
          }
        }
      }
      readEdges(atn, sets) {
        let i;
        let j;
        let state;
        let trans;
        let target;
        const edgeCount = this.data[this.pos++];
        for (i = 0; i < edgeCount; i++) {
          const src = this.data[this.pos++];
          const trg = this.data[this.pos++];
          const ttype = this.data[this.pos++];
          const arg1 = this.data[this.pos++];
          const arg2 = this.data[this.pos++];
          const arg3 = this.data[this.pos++];
          trans = this.edgeFactory(atn, ttype, trg, arg1, arg2, arg3, sets);
          const srcState = atn.states[src];
          srcState.addTransition(trans);
        }
        for (i = 0; i < atn.states.length; i++) {
          state = atn.states[i];
          for (j = 0; j < state.transitions.length; j++) {
            const t = state.transitions[j];
            if (!(t instanceof RuleTransition)) {
              continue;
            }
            let outermostPrecedenceReturn = -1;
            if (atn.ruleToStartState[t.target.ruleIndex].isLeftRecursiveRule) {
              if (t.precedence === 0) {
                outermostPrecedenceReturn = t.target.ruleIndex;
              }
            }
            trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
            atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
          }
        }
        for (i = 0; i < atn.states.length; i++) {
          state = atn.states[i];
          if (state instanceof BlockStartState) {
            if (!state.endState) {
              throw new Error("IllegalState");
            }
            if (state.endState.startState) {
              throw new Error("IllegalState");
            }
            state.endState.startState = state;
          }
          if (state instanceof PlusLoopbackState) {
            for (j = 0; j < state.transitions.length; j++) {
              target = state.transitions[j].target;
              if (target instanceof PlusBlockStartState) {
                target.loopBackState = state;
              }
            }
          } else if (state instanceof StarLoopbackState) {
            for (j = 0; j < state.transitions.length; j++) {
              target = state.transitions[j].target;
              if (target instanceof StarLoopEntryState) {
                target.loopBackState = state;
              }
            }
          }
        }
      }
      readDecisions(atn) {
        const decisionCount = this.data[this.pos++];
        for (let i = 0; i < decisionCount; i++) {
          const s = this.data[this.pos++];
          const decState = atn.states[s];
          atn.decisionToState.push(decState);
          decState.decision = i;
        }
      }
      readLexerActions(atn) {
        if (atn.grammarType === ATN.LEXER) {
          const count = this.data[this.pos++];
          atn.lexerActions = [];
          for (let i = 0; i < count; i++) {
            const actionType = this.data[this.pos++];
            const data1 = this.data[this.pos++];
            const data2 = this.data[this.pos++];
            atn.lexerActions.push(this.lexerActionFactory(actionType, data1, data2));
          }
        }
      }
      generateRuleBypassTransitions(atn) {
        let i;
        const count = atn.ruleToStartState.length;
        for (i = 0; i < count; i++) {
          atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
        }
        for (i = 0; i < count; i++) {
          this.generateRuleBypassTransition(atn, i);
        }
      }
      generateRuleBypassTransition(atn, idx) {
        let i;
        let state;
        const bypassStart = new BasicBlockStartState();
        bypassStart.ruleIndex = idx;
        atn.addState(bypassStart);
        const bypassStop = new BlockEndState();
        bypassStop.ruleIndex = idx;
        atn.addState(bypassStop);
        bypassStart.endState = bypassStop;
        atn.defineDecisionState(bypassStart);
        bypassStop.startState = bypassStart;
        let excludeTransition = null;
        let endState = null;
        if (atn.ruleToStartState[idx].isLeftRecursiveRule) {
          endState = null;
          for (i = 0; i < atn.states.length; i++) {
            state = atn.states[i];
            if (this.stateIsEndStateFor(state, idx)) {
              endState = state;
              excludeTransition = state.loopBackState.transitions[0];
              break;
            }
          }
          if (excludeTransition === null) {
            throw new Error("Couldn't identify final state of the precedence rule prefix section.");
          }
        } else {
          endState = atn.ruleToStopState[idx];
        }
        for (i = 0; i < atn.states.length; i++) {
          state = atn.states[i];
          for (const transition of state.transitions) {
            if (transition === excludeTransition) {
              continue;
            }
            if (transition.target === endState) {
              transition.target = bypassStop;
            }
          }
        }
        const ruleToStartState = atn.ruleToStartState[idx];
        while (ruleToStartState.transitions.length > 0) {
          const transition = ruleToStartState.removeTransition(ruleToStartState.transitions.length - 1);
          bypassStart.addTransition(transition);
        }
        atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
        if (endState) {
          bypassStop.addTransition(new EpsilonTransition(endState));
        }
        const matchState = new BasicState();
        atn.addState(matchState);
        matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
        bypassStart.addTransition(new EpsilonTransition(matchState));
      }
      stateIsEndStateFor(state, idx) {
        if (state.ruleIndex !== idx) {
          return null;
        }
        if (!(state instanceof StarLoopEntryState)) {
          return null;
        }
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
        if (!(maybeLoopEndState instanceof LoopEndState)) {
          return null;
        }
        if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
          return state;
        } else {
          return null;
        }
      }
      /**
       * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
       * the {@link StarLoopEntryState} field to the correct value.
       *
       * @param atn The ATN.
       */
      markPrecedenceDecisions(atn) {
        for (const state of atn.states) {
          if (!(state instanceof StarLoopEntryState)) {
            continue;
          }
          if (atn.ruleToStartState[state.ruleIndex].isLeftRecursiveRule) {
            const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
            if (maybeLoopEndState instanceof LoopEndState) {
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
                state.precedenceRuleDecision = true;
              }
            }
          }
        }
      }
      verifyATN(atn) {
        if (!this.deserializationOptions.verifyATN) {
          return;
        }
        for (const state of atn.states) {
          if (state === null) {
            continue;
          }
          this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
          if (state instanceof PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== null);
          } else if (state instanceof StarLoopEntryState) {
            this.checkCondition(state.loopBackState !== null);
            this.checkCondition(state.transitions.length === 2);
            if (state.transitions[0].target instanceof StarBlockStartState) {
              this.checkCondition(state.transitions[1].target instanceof LoopEndState);
              this.checkCondition(!state.nonGreedy);
            } else if (state.transitions[0].target instanceof LoopEndState) {
              this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
              this.checkCondition(state.nonGreedy);
            } else {
              throw new Error("IllegalState");
            }
          } else if (state instanceof StarLoopbackState) {
            this.checkCondition(state.transitions.length === 1);
            this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
          } else if (state instanceof LoopEndState) {
            this.checkCondition(state.loopBackState !== null);
          } else if (state instanceof RuleStartState) {
            this.checkCondition(state.stopState !== null);
          } else if (state instanceof BlockStartState) {
            this.checkCondition(state.endState !== null);
          } else if (state instanceof BlockEndState) {
            this.checkCondition(state.startState !== null);
          } else if (state instanceof DecisionState) {
            this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
          } else {
            this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
          }
        }
      }
      checkCondition(condition, message) {
        if (!condition) {
          if (message === void 0 || message === null) {
            message = "IllegalState";
          }
          throw message;
        }
      }
      edgeFactory(atn, type, trg, arg1, arg2, arg3, sets) {
        const target = atn.states[trg];
        switch (type) {
          case Transition.EPSILON:
            return new EpsilonTransition(target);
          case Transition.RANGE:
            return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
          case Transition.RULE:
            return new RuleTransition(atn.states[arg1], arg2, arg3, target);
          case Transition.PREDICATE:
            return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
          case Transition.PRECEDENCE:
            return new PrecedencePredicateTransition(target, arg1);
          case Transition.ATOM:
            return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
          case Transition.ACTION:
            return new ActionTransition(target, arg1, arg2, arg3 !== 0);
          case Transition.SET:
            return new SetTransition(target, sets[arg1]);
          case Transition.NOT_SET:
            return new NotSetTransition(target, sets[arg1]);
          case Transition.WILDCARD:
            return new WildcardTransition(target);
          default:
            throw new Error("The specified transition type: " + type + " is not valid.");
        }
      }
      stateFactory(type, ruleIndex) {
        const ctor = _ATNDeserializer.stateTypeMapper.get(type);
        if (!ctor) {
          throw new Error("The specified state type " + type + " is not valid.");
        }
        const s = new ctor();
        s.ruleIndex = ruleIndex;
        return s;
      }
      lexerActionFactory(type, data1, data2) {
        const factory = _ATNDeserializer.lexerActionFactoryMapper.get(type);
        if (!factory) {
          throw new Error("The specified lexer action type " + type + " is not valid.");
        }
        return factory(data1, data2);
      }
    };
    var OrderedHashMap = class _OrderedHashMap extends HashMap {
      static {
        __name(this, "OrderedHashMap");
      }
      #keys = [];
      clear() {
        super.clear();
        this.#keys = [];
      }
      get(key) {
        return super.get(key);
      }
      set(key, value) {
        const result = super.set(key, value);
        if (result === void 0) {
          this.#keys.push(key);
        }
        return result;
      }
      setIfAbsent(key, value) {
        const result = super.setIfAbsent(key, value);
        if (result === void 0) {
          this.#keys.push(key);
        }
        return result;
      }
      /**
       * @returns an iterable of the values in the map, in the order they were inserted.
       */
      values() {
        return {
          [Symbol.iterator]: () => {
            let index = 0;
            return {
              next: /* @__PURE__ */ __name(() => {
                if (index < this.#keys.length) {
                  return {
                    done: false,
                    value: super.get(this.#keys[index++])
                  };
                }
                return {
                  done: true,
                  value: void 0
                };
              }, "next")
            };
          }
        };
      }
      /**
       * @returns an iterable of the keys in the map, in the order they were inserted.
       */
      keys() {
        return this.#keys[Symbol.iterator]();
      }
      equals(o) {
        if (!(o instanceof _OrderedHashMap)) {
          return false;
        }
        return super.equals(o);
      }
    };
    var ATNSerializer = class _ATNSerializer {
      static {
        __name(this, "ATNSerializer");
      }
      atn;
      data = [];
      // Note that we use a LinkedHashMap as a set to maintain insertion order while deduplicating entries with the
      // same key.
      sets = new OrderedHashMap(ObjectEqualityComparator.instance);
      nonGreedyStates = [];
      precedenceStates = [];
      constructor(atn) {
        this.atn = atn;
      }
      static getSerialized(atn) {
        return new _ATNSerializer(atn).serialize();
      }
      static serializeSets(data, sets) {
        data.push(sets.length);
        for (const set of sets) {
          const containsEof = set.contains(Token.EOF);
          const intervals = [...set];
          if (containsEof && intervals[0].stop === Token.EOF) {
            data.push(intervals.length - 1);
          } else {
            data.push(intervals.length);
          }
          data.push(containsEof ? 1 : 0);
          for (const interval of intervals) {
            if (interval.start === Token.EOF) {
              if (interval.stop === Token.EOF) {
                continue;
              } else {
                data.push(0);
              }
            } else {
              data.push(interval.start);
            }
            data.push(interval.stop);
          }
        }
      }
      /**
       * Serialize state descriptors, edge descriptors, and decision -> state map
       *  into list of ints.  Likely out of date, but keeping as it could be helpful:
       *
       *      SERIALIZED_VERSION
       *      UUID (2 longs)
       * 		grammar-type, (ANTLRParser.LEXER, ...)
       *  	max token type,
       *  	num states,
       *  	state-0-type ruleIndex, state-1-type ruleIndex, ... state-i-type ruleIndex optional-arg ...
       *  	num rules,
       *  	rule-1-start-state rule-1-args, rule-2-start-state  rule-2-args, ...
       *  	(args are token type,actionIndex in lexer else 0,0)
       *      num modes,
       *      mode-0-start-state, mode-1-start-state, ... (parser has 0 modes)
       *      num unicode-bmp-sets
       *      bmp-set-0-interval-count intervals, bmp-set-1-interval-count intervals, ...
       *      num unicode-smp-sets
       *      smp-set-0-interval-count intervals, smp-set-1-interval-count intervals, ...
       *	num total edges,
       *      src, trg, edge-type, edge arg1, optional edge arg2 (present always), ...
       *      num decisions,
       *      decision-0-start-state, decision-1-start-state, ...
       *
       *  Convenient to pack into unsigned shorts to make as Java string.
       */
      serialize() {
        this.addPreamble();
        const edgeCount = this.addEdges();
        this.addNonGreedyStates();
        this.addPrecedenceStates();
        this.addRuleStatesAndLexerTokenTypes();
        this.addModeStartStates();
        const setIndices = this.addSets();
        this.addEdges(edgeCount, setIndices);
        this.addDecisionStartStates();
        this.addLexerActions();
        return this.data;
      }
      addPreamble() {
        this.data.push(ATNDeserializer.SERIALIZED_VERSION);
        this.data.push(this.atn.grammarType);
        this.data.push(this.atn.maxTokenType);
      }
      addLexerActions() {
        if (this.atn.grammarType === ATN.LEXER) {
          this.data.push(this.atn.lexerActions.length);
          for (const action of this.atn.lexerActions) {
            this.data.push(action.actionType);
            switch (action.actionType) {
              case LexerActionType.CHANNEL: {
                const channel = action.channel;
                this.data.push(channel);
                this.data.push(0);
                break;
              }
              case LexerActionType.CUSTOM: {
                const ruleIndex = action.ruleIndex;
                const actionIndex = action.actionIndex;
                this.data.push(ruleIndex);
                this.data.push(actionIndex);
                break;
              }
              case LexerActionType.MODE: {
                const mode = action.mode;
                this.data.push(mode);
                this.data.push(0);
                break;
              }
              case LexerActionType.MORE: {
                this.data.push(0);
                this.data.push(0);
                break;
              }
              case LexerActionType.POP_MODE: {
                this.data.push(0);
                this.data.push(0);
                break;
              }
              case LexerActionType.PUSH_MODE: {
                const mode = action.mode;
                this.data.push(mode);
                this.data.push(0);
                break;
              }
              case LexerActionType.SKIP: {
                this.data.push(0);
                this.data.push(0);
                break;
              }
              case LexerActionType.TYPE: {
                const type = action.type;
                this.data.push(type);
                this.data.push(0);
                break;
              }
              default: {
                throw new Error(`The specified lexer action type ${action.actionType} is not valid.`);
              }
            }
          }
        }
      }
      addDecisionStartStates() {
        this.data.push(this.atn.decisionToState.length);
        for (const decStartState of this.atn.decisionToState) {
          this.data.push(decStartState.stateNumber);
        }
      }
      addEdges(...args) {
        switch (args.length) {
          case 0: {
            let edgeCount = 0;
            this.data.push(this.atn.states.length);
            for (const s of this.atn.states) {
              if (s === null) {
                this.data.push(ATNState.INVALID_TYPE);
                continue;
              }
              const stateType = s.constructor.stateType;
              if (s instanceof DecisionState && s.nonGreedy) {
                this.nonGreedyStates.push(s.stateNumber);
              }
              if (s instanceof RuleStartState && s.isLeftRecursiveRule) {
                this.precedenceStates.push(s.stateNumber);
              }
              this.data.push(stateType);
              this.data.push(s.ruleIndex);
              if (s.constructor.stateType === ATNState.LOOP_END) {
                this.data.push(s.loopBackState.stateNumber);
              } else {
                if (s instanceof BlockStartState) {
                  this.data.push(s.endState.stateNumber);
                }
              }
              if (s.constructor.stateType !== ATNState.RULE_STOP) {
                edgeCount += s.transitions.length;
              }
              for (const t of s.transitions) {
                const edgeType = t.transitionType;
                if (edgeType === Transition.SET || edgeType === Transition.NOT_SET) {
                  const st = t;
                  this.sets.set(st.set, true);
                }
              }
            }
            return edgeCount;
          }
          case 2: {
            const [edgeCount, setIndices] = args;
            this.data.push(edgeCount);
            for (const s of this.atn.states) {
              if (s === null) {
                continue;
              }
              if (s.constructor.stateType === ATNState.RULE_STOP) {
                continue;
              }
              for (const t of s.transitions) {
                if (this.atn.states[t.target.stateNumber] === null) {
                  throw new Error("Cannot serialize a transition to a removed state.");
                }
                const src = s.stateNumber;
                let trg = t.target.stateNumber;
                const edgeType = t.transitionType;
                let arg1 = 0;
                let arg2 = 0;
                let arg3 = 0;
                switch (edgeType) {
                  case Transition.RULE: {
                    trg = t.followState.stateNumber;
                    arg1 = t.target.stateNumber;
                    arg2 = t.ruleIndex;
                    arg3 = t.precedence;
                    break;
                  }
                  case Transition.PRECEDENCE: {
                    const ppt = t;
                    arg1 = ppt.precedence;
                    break;
                  }
                  case Transition.PREDICATE: {
                    const pt = t;
                    arg1 = pt.ruleIndex;
                    arg2 = pt.predIndex;
                    arg3 = pt.isCtxDependent ? 1 : 0;
                    break;
                  }
                  case Transition.RANGE: {
                    arg1 = t.start;
                    arg2 = t.stop;
                    if (arg1 === Token.EOF) {
                      arg1 = 0;
                      arg3 = 1;
                    }
                    break;
                  }
                  case Transition.ATOM: {
                    arg1 = t.labelValue;
                    if (arg1 === Token.EOF) {
                      arg1 = 0;
                      arg3 = 1;
                    }
                    break;
                  }
                  case Transition.ACTION: {
                    const at = t;
                    arg1 = at.ruleIndex;
                    arg2 = at.actionIndex;
                    arg3 = at.isCtxDependent ? 1 : 0;
                    break;
                  }
                  case Transition.SET: {
                    arg1 = setIndices.get(t.set);
                    break;
                  }
                  case Transition.NOT_SET: {
                    arg1 = setIndices.get(t.set);
                    break;
                  }
                  case Transition.WILDCARD: {
                    break;
                  }
                  default:
                }
                this.data.push(src);
                this.data.push(trg);
                this.data.push(edgeType);
                this.data.push(arg1);
                this.data.push(arg2);
                this.data.push(arg3);
              }
            }
            break;
          }
          default: {
            throw new Error("Invalid number of arguments");
          }
        }
      }
      addSets() {
        _ATNSerializer.serializeSets(this.data, [...this.sets.keys()]);
        const setIndices = new HashMap();
        let setIndex = 0;
        for (const s of this.sets.keys()) {
          setIndices.set(s, setIndex++);
        }
        return setIndices;
      }
      addModeStartStates() {
        const modeCount = this.atn.modeToStartState.length;
        this.data.push(modeCount);
        if (modeCount > 0) {
          for (const modeStartState of this.atn.modeToStartState) {
            this.data.push(modeStartState.stateNumber);
          }
        }
      }
      addRuleStatesAndLexerTokenTypes() {
        const ruleCount = this.atn.ruleToStartState.length;
        this.data.push(ruleCount);
        for (let r = 0; r < ruleCount; r++) {
          const ruleStartState = this.atn.ruleToStartState[r];
          this.data.push(ruleStartState.stateNumber);
          if (this.atn.grammarType === ATN.LEXER) {
            this.data.push(this.atn.ruleToTokenType[r]);
          }
        }
      }
      addPrecedenceStates() {
        this.data.push(this.precedenceStates.length);
        for (const state of this.precedenceStates) {
          this.data.push(state);
        }
      }
      addNonGreedyStates() {
        this.data.push(this.nonGreedyStates.length);
        for (const state of this.nonGreedyStates) {
          this.data.push(state);
        }
      }
    };
    var DFAState = class _DFAState {
      static {
        __name(this, "DFAState");
      }
      stateNumber = -1;
      configs;
      /**
       * `edges[symbol]` points to target of symbol. Shift up by 1 so (-1) {@link Token.EOF} maps to `edges[0]`.
       */
      edges = [];
      isAcceptState = false;
      /**
       * If accept state, what ttype do we match or alt do we predict? This is set to {@link ATN.INVALID_ALT_NUMBER}
       * when {@link predicates} `!= null` or {@link requiresFullContext}.
       */
      prediction = -1;
      lexerActionExecutor = null;
      /**
       * Indicates that this state was created during SLL prediction that discovered a conflict between the configurations
       * in the state. Future {@link ParserATNSimulator.execATN} invocations immediately jumped doing
       * full context prediction if this field is true.
       */
      requiresFullContext = false;
      /**
       * During SLL parsing, this is a list of predicates associated with the ATN configurations of the DFA state.
       * When we have predicates, {@link requiresFullContext} is `false` since full context prediction evaluates
       * predicates on-the-fly. If this is not null, then {@link prediction} is `ATN.INVALID_ALT_NUMBER`.
       *
       * We only use these for non-{@link #requiresFullContext} but conflicting states. That
       * means we know from the context (it's $ or we don't dip into outer
       * context) that it's an ambiguity not a conflict.
       *
       * This list is computed by {@link ParserATNSimulator#predicateDFAState}.
       */
      predicates = null;
      constructor(configs) {
        if (configs) {
          this.configs = configs;
        }
      }
      static fromState(stateNumber) {
        const result = new _DFAState();
        result.stateNumber = stateNumber;
        return result;
      }
      static fromConfigs(configs) {
        return new _DFAState(configs);
      }
      static hashCode(state) {
        return state.configs.hashCode();
      }
      /**
       * Two {@link DFAState} instances are equal if their ATN configuration sets
       * are the same. This method is used to see if a state already exists.
       *
       * Because the number of alternatives and number of ATN configurations are
       * finite, there is a finite number of DFA states that can be processed.
       * This is necessary to show that the algorithm terminates.
       *
       * Cannot test the DFA state numbers here because in
       * {@link ParserATNSimulator#addDFAState} we need to know if any other state
       * exists that has this exact set of ATN configurations. The
       * {@link #stateNumber} is irrelevant.
       *
       * @param a The first {@link DFAState}.
       * @param b The second {@link DFAState}.
       *
       * @returns `true` if the two states are equal, otherwise `false`.
       */
      static equals(a, b) {
        return a.configs.equals(b.configs);
      }
      /**
       * @returns the set of all alts mentioned by all ATN configurations in this DFA state.
       */
      getAltSet() {
        const alts = /* @__PURE__ */ new Set();
        for (const config of this.configs) {
          alts.add(config.alt);
        }
        if (alts.size === 0) {
          return null;
        }
        return alts;
      }
      toString() {
        let buf = "";
        buf += this.stateNumber;
        buf += ":";
        buf += this.configs ? this.configs.toString() : "";
        if (this.isAcceptState) {
          buf += "=>";
          if (this.predicates) {
            buf += arrayToString(this.predicates);
          } else {
            buf += this.prediction;
          }
        }
        return buf.toString();
      }
    };
    var ATNSimulator = class {
      static {
        __name(this, "ATNSimulator");
      }
      /** Must distinguish between missing edge and edge we know leads nowhere */
      static ERROR = DFAState.fromState(2147483647);
      atn;
      /**
       * The context cache maps all PredictionContext objects that are ==
       * to a single cached copy. This cache is shared across all contexts
       * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
       * to use only cached nodes/graphs in addDFAState(). We don't want to
       * fill this during closure() since there are lots of contexts that
       * pop up but are not used ever again. It also greatly slows down closure().
       *
       * This cache makes a huge difference in memory and a little bit in speed.
       * For the Java grammar on java.*, it dropped the memory requirements
       * at the end from 25M to 16M. We don't store any of the full context
       * graphs in the DFA because they are limited to local context only,
       * but apparently there's a lot of repetition there as well. We optimize
       * the config contexts before storing the config set in the DFA states
       * by literally rebuilding them with cached subgraphs only.
       *
       * I tried a cache for use during closure operations, that was
       * whacked after each adaptivePredict(). It cost a little bit
       * more time I think and doesn't save on the overall footprint
       * so it's not worth the complexity.
       */
      sharedContextCache;
      constructor(atn, sharedContextCache) {
        this.atn = atn;
        this.sharedContextCache = sharedContextCache;
        return this;
      }
      getCachedContext(context) {
        if (!this.sharedContextCache) {
          return context;
        }
        const visited = new HashMap(ObjectEqualityComparator.instance);
        return getCachedPredictionContext(context, this.sharedContextCache, visited);
      }
    };
    var CodePointTransitions = class _CodePointTransitions {
      static {
        __name(this, "CodePointTransitions");
      }
      /** @returns new {@link AtomTransition}     */
      static createWithCodePoint(target, codePoint) {
        return _CodePointTransitions.createWithCodePointRange(target, codePoint, codePoint);
      }
      /** @returns new {@link AtomTransition} if range represents one atom else {@link SetTransition}. */
      static createWithCodePointRange(target, codePointFrom, codePointTo) {
        return codePointFrom === codePointTo ? new AtomTransition(target, codePointFrom) : new RangeTransition(target, codePointFrom, codePointTo);
      }
    };
    var DecisionInfo = class {
      static {
        __name(this, "DecisionInfo");
      }
      /**
       * The decision number, which is an index into {@link ATN.decisionToState}.
       */
      decision = 0;
      /**
       * The total number of times {@link ParserATNSimulator.adaptivePredict} was
       * invoked for this decision.
       */
      invocations = 0;
      /**
       * The total time spent in {@link ParserATNSimulator.adaptivePredict} for
       * this decision, in nanoseconds.
       *
       * The value of this field contains the sum of differential results obtained
       * by {@link process.hrtime()}, and is not adjusted to compensate for JIT
       * and/or garbage collection overhead. For best accuracy, use a modern Node.js
       * version that provides precise results from {@link process.hrtime()}, and
       * perform profiling in a separate process which is warmed up by parsing the
       * input prior to profiling.
       */
      timeInPrediction = 0;
      /**
       * The sum of the lookahead required for SLL prediction for this decision.
       * Note that SLL prediction is used before LL prediction for performance
       * reasons even when {@link PredictionMode.LL} or
       * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION} is used.
       */
      sllTotalLook = 0;
      /**
       * Gets the minimum lookahead required for any single SLL prediction to
       * complete for this decision, by reaching a unique prediction, reaching an
       * SLL conflict state, or encountering a syntax error.
       */
      sllMinLook = 0;
      /**
       * Gets the maximum lookahead required for any single SLL prediction to
       * complete for this decision, by reaching a unique prediction, reaching an
       * SLL conflict state, or encountering a syntax error.
       */
      sllMaxLook = 0;
      /**
       * Gets the {@link LookaheadEventInfo} associated with the event where the
       * {@link sllMaxLook} value was set.
       */
      sllMaxLookEvent;
      /**
       * The sum of the lookahead required for LL prediction for this decision.
       * Note that LL prediction is only used when SLL prediction reaches a
       * conflict state.
       */
      llTotalLook = 0;
      /**
       * Gets the minimum lookahead required for any single LL prediction to
       * complete for this decision. An LL prediction completes when the algorithm
       * reaches a unique prediction, a conflict state (for
       * {@link PredictionMode.LL}, an ambiguity state (for
       * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.
       */
      llMinLook = 0;
      /**
       * Gets the maximum lookahead required for any single LL prediction to
       * complete for this decision. An LL prediction completes when the algorithm
       * reaches a unique prediction, a conflict state (for
       * {@link PredictionMode.LL}, an ambiguity state (for
       * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.
       */
      llMaxLook = 0;
      /**
       * Gets the {@link LookaheadEventInfo} associated with the event where the
       * {@link llMaxLook} value was set.
       */
      llMaxLookEvent;
      /**
       * A collection of {@link ContextSensitivityInfo} instances describing the
       * context sensitivities encountered during LL prediction for this decision.
       */
      contextSensitivities;
      /**
       * A collection of {@link DecisionEventInfo} instances describing the parse errors
       * identified during calls to {@link ParserATNSimulator.adaptivePredict} for
       * this decision.
       */
      errors;
      /**
       * A collection of {@link AmbiguityInfo} instances describing the
       * ambiguities encountered during LL prediction for this decision.
       */
      ambiguities;
      /**
       * A collection of {@link PredicateEvalInfo} instances describing the
       * results of evaluating individual predicates during prediction for this
       * decision.
       */
      predicateEvals;
      /**
       * The total number of ATN transitions required during SLL prediction for
       * this decision. An ATN transition is determined by the number of times the
       * DFA does not contain an edge that is required for prediction, resulting
       * in on-the-fly computation of that edge.
      /**
       * If DFA caching of SLL transitions is employed by the implementation, ATN
       * computation may cache the computed edge for efficient lookup during
       * future parsing of this decision. Otherwise, the SLL parsing algorithm
       * will use ATN transitions exclusively.
       *
       * @see sllDFATransitions
       * @see ParserATNSimulator.computeTargetState
       * @see LexerATNSimulator.computeTargetState
       */
      sllATNTransitions = 0;
      /**
       * The total number of DFA transitions required during SLL prediction for
       * this decision.
       *
       * If the ATN simulator implementation does not use DFA caching for SLL
       * transitions, this value will be 0.
       *
       * @see ParserATNSimulator.getExistingTargetState
       * @see LexerATNSimulator.getExistingTargetState
       */
      sllDFATransitions = 0;
      /**
       * Gets the total number of times SLL prediction completed in a conflict
       * state, resulting in fallback to LL prediction.
       *
       * Note that this value is not related to whether or not
       * {@link PredictionMode.SLL} may be used successfully with a particular
       * grammar. If the ambiguity resolution algorithm applied to the SLL
       * conflicts for this decision produce the same result as LL prediction for
       * this decision, {@link PredictionMode.SLL} would produce the same overall
       * parsing result as {@link PredictionMode.LL}.
       */
      llFallback = 0;
      /**
       * The total number of ATN transitions required during LL prediction for
       * this decision. An ATN transition is determined by the number of times the
       * DFA does not contain an edge that is required for prediction, resulting
       * in on-the-fly computation of that edge.
       *
       * If DFA caching of LL transitions is employed by the implementation, ATN
       * computation may cache the computed edge for efficient lookup during
       * future parsing of this decision. Otherwise, the LL parsing algorithm will
       * use ATN transitions exclusively.
       *
       * @see llDFATransitions
       * @see ParserATNSimulator.computeTargetState
       * @see LexerATNSimulator.computeTargetState
       */
      llATNTransitions = 0;
      /**
       * The total number of DFA transitions required during LL prediction for
       * this decision.
       *
       * If the ATN simulator implementation does not use DFA caching for LL
       * transitions, this value will be 0.
       *
       * @see ParserATNSimulator.getExistingTargetState
       * @see LexerATNSimulator.getExistingTargetState
       */
      llDFATransitions = 0;
      /**
       * Constructs a new instance of the {@link DecisionInfo} class to contain
       * statistics for a particular decision.
       *
       * @param decision The decision number
       */
      constructor(decision) {
        this.decision = decision;
        this.contextSensitivities = [];
        this.errors = [];
        this.ambiguities = [];
        this.predicateEvals = [];
      }
      toString() {
        return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", sllLookahead=" + this.sllTotalLook + ", sllATNTransitions=" + this.sllATNTransitions + ", sllDFATransitions=" + this.sllDFATransitions + ", llFallback=" + this.llFallback + ", llLookahead=" + this.llTotalLook + ", llATNTransitions=" + this.llATNTransitions + "}";
      }
    };
    var LexerATNConfig = class _LexerATNConfig extends ATNConfig {
      static {
        __name(this, "LexerATNConfig");
      }
      /**
       * This is the backing field for {@link #getLexerActionExecutor}.
       */
      lexerActionExecutor;
      passedThroughNonGreedyDecision;
      constructor(config, state, context, lexerActionExecutor) {
        super(config, state, context ?? config.context, context ? SemanticContext.NONE : config.semanticContext);
        this.lexerActionExecutor = context ? lexerActionExecutor : config.lexerActionExecutor ?? null;
        this.passedThroughNonGreedyDecision = _LexerATNConfig.checkNonGreedyDecision(config, this.state);
        return this;
      }
      static createWithExecutor(config, state, lexerActionExecutor) {
        return new _LexerATNConfig(config, state, config.context, lexerActionExecutor);
      }
      static createWithConfig(state, config, context) {
        return new _LexerATNConfig(config, state, context ?? null, config.lexerActionExecutor);
      }
      static createWithContext(state, alt, context) {
        return new _LexerATNConfig({ alt }, state, context, null);
      }
      static checkNonGreedyDecision(source, target) {
        return source.passedThroughNonGreedyDecision || "nonGreedy" in target && target.nonGreedy;
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hashCode = MurmurHash.initialize(7);
          hashCode = MurmurHash.update(hashCode, this.state.stateNumber);
          hashCode = MurmurHash.update(hashCode, this.alt);
          hashCode = MurmurHash.updateFromComparable(hashCode, this.context);
          hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);
          hashCode = MurmurHash.update(hashCode, this.passedThroughNonGreedyDecision ? 1 : 0);
          hashCode = MurmurHash.updateFromComparable(hashCode, this.lexerActionExecutor);
          hashCode = MurmurHash.finish(hashCode, 6);
          this.cachedHashCode = hashCode;
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        return this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor && other.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
      }
    };
    var BaseErrorListener = class {
      static {
        __name(this, "BaseErrorListener");
      }
      syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
      }
    };
    var ConsoleErrorListener = class _ConsoleErrorListener extends BaseErrorListener {
      static {
        __name(this, "ConsoleErrorListener");
      }
      /**
       * Provides a default instance of {@link ConsoleErrorListener}.
       */
      static instance = new _ConsoleErrorListener();
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, _e) {
        console.error("line " + line + ":" + charPositionInLine + " " + msg);
      }
    };
    var ProxyErrorListener = class extends BaseErrorListener {
      constructor(delegates) {
        super();
        this.delegates = delegates;
        return this;
      }
      static {
        __name(this, "ProxyErrorListener");
      }
      syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
        this.delegates.forEach((d) => {
          d.syntaxError(recognizer, offendingSymbol, line, column, msg, e);
        });
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.delegates.forEach((d) => {
          d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
        });
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
        this.delegates.forEach((d) => {
          d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs);
        });
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
        this.delegates.forEach((d) => {
          d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs);
        });
      }
    };
    var Recognizer = class _Recognizer {
      static {
        __name(this, "Recognizer");
      }
      static EOF = -1;
      static tokenTypeMapCache = /* @__PURE__ */ new Map();
      static ruleIndexMapCache = /* @__PURE__ */ new Map();
      interpreter;
      listeners = [ConsoleErrorListener.instance];
      stateNumber = -1;
      checkVersion(toolVersion) {
        const runtimeVersion = "4.13.1";
        if (runtimeVersion !== toolVersion) {
          console.error("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
        }
      }
      addErrorListener(listener) {
        this.listeners.push(listener);
      }
      removeErrorListeners() {
        this.listeners = [];
      }
      removeErrorListener(listener) {
        for (let i = 0; i < this.listeners.length; i++) {
          if (this.listeners[i] === listener) {
            this.listeners.splice(i, 1);
            return;
          }
        }
      }
      getErrorListeners() {
        return this.listeners;
      }
      getTokenTypeMap() {
        const vocabulary = this.vocabulary;
        let result = _Recognizer.tokenTypeMapCache.get(vocabulary);
        if (!result) {
          result = /* @__PURE__ */ new Map();
          for (let i = 0; i <= this.atn.maxTokenType; i++) {
            const literalName = vocabulary.getLiteralName(i);
            if (literalName) {
              result.set(literalName, i);
            }
            const symbolicName = vocabulary.getSymbolicName(i);
            if (symbolicName) {
              result.set(symbolicName, i);
            }
          }
          result.set("EOF", Token.EOF);
          _Recognizer.tokenTypeMapCache.set(vocabulary, result);
        }
        return result;
      }
      /**
       * Get a map from rule names to rule indexes.
       * Used for XPath and tree pattern compilation.
       */
      getRuleIndexMap() {
        const ruleNames = this.ruleNames;
        let result = _Recognizer.ruleIndexMapCache.get(ruleNames);
        if (!result) {
          result = /* @__PURE__ */ new Map();
          ruleNames.forEach((ruleName, idx) => {
            return result.set(ruleName, idx);
          });
          _Recognizer.ruleIndexMapCache.set(ruleNames, result);
        }
        return result;
      }
      getTokenType(tokenName) {
        const ttype = this.getTokenTypeMap().get(tokenName);
        if (ttype) {
          return ttype;
        }
        return Token.INVALID_TYPE;
      }
      /** What is the error header, normally line/character position information? */
      getErrorHeader(e) {
        const line = e.offendingToken?.line;
        const column = e.offendingToken?.column;
        return "line " + line + ":" + column;
      }
      get errorListenerDispatch() {
        return new ProxyErrorListener(this.listeners);
      }
      /**
       * subclass needs to override these if there are semantic predicates or actions
       * that the ATN interp needs to execute
       */
      sempred(_localctx, _ruleIndex, _actionIndex) {
        return true;
      }
      // TODO: make localCtx an optional parameter, not optional null.
      precpred(_localctx, _precedence) {
        return true;
      }
      action(_localctx, _ruleIndex, _actionIndex) {
      }
      get atn() {
        return this.interpreter.atn;
      }
      get state() {
        return this.stateNumber;
      }
      set state(state) {
        this.stateNumber = state;
      }
      getParseInfo() {
        return void 0;
      }
    };
    var CommonTokenFactory = class _CommonTokenFactory {
      static {
        __name(this, "CommonTokenFactory");
      }
      /**
       * The default {@link CommonTokenFactory} instance.
       *
       *
       * This token factory does not explicitly copy token text when constructing
       * tokens.
       */
      static DEFAULT = new _CommonTokenFactory();
      /**
       * Indicates whether {@link CommonToken.setText} should be called after
       * constructing tokens to explicitly set the text. This is useful for cases
       * where the input stream might not be able to provide arbitrary substrings
       * of text from the input after the lexer creates a token (e.g. the
       * implementation of {@link CharStream.getText} in
       * {@link UnbufferedCharStream} throws an
       * {@link UnsupportedOperationException}). Explicitly setting the token text
       * allows {@link Token.getText} to be called at any time regardless of the
       * input stream implementation.
       *
       *
       * The default value is `false` to avoid the performance and memory
       * overhead of copying text for every token unless explicitly requested.
       */
      copyText = false;
      constructor(copyText) {
        this.copyText = copyText ?? false;
      }
      create(source, type, text, channel, start, stop, line, column) {
        const t = CommonToken.fromSource(source, type, channel, start, stop);
        t.line = line;
        t.column = column;
        if (text) {
          t.text = text;
        } else if (this.copyText && source[1] !== null) {
          t.text = source[1].getTextFromRange(start, stop);
        }
        return t;
      }
    };
    var RecognitionException = class _RecognitionException extends Error {
      static {
        __name(this, "RecognitionException");
      }
      ctx;
      /**
       * The current {@link Token} when an error occurred. Since not all streams
       * support accessing symbols by index, we have to track the {@link Token}
       * instance itself
       */
      offendingToken = null;
      /**
       * Get the ATN state number the parser was in at the time the error
       * occurred. For {@link NoViableAltException} and
       * {@link LexerNoViableAltException} exceptions, this is the
       * {@link DecisionState} number. For others, it is the state whose outgoing
       * edge we couldn't match.
       */
      offendingState = -1;
      recognizer;
      input;
      constructor(params) {
        super(params.message);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _RecognitionException);
        }
        this.message = params.message;
        this.recognizer = params.recognizer;
        this.input = params.input;
        this.ctx = params.ctx;
        if (this.recognizer !== null) {
          this.offendingState = this.recognizer.state;
        }
      }
      /**
       * Gets the set of input symbols which could potentially follow the
       * previously matched symbol at the time this exception was thrown.
       *
       * If the set of expected tokens is not known and could not be computed,
       * this method returns `null`.
       *
       * @returns The set of token types that could potentially follow the current
       * state in the ATN, or `null` if the information is not available.
       */
      getExpectedTokens() {
        if (this.recognizer !== null && this.ctx !== null) {
          return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
        } else {
          return null;
        }
      }
      // If the state number is not known, this method returns -1.
      toString() {
        return this.message;
      }
    };
    var LexerNoViableAltException = class extends RecognitionException {
      static {
        __name(this, "LexerNoViableAltException");
      }
      startIndex;
      deadEndConfigs;
      constructor(lexer, input, startIndex, deadEndConfigs) {
        super({ message: "", recognizer: lexer, input, ctx: null });
        this.startIndex = startIndex;
        this.deadEndConfigs = deadEndConfigs;
      }
      toString() {
        let symbol = "";
        if (this.input && this.startIndex >= 0 && this.startIndex < this.input.size) {
          symbol = this.input.getTextFromRange(this.startIndex, this.startIndex);
        }
        return `LexerNoViableAltException(${symbol})`;
      }
    };
    var Lexer = class _Lexer extends Recognizer {
      static {
        __name(this, "Lexer");
      }
      static DEFAULT_MODE = 0;
      static MORE = -2;
      static SKIP = -3;
      static DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
      static HIDDEN = Token.HIDDEN_CHANNEL;
      options = {
        minDFAEdge: 0,
        maxDFAEdge: 256,
        minCodePoint: 0,
        maxCodePoint: 1114111
      };
      /**
       * What character index in the stream did the current token start at?
       *  Needed, for example, to get the text for current token.  Set at
       *  the start of nextToken.
       */
      tokenStartCharIndex = -1;
      /** The channel number for the current token */
      channel = 0;
      /** The token type for the current token */
      type = 0;
      mode = _Lexer.DEFAULT_MODE;
      /** The start column of the current token (the one that was last read by `nextToken`). */
      currentTokenColumn = 0;
      /**
       * The line on which the first character of the current token (the one that was last read by `nextToken`) resides.
       */
      currentTokenStartLine = 0;
      input;
      /**
       * The goal of all lexer rules/methods is to create a token object.
       *  This is an instance variable as multiple rules may collaborate to
       *  create a single token.  nextToken will return this object after
       *  matching lexer rule(s).  If you subclass to allow multiple token
       *  emissions, then set this to the last token to be matched or
       *  something non-null so that the auto token emit mechanism will not
       *  emit another token.
       */
      token = null;
      /**
       * Once we see EOF on char stream, next token will be EOF.
       * If you have DONE : EOF ; then you see DONE EOF.
       */
      hitEOF = false;
      factory;
      #modeStack = [];
      /**
       * The text to be used for the next token. If this is not null, then the text
       * for the next token is fixed and is not subject to change in the normal
       * workflow of the lexer.
       */
      #text;
      constructor(input, options) {
        super();
        this.options = { ...this.options, ...options };
        this.input = input;
        this.factory = CommonTokenFactory.DEFAULT;
      }
      reset(seekBack = true) {
        if (seekBack) {
          this.input.seek(0);
        }
        this.token = null;
        this.type = Token.INVALID_TYPE;
        this.channel = Token.DEFAULT_CHANNEL;
        this.tokenStartCharIndex = -1;
        this.currentTokenColumn = -1;
        this.currentTokenStartLine = -1;
        this.#text = void 0;
        this.hitEOF = false;
        this.mode = _Lexer.DEFAULT_MODE;
        this.#modeStack = [];
        this.interpreter.reset();
      }
      /** @returns a token from this source; i.e., match a token on the char stream. */
      nextToken() {
        if (this.input === null) {
          throw new Error("nextToken requires a non-null input stream.");
        }
        const tokenStartMarker = this.input.mark();
        try {
          while (true) {
            if (this.hitEOF) {
              this.emitEOF();
              return this.token;
            }
            this.token = null;
            this.channel = Token.DEFAULT_CHANNEL;
            this.tokenStartCharIndex = this.input.index;
            this.currentTokenColumn = this.interpreter.column;
            this.currentTokenStartLine = this.interpreter.line;
            this.#text = void 0;
            let continueOuter = false;
            while (true) {
              this.type = Token.INVALID_TYPE;
              let ttype = _Lexer.SKIP;
              try {
                ttype = this.interpreter.match(this.input, this.mode);
              } catch (e) {
                if (e instanceof LexerNoViableAltException) {
                  this.notifyListeners(e);
                  this.recover(e);
                } else {
                  throw e;
                }
              }
              if (this.input.LA(1) === Token.EOF) {
                this.hitEOF = true;
              }
              if (this.type === Token.INVALID_TYPE) {
                this.type = ttype;
              }
              if (this.type === _Lexer.SKIP) {
                continueOuter = true;
                break;
              }
              if (this.type !== _Lexer.MORE) {
                break;
              }
            }
            if (continueOuter) {
              continue;
            }
            if (this.token === null) {
              this.emit();
            }
            return this.token;
          }
        } finally {
          this.input.release(tokenStartMarker);
        }
      }
      /**
       * Instruct the lexer to skip creating a token for current lexer rule
       * and look for another token. nextToken() knows to keep looking when
       * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
       * if token==null at end of any token rule, it creates one for you
       * and emits it.
       */
      skip() {
        this.type = _Lexer.SKIP;
      }
      more() {
        this.type = _Lexer.MORE;
      }
      pushMode(m2) {
        if (LexerATNSimulator.debug) {
          console.log("pushMode " + m2);
        }
        this.#modeStack.push(this.mode);
        this.mode = m2;
      }
      popMode() {
        if (this.#modeStack.length === 0) {
          throw new Error("Empty Stack");
        }
        if (LexerATNSimulator.debug) {
          console.log("popMode back to " + this.#modeStack.slice(0, -1));
        }
        this.mode = this.#modeStack.pop();
        return this.mode;
      }
      get modeStack() {
        return this.#modeStack;
      }
      /**
       * By default does not support multiple emits per nextToken invocation
       * for efficiency reasons. Subclass and override this method, nextToken,
       * and getToken (to push tokens into a list and pull from that list
       * rather than a single variable as this implementation does).
       */
      emitToken(token) {
        this.token = token;
      }
      /**
       * The standard method called to automatically emit a token at the
       * outermost lexical rule. The token object should point into the
       * char buffer start..stop. If there is a text override in 'text',
       * use that to set the token's text. Override this method to emit
       * custom Token objects or provide a new factory.
       */
      emit() {
        const t = this.factory.create(
          [this, this.input],
          this.type,
          this.#text,
          this.channel,
          this.tokenStartCharIndex,
          this.getCharIndex() - 1,
          this.currentTokenStartLine,
          this.currentTokenColumn
        );
        this.emitToken(t);
        return t;
      }
      emitEOF() {
        const eof = this.factory.create(
          [this, this.input],
          Token.EOF,
          void 0,
          Token.DEFAULT_CHANNEL,
          this.input.index,
          this.input.index - 1,
          this.line,
          this.column
        );
        this.emitToken(eof);
        return eof;
      }
      /** What is the index of the current character of lookahead? */
      getCharIndex() {
        return this.input.index;
      }
      /**
       * Return a list of all Token objects in input char stream.
       * Forces load of all tokens. Does not include EOF token.
       */
      getAllTokens() {
        const tokens = [];
        let t = this.nextToken();
        while (t.type !== Token.EOF) {
          tokens.push(t);
          t = this.nextToken();
        }
        return tokens;
      }
      notifyListeners(e) {
        const start = this.tokenStartCharIndex;
        const stop = this.input.index;
        const text = this.input.getTextFromRange(start, stop);
        const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
        this.errorListenerDispatch.syntaxError(this, null, this.currentTokenStartLine, this.currentTokenColumn, msg, e);
      }
      getErrorDisplay(s) {
        return s;
      }
      getErrorDisplayForChar(c) {
        if (c.charCodeAt(0) === Token.EOF) {
          return "<EOF>";
        }
        if (c === "\n") {
          return "\\n";
        }
        if (c === "	") {
          return "\\t";
        }
        if (c === "\r") {
          return "\\r";
        }
        return c;
      }
      getCharErrorDisplay(c) {
        return "'" + this.getErrorDisplayForChar(c) + "'";
      }
      /**
       * Lexers can normally match any char in it's vocabulary after matching
       * a token, so do the easy thing and just kill a character and hope
       * it all works out. You can instead use the rule invocation stack
       * to do sophisticated error recovery if you are in a fragment rule.
       */
      recover(re) {
        if (this.input.LA(1) !== Token.EOF) {
          if (re instanceof LexerNoViableAltException) {
            this.interpreter.consume(this.input);
          } else {
            this.input.consume();
          }
        }
      }
      get inputStream() {
        return this.input;
      }
      set inputStream(input) {
        this.reset(false);
        this.input = input;
      }
      set tokenFactory(factory) {
        this.factory = factory;
      }
      get tokenFactory() {
        return this.factory;
      }
      get sourceName() {
        return this.input.getSourceName();
      }
      get line() {
        return this.interpreter.line;
      }
      set line(line) {
        this.interpreter.line = line;
      }
      get column() {
        return this.interpreter.column;
      }
      set column(column) {
        this.interpreter.column = column;
      }
      get text() {
        if (this.#text) {
          return this.#text;
        } else {
          return this.interpreter.getText(this.input);
        }
      }
      set text(text) {
        this.#text = text;
      }
    };
    var DFASerializer = class {
      static {
        __name(this, "DFASerializer");
      }
      dfa;
      vocabulary;
      constructor(dfa, vocabulary) {
        this.dfa = dfa;
        this.vocabulary = vocabulary;
      }
      toString() {
        if (!this.dfa.s0) {
          return "";
        }
        let buf = "";
        const states = this.dfa.getStates();
        for (const s of states) {
          let n2 = 0;
          n2 = s.edges.length;
          for (let i = 0; i < n2; i++) {
            const t = s.edges[i];
            if (t && t.stateNumber !== 2147483647) {
              buf += this.getStateString(s);
              const label = this.getEdgeLabel(i);
              buf += "-";
              buf += label;
              buf += "->";
              buf += this.getStateString(t);
              buf += "\n";
            }
          }
        }
        return buf;
      }
      getEdgeLabel(i) {
        const name = this.vocabulary.getDisplayName(i - 1);
        return `${name}`;
      }
      getStateString(s) {
        const n2 = s.stateNumber;
        const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + n2 + (s.requiresFullContext ? "^" : "");
        if (s.isAcceptState) {
          if (s.predicates !== null) {
            return `${baseStateStr}=>${s.predicates.toString()}`;
          }
          return `${baseStateStr}=>${s.prediction}`;
        } else {
          return `${baseStateStr}`;
        }
      }
    };
    var LexerDFASerializer = class extends DFASerializer {
      static {
        __name(this, "LexerDFASerializer");
      }
      constructor(dfa) {
        super(dfa, Vocabulary.EMPTY_VOCABULARY);
      }
      getEdgeLabel = /* @__PURE__ */ __name((i) => {
        return "'" + String.fromCharCode(i) + "'";
      }, "getEdgeLabel");
    };
    var DFA = class {
      static {
        __name(this, "DFA");
      }
      s0;
      decision;
      /** From which ATN state did we create this DFA? */
      atnStartState;
      /**
       * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
       * start state {@link #s0} which is not stored in {@link #states}. The
       * {@link DFAState#edges} array for this start state contains outgoing edges
       * supplying individual start states corresponding to specific precedence
       * values.
       *
       * @returns `true` if this is a precedence DFA; otherwise, `false`.
       */
      isPrecedenceDfa;
      /**
       * A mapping from an ATNConfigSet hash to a DFAState.
       * Used to quick look up the DFA state for a particular configuration set.
       */
      states = /* @__PURE__ */ new Map();
      constructor(atnStartState, decision) {
        this.atnStartState = atnStartState;
        this.decision = decision ?? 0;
        let precedenceDfa = false;
        if (atnStartState instanceof StarLoopEntryState) {
          if (atnStartState.precedenceRuleDecision) {
            precedenceDfa = true;
            this.s0 = DFAState.fromState(-1);
          }
        }
        this.isPrecedenceDfa = precedenceDfa;
      }
      [Symbol.iterator] = () => {
        return this.states.values()[Symbol.iterator]();
      };
      /**
       * Get the start state for a specific precedence value.
       *
       * @param precedence The current precedence.
        @returns The start state corresponding to the specified precedence, or
       * `null` if no start state exists for the specified precedence.
       *
       * @throws IllegalStateException if this is not a precedence DFA.
       * @see #isPrecedenceDfa
       */
      getPrecedenceStartState = /* @__PURE__ */ __name((precedence) => {
        if (!this.isPrecedenceDfa) {
          throw new Error(`Only precedence DFAs may contain a precedence start state.`);
        }
        if (!this.s0 || !this.s0.edges || precedence < 0 || precedence >= this.s0.edges.length) {
          return void 0;
        }
        return this.s0.edges[precedence];
      }, "getPrecedenceStartState");
      /**
       * Set the start state for a specific precedence value.
       *
       * @param precedence The current precedence.
       * @param startState The start state corresponding to the specified precedence.
       */
      setPrecedenceStartState = /* @__PURE__ */ __name((precedence, startState) => {
        if (!this.isPrecedenceDfa) {
          throw new Error(`Only precedence DFAs may contain a precedence start state.`);
        }
        if (precedence < 0 || !this.s0) {
          return;
        }
        this.s0.edges[precedence] = startState;
      }, "setPrecedenceStartState");
      /**
       * @returns a list of all states in this DFA, ordered by state number.
       */
      getStates() {
        const result = [...this.states.values()];
        result.sort((o1, o2) => {
          return o1.stateNumber - o2.stateNumber;
        });
        return result;
      }
      getState(state) {
        return this.states.get(state.configs.hashCode()) ?? null;
      }
      getStateForConfigs(configs) {
        return this.states.get(configs.hashCode()) ?? null;
      }
      addState(state) {
        const hash = state.configs.hashCode();
        if (this.states.has(hash)) {
          return;
        }
        this.states.set(hash, state);
        state.stateNumber = this.states.size - 1;
      }
      toString(vocabulary) {
        if (!vocabulary) {
          return this.toString(Vocabulary.EMPTY_VOCABULARY);
        }
        if (!this.s0) {
          return "";
        }
        const serializer = new DFASerializer(this, vocabulary);
        return serializer.toString() ?? "";
      }
      toLexerString() {
        if (!this.s0) {
          return "";
        }
        const serializer = new LexerDFASerializer(this);
        return serializer.toString() ?? "";
      }
      get length() {
        return this.states.size;
      }
    };
    var LexerIndexedCustomAction = class _LexerIndexedCustomAction {
      static {
        __name(this, "LexerIndexedCustomAction");
      }
      offset;
      action;
      actionType;
      isPositionDependent = true;
      cachedHashCode;
      constructor(offset, action) {
        this.actionType = action.actionType;
        this.offset = offset;
        this.action = action;
      }
      /**
       * This method calls {@link execute} on the result of {@link getAction}
       * using the provided `lexer`.
       */
      execute(lexer) {
        this.action.execute(lexer);
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hash = MurmurHash.initialize();
          hash = MurmurHash.update(hash, this.offset);
          hash = MurmurHash.updateFromComparable(hash, this.action);
          this.cachedHashCode = MurmurHash.finish(hash, 2);
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _LexerIndexedCustomAction)) {
          return false;
        }
        return this.offset === other.offset && this.action === other.action;
      }
    };
    var LexerActionExecutor = class _LexerActionExecutor {
      static {
        __name(this, "LexerActionExecutor");
      }
      lexerActions;
      actionType;
      isPositionDependent = false;
      cachedHashCode;
      /**
       * Represents an executor for a sequence of lexer actions which traversed during
       * the matching operation of a lexer rule (token).
       *
       * The executor tracks position information for position-dependent lexer actions
       * efficiently, ensuring that actions appearing only at the end of the rule do
       * not cause bloating of the {@link DFA} created for the lexer.
       */
      constructor(lexerActions) {
        this.actionType = -1;
        this.lexerActions = lexerActions ?? [];
        return this;
      }
      /**
       * Creates a {@link LexerActionExecutor} which executes the actions for
       * the input `lexerActionExecutor` followed by a specified
       * `lexerAction`.
       *
       * @param lexerActionExecutor The executor for actions already traversed by
       * the lexer while matching a token within a particular
       * {@link LexerATNConfig}. If this is `null`, the method behaves as
       * though it were an empty executor.
       * @param lexerAction The lexer action to execute after the actions
       * specified in `lexerActionExecutor`.
       *
       * @returns {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
       * of `lexerActionExecutor` and `lexerAction`.
       */
      static append(lexerActionExecutor, lexerAction) {
        if (lexerActionExecutor === null) {
          return new _LexerActionExecutor([lexerAction]);
        }
        const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
        return new _LexerActionExecutor(lexerActions);
      }
      /**
       * Creates a {@link LexerActionExecutor} which encodes the current offset
       * for position-dependent lexer actions.
       *
       * Normally, when the executor encounters lexer actions where
       * {@link LexerAction//isPositionDependent} returns `true`, it calls
       * {@link IntStream.seek} on the input {@link CharStream} to set the input
       * position to the *end* of the current token. This behavior provides
       * for efficient DFA representation of lexer actions which appear at the end
       * of a lexer rule, even when the lexer rule matches a variable number of
       * characters.
       *
       * Prior to traversing a match transition in the ATN, the current offset
       * from the token start index is assigned to all position-dependent lexer
       * actions which have not already been assigned a fixed offset. By storing
       * the offsets relative to the token start index, the DFA representation of
       * lexer actions which appear in the middle of tokens remains efficient due
       * to sharing among tokens of the same length, regardless of their absolute
       * position in the input stream.
       *
       * If the current executor already has offsets assigned to all
       * position-dependent lexer actions, the method returns `this`.
       *
       * @param offset The current offset to assign to all position-dependent
       * lexer actions which do not already have offsets assigned.
       *
       * @returns {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
       * for all position-dependent lexer actions.
       */
      fixOffsetBeforeMatch(offset) {
        let updatedLexerActions = null;
        for (let i = 0; i < this.lexerActions.length; i++) {
          if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
            if (updatedLexerActions === null) {
              updatedLexerActions = this.lexerActions.concat([]);
            }
            updatedLexerActions[i] = new LexerIndexedCustomAction(
              offset,
              this.lexerActions[i]
            );
          }
        }
        if (updatedLexerActions === null) {
          return this;
        } else {
          return new _LexerActionExecutor(updatedLexerActions);
        }
      }
      /**
       * Execute the actions encapsulated by this executor within the context of a
       * particular {@link Lexer}.
       *
       * This method calls {@link IntStream.seek} to set the position of the
       * `input` {@link CharStream} prior to calling
       * {@link LexerAction.execute} on a position-dependent action. Before the
       * method returns, the input position will be restored to the same position
       * it was in when the method was invoked.
       *
       * @param lexer The lexer instance.
       * @param input The input stream which is the source for the current token.
       * When this method is called, the current {@link IntStream.index} for
       * `input` should be the start of the following token, i.e. 1
       * character past the end of the current token.
       * @param startIndex The token start index. This value may be passed to
       * {@link IntStream.seek} to set the `input` position to the beginning
       * of the token.
       */
      execute(lexer, input, startIndex) {
        if (input === void 0 || startIndex === void 0) {
          return;
        }
        let requiresSeek = false;
        const stopIndex = input.index;
        try {
          for (const lexerAction of this.lexerActions) {
            let action = lexerAction;
            if (lexerAction instanceof LexerIndexedCustomAction) {
              const offset = lexerAction.offset;
              input.seek(startIndex + offset);
              action = lexerAction.action;
              requiresSeek = startIndex + offset !== stopIndex;
            } else if (lexerAction.isPositionDependent) {
              input.seek(stopIndex);
              requiresSeek = false;
            }
            action.execute(lexer);
          }
        } finally {
          if (requiresSeek) {
            input.seek(stopIndex);
          }
        }
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hashCode = MurmurHash.initialize(7);
          for (const lexerAction of this.lexerActions) {
            hashCode = MurmurHash.update(hashCode, lexerAction.hashCode());
          }
          this.cachedHashCode = MurmurHash.finish(hashCode, this.lexerActions.length);
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        if (this.cachedHashCode !== other.cachedHashCode) {
          return false;
        }
        if (this.lexerActions.length !== other.lexerActions.length) {
          return false;
        }
        return this.lexerActions.every((action, index) => {
          return action.equals(other.lexerActions[index]);
        });
      }
    };
    var OrderedHashSet = class _OrderedHashSet extends HashSet {
      static {
        __name(this, "OrderedHashSet");
      }
      elements = [];
      getOrAdd(o) {
        const oldSize = this.size;
        const result = super.getOrAdd(o);
        if (this.size > oldSize) {
          this.elements.push(o);
        }
        return result;
      }
      equals(o) {
        if (!(o instanceof _OrderedHashSet)) {
          return false;
        }
        return super.equals(o);
      }
      clear() {
        super.clear();
        this.elements = [];
      }
      *[Symbol.iterator]() {
        yield* this.elements;
      }
      toArray() {
        return this.elements.slice(0);
      }
    };
    var OrderedATNConfigSet = class extends ATNConfigSet {
      static {
        __name(this, "OrderedATNConfigSet");
      }
      constructor() {
        super();
        this.configLookup = new OrderedHashSet();
      }
    };
    var LexerATNSimulator = class _LexerATNSimulator extends ATNSimulator {
      static {
        __name(this, "LexerATNSimulator");
      }
      static debug = false;
      decisionToDFA;
      recognizer = null;
      /**
       * The current token's starting index into the character stream.
       *  Shared across DFA to ATN simulation in case the ATN fails and the
       *  DFA did not have a previous accept state. In this case, we use the
       *  ATN-generated exception object.
       */
      startIndex = -1;
      /** line number 1..n within the input */
      line = 1;
      /** The index of the character relative to the beginning of the line 0..n-1 */
      column = 0;
      mode = Lexer.DEFAULT_MODE;
      /** Used during DFA/ATN exec to record the most recent accept configuration info */
      prevAccept;
      options;
      /** Lookup table for lexer ATN config creation. */
      lexerATNConfigFactory;
      /**
       * When we hit an accept state in either the DFA or the ATN, we
       * have to notify the character stream to start buffering characters
       * via {@link IntStream//mark} and record the current state. The current sim state
       * includes the current index into the input, the current line,
       * and current character position in that line. Note that the Lexer is
       * tracking the starting line and characterization of the token. These
       * variables track the "state" of the simulator when it hits an accept state.
       *
       * We track these variables separately for the DFA and ATN simulation
       * because the DFA simulation often has to fail over to the ATN
       * simulation. If the ATN simulation fails, we need the DFA to fall
       * back to its previously accepted state, if any. If the ATN succeeds,
       * then the ATN does the accept and the DFA simulator that invoked it
       * can simply return the predicted token type.
       */
      constructor(recog, atn, decisionToDFA, sharedContextCache) {
        super(atn, sharedContextCache);
        this.decisionToDFA = decisionToDFA;
        this.recognizer = recog;
        if (recog) {
          this.options = recog.options;
        } else {
          this.options = {
            minDFAEdge: 0,
            maxDFAEdge: 256,
            minCodePoint: 0,
            maxCodePoint: 1114111
          };
        }
      }
      match(input, mode) {
        this.mode = mode;
        const mark = input.mark();
        try {
          this.startIndex = input.index;
          this.prevAccept = void 0;
          const dfa = this.decisionToDFA[mode];
          if (!dfa.s0) {
            return this.matchATN(input);
          }
          return this.execATN(input, dfa.s0);
        } finally {
          input.release(mark);
        }
      }
      reset() {
        this.prevAccept = void 0;
        this.startIndex = -1;
        this.line = 1;
        this.column = 0;
        this.mode = Lexer.DEFAULT_MODE;
      }
      clearDFA() {
        for (let d = 0; d < this.decisionToDFA.length; d++) {
          this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);
        }
      }
      getDFA(mode) {
        return this.decisionToDFA[mode];
      }
      /** @returns the text matched so far for the current token. */
      getText(input) {
        return input.getTextFromRange(this.startIndex, input.index - 1);
      }
      consume(input) {
        const curChar = input.LA(1);
        if (curChar === "\n".charCodeAt(0)) {
          this.line += 1;
          this.column = 0;
        } else {
          this.column += 1;
        }
        input.consume();
      }
      getTokenName(tt) {
        if (tt === Token.EOF) {
          return "EOF";
        } else {
          return "'" + String.fromCharCode(tt) + "'";
        }
      }
      matchATN(input) {
        const startState = this.atn.modeToStartState[this.mode];
        if (_LexerATNSimulator.debug) {
          console.log("matchATN mode " + this.mode + " start: " + startState);
        }
        const oldMode = this.mode;
        const s0Closure = this.computeStartState(input, startState);
        const suppressEdge = s0Closure.hasSemanticContext;
        s0Closure.hasSemanticContext = false;
        const next = this.addDFAState(s0Closure);
        if (!suppressEdge) {
          this.decisionToDFA[this.mode].s0 = next;
        }
        const predict = this.execATN(input, next);
        if (_LexerATNSimulator.debug) {
          console.log("DFA after matchATN: " + this.decisionToDFA[oldMode].toLexerString());
        }
        return predict;
      }
      execATN(input, state) {
        if (_LexerATNSimulator.debug) {
          console.log("start state closure=" + state.configs);
        }
        if (state.isAcceptState) {
          this.captureSimState(input, state);
        }
        let t = input.LA(1);
        while (true) {
          if (_LexerATNSimulator.debug) {
            console.log("execATN loop starting closure: " + state.configs);
          }
          let target = this.getExistingTargetState(state, t);
          if (!target) {
            target = this.computeTargetState(input, state, t);
          }
          if (target === ATNSimulator.ERROR) {
            break;
          }
          if (t !== Token.EOF) {
            this.consume(input);
          }
          if (target.isAcceptState) {
            this.captureSimState(input, target);
            if (t === Token.EOF) {
              break;
            }
          }
          t = input.LA(1);
          state = target;
        }
        return this.failOrAccept(input, state.configs, t);
      }
      /**
       * Get an existing target state for an edge in the DFA. If the target state
       * for the edge has not yet been computed or is otherwise not available,
       * this method returns `null`.
       *
       * @param s The current DFA state.
       * @param t The next input symbol.
       *
       * @returns The existing target DFA state for the given input symbol
       * `t`, or `null` if the target state for this edge is not already cached
       */
      getExistingTargetState(s, t) {
        if (t >= this.options.minDFAEdge && t <= this.options.maxDFAEdge) {
          const target = s.edges[t - this.options.minDFAEdge];
          if (_LexerATNSimulator.debug && target) {
            console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
          }
          return target;
        }
        return void 0;
      }
      /**
       * Compute a target state for an edge in the DFA, and attempt to add the computed state and corresponding
       * edge to the DFA.
       *
       * @param input The input stream
       * @param s The current DFA state
       * @param t The next input symbol
       *
       * @returns The computed target DFA state for the given input symbol `t`.
       *          If `t` does not lead to a valid DFA state, this method returns `ERROR`.
       */
      computeTargetState(input, s, t) {
        const reach = new OrderedATNConfigSet();
        this.getReachableConfigSet(input, s.configs, reach, t);
        if (reach.length === 0) {
          if (!reach.hasSemanticContext) {
            this.addDFAEdge(s, t, ATNSimulator.ERROR);
          }
          return ATNSimulator.ERROR;
        }
        return this.addDFAEdge(s, t, null, reach);
      }
      failOrAccept(input, reach, t) {
        if (this.prevAccept?.dfaState) {
          const { dfaState, index, line, column } = this.prevAccept;
          this.accept(input, dfaState.lexerActionExecutor, this.startIndex, index, line, column);
          return dfaState.prediction;
        }
        if (t === Token.EOF && input.index === this.startIndex) {
          return Token.EOF;
        }
        throw new LexerNoViableAltException(this.recognizer, input, this.startIndex, reach);
      }
      /**
       * Given a starting configuration set, figure out all ATN configurations we can reach upon input `t`.
       * Parameter `reach` is a return parameter.
       */
      getReachableConfigSet(input, closure, reach, t) {
        let skipAlt = ATN.INVALID_ALT_NUMBER;
        for (const cfg of closure) {
          const currentAltReachedAcceptState = cfg.alt === skipAlt;
          if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
            continue;
          }
          if (_LexerATNSimulator.debug) {
            console.log("testing %s at %s\n", this.getTokenName(t), cfg.toString(this.recognizer, true));
          }
          for (const trans of cfg.state.transitions) {
            const target = this.getReachableTarget(trans, t);
            if (target) {
              let lexerActionExecutor = cfg.lexerActionExecutor;
              if (lexerActionExecutor) {
                lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
              }
              const treatEofAsEpsilon = t === Token.EOF;
              const config = LexerATNConfig.createWithExecutor(
                cfg,
                target,
                lexerActionExecutor
              );
              if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                skipAlt = cfg.alt;
              }
            }
          }
        }
      }
      accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
        if (_LexerATNSimulator.debug) {
          console.log("ACTION %s\n", lexerActionExecutor);
        }
        input.seek(index);
        this.line = line;
        this.column = charPos;
        if (lexerActionExecutor && this.recognizer) {
          lexerActionExecutor.execute(this.recognizer, input, startIndex);
        }
      }
      getReachableTarget(trans, t) {
        if (trans.matches(t, this.options.minCodePoint, this.options.maxCodePoint)) {
          return trans.target;
        } else {
          return void 0;
        }
      }
      computeStartState(input, p) {
        const initialContext = EmptyPredictionContext.instance;
        const configs = new OrderedATNConfigSet();
        for (let i = 0; i < p.transitions.length; i++) {
          const target = p.transitions[i].target;
          const cfg = LexerATNConfig.createWithContext(target, i + 1, initialContext);
          this.closure(input, cfg, configs, false, false, false);
        }
        return configs;
      }
      /**
       * Since the alternatives within any lexer decision are ordered by
       * preference, this method stops pursuing the closure as soon as an accept
       * state is reached. After the first accept state is reached by depth-first
       * search from `config`, all other (potentially reachable) states for
       * this rule would have a lower priority.
       *
       * @returns {boolean} `true` if an accept state is reached, otherwise `false`.
       */
      closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
        let cfg = null;
        if (_LexerATNSimulator.debug) {
          console.log("closure(" + config.toString(this.recognizer, true) + ")");
        }
        if (config.state.constructor.stateType === ATNState.RULE_STOP) {
          if (_LexerATNSimulator.debug) {
            if (this.recognizer !== null) {
              console.log(
                "closure at %s rule stop %s\n",
                this.recognizer.ruleNames[config.state.ruleIndex],
                config
              );
            } else {
              console.log("closure at rule stop %s\n", config);
            }
          }
          if (!config.context || config.context.hasEmptyPath()) {
            if (!config.context || config.context.isEmpty()) {
              configs.add(config);
              return true;
            } else {
              configs.add(LexerATNConfig.createWithConfig(config.state, config, EmptyPredictionContext.instance));
              currentAltReachedAcceptState = true;
            }
          }
          if (config.context && !config.context.isEmpty()) {
            for (let i = 0; i < config.context.length; i++) {
              if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
                const newContext = config.context.getParent(i);
                const returnState = this.atn.states[config.context.getReturnState(i)];
                cfg = LexerATNConfig.createWithConfig(returnState, config, newContext);
                currentAltReachedAcceptState = this.closure(
                  input,
                  cfg,
                  configs,
                  currentAltReachedAcceptState,
                  speculative,
                  treatEofAsEpsilon
                );
              }
            }
          }
          return currentAltReachedAcceptState;
        }
        if (!config.state.epsilonOnlyTransitions) {
          if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
            configs.add(config);
          }
        }
        for (const trans of config.state.transitions) {
          cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
          if (cfg) {
            currentAltReachedAcceptState = this.closure(
              input,
              cfg,
              configs,
              currentAltReachedAcceptState,
              speculative,
              treatEofAsEpsilon
            );
          }
        }
        return currentAltReachedAcceptState;
      }
      // side-effect: can alter configs.hasSemanticContext
      getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
        if (!this.lexerATNConfigFactory) {
          this.setupATNFactoryLookup();
        }
        const factory = this.lexerATNConfigFactory[trans.transitionType];
        if (!factory) {
          return null;
        }
        return factory(input, config, trans, configs, speculative, treatEofAsEpsilon);
      }
      /**
       * Fills the lookup table for creating lexer ATN configs. This helps to avoid frequent checks of the transition
       * type, which determines the configuration of the created config.
       */
      setupATNFactoryLookup() {
        this.lexerATNConfigFactory = [];
        this.lexerATNConfigFactory[Transition.RULE] = (input, config, trans) => {
          const newContext = createSingletonPredictionContext(
            config.context ?? void 0,
            trans.followState.stateNumber
          );
          return LexerATNConfig.createWithConfig(trans.target, config, newContext);
        };
        this.lexerATNConfigFactory[Transition.PRECEDENCE] = () => {
          throw new Error("Precedence predicates are not supported in lexers.");
        };
        this.lexerATNConfigFactory[Transition.PREDICATE] = (input, config, trans, configs, speculative) => {
          const pt = trans;
          if (_LexerATNSimulator.debug) {
            console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
          }
          configs.hasSemanticContext = true;
          if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
            return LexerATNConfig.createWithConfig(trans.target, config);
          }
          return null;
        };
        this.lexerATNConfigFactory[Transition.ACTION] = (input, config, trans) => {
          if (config.context === null || config.context.hasEmptyPath()) {
            const lexerActionExecutor = LexerActionExecutor.append(
              config.lexerActionExecutor,
              this.atn.lexerActions[trans.actionIndex]
            );
            return LexerATNConfig.createWithExecutor(config, trans.target, lexerActionExecutor);
          } else {
            return LexerATNConfig.createWithConfig(trans.target, config);
          }
        };
        this.lexerATNConfigFactory[Transition.EPSILON] = (input, config, trans) => {
          return LexerATNConfig.createWithConfig(trans.target, config);
        };
        const simple = /* @__PURE__ */ __name((input, config, trans, configs, speculative, treatEofAsEpsilon) => {
          if (treatEofAsEpsilon) {
            if (trans.matches(Token.EOF, this.options.minCodePoint, this.options.maxCodePoint)) {
              return LexerATNConfig.createWithConfig(trans.target, config);
            }
          }
          return null;
        }, "simple");
        this.lexerATNConfigFactory[Transition.ATOM] = simple;
        this.lexerATNConfigFactory[Transition.RANGE] = simple;
        this.lexerATNConfigFactory[Transition.SET] = simple;
      }
      /**
       * Evaluate a predicate specified in the lexer.
       *
       * If `speculative` is `true`, this method was called before
       * {@link consume} for the matched character. This method should call
       * {@link consume} before evaluating the predicate to ensure position
       * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
       * and {@link Lexer}, properly reflect the current
       * lexer state. This method should restore `input` and the simulator
       * to the original state before returning (i.e. undo the actions made by the
       * call to {@link consume}.
       *
       * @param input The input stream.
       * @param ruleIndex The rule containing the predicate.
       * @param predIndex The index of the predicate within the rule.
       * @param speculative `true` if the current index in `input` is
       * one character before the predicate's location.
       *
       * @returns `true` if the specified predicate evaluates to
       * `true`.
       */
      evaluatePredicate(input, ruleIndex, predIndex, speculative) {
        if (!this.recognizer) {
          return true;
        }
        if (!speculative) {
          return this.recognizer.sempred(null, ruleIndex, predIndex);
        }
        const savedColumn = this.column;
        const savedLine = this.line;
        const index = input.index;
        const marker = input.mark();
        try {
          this.consume(input);
          return this.recognizer.sempred(null, ruleIndex, predIndex);
        } finally {
          this.column = savedColumn;
          this.line = savedLine;
          input.seek(index);
          input.release(marker);
        }
      }
      captureSimState(input, dfaState) {
        this.prevAccept = {
          index: input.index,
          line: this.line,
          column: this.column,
          dfaState
        };
      }
      addDFAEdge(from, tk, to, configs) {
        if (!to && configs) {
          const suppressEdge = configs.hasSemanticContext;
          configs.hasSemanticContext = false;
          to = this.addDFAState(configs);
          if (suppressEdge) {
            return to;
          }
        }
        if (tk < this.options.minDFAEdge || tk > this.options.maxDFAEdge) {
          return to;
        }
        if (_LexerATNSimulator.debug) {
          console.log("EDGE " + from + " -> " + to + " upon " + tk);
        }
        from.edges[tk - this.options.minDFAEdge] = to;
        return to;
      }
      /**
       * Add a new DFA state if there isn't one with this set of configurations already. This method also detects
       * the first configuration containing an ATN rule stop state. Later, when traversing the DFA, we will know
       * which rule to accept.
       */
      addDFAState(configs) {
        const dfa = this.decisionToDFA[this.mode];
        const existing = dfa.getStateForConfigs(configs);
        if (existing) {
          return existing;
        }
        const proposed = DFAState.fromConfigs(configs);
        const firstConfigWithRuleStopState = configs.firstStopState;
        if (firstConfigWithRuleStopState) {
          proposed.isAcceptState = true;
          proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
          proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
        }
        configs.setReadonly(true);
        dfa.addState(proposed);
        return proposed;
      }
    };
    var ParseInfo = class {
      static {
        __name(this, "ParseInfo");
      }
      atnSimulator;
      constructor(atnSimulator) {
        this.atnSimulator = atnSimulator;
      }
      /**
       * Gets an array of {@link DecisionInfo} instances containing the profiling
       * information gathered for each decision in the ATN.
       *
       * @returns An array of {@link DecisionInfo} instances, indexed by decision
       * number.
       */
      getDecisionInfo() {
        return this.atnSimulator.getDecisionInfo();
      }
      /**
       * Gets the decision numbers for decisions that required one or more
       * full-context predictions during parsing. These are decisions for which
       * {@link DecisionInfo#llFallback} is non-zero.
       *
       * @returns A list of decision numbers which required one or more
       * full-context predictions during parsing.
       */
      getLLDecisions() {
        const decisions = this.atnSimulator.getDecisionInfo();
        const result = new Array();
        for (let i = 0; i < decisions.length; i++) {
          const fallBack = decisions[i].llFallback;
          if (fallBack > 0) {
            result.push(i);
          }
        }
        return result;
      }
      /**
       * Gets the total time spent during prediction across all decisions made
       * during parsing. This value is the sum of
       * {@link DecisionInfo#timeInPrediction} for all decisions.
       */
      getTotalTimeInPrediction() {
        const decisions = this.atnSimulator.getDecisionInfo();
        let t = 0;
        for (const decision of decisions) {
          t += decision.timeInPrediction;
        }
        return t;
      }
      /**
       * Gets the total number of SLL lookahead operations across all decisions
       * made during parsing. This value is the sum of
       * {@link DecisionInfo#sllTotalLook} for all decisions.
       */
      getTotalSLLLookaheadOps() {
        const decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (const decision of decisions) {
          k += decision.sllTotalLook;
        }
        return k;
      }
      /**
       * Gets the total number of LL lookahead operations across all decisions
       * made during parsing. This value is the sum of
       * {@link DecisionInfo#llTotalLook} for all decisions.
       */
      getTotalLLLookaheadOps() {
        const decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (const decision of decisions) {
          k += decision.llTotalLook;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for SLL prediction
       * across all decisions made during parsing.
       */
      getTotalSLLATNLookaheadOps() {
        const decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (const decision of decisions) {
          k += decision.sllATNTransitions;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for LL prediction
       * across all decisions made during parsing.
       */
      getTotalLLATNLookaheadOps() {
        const decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (const decision of decisions) {
          k += decision.llATNTransitions;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for SLL and LL
       * prediction across all decisions made during parsing.
       *
       *
       * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
       * {@link #getTotalLLATNLookaheadOps}.
       */
      getTotalATNLookaheadOps() {
        const decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (const decision of decisions) {
          k += decision.sllATNTransitions;
          k += decision.llATNTransitions;
        }
        return k;
      }
      getDFASize(decision) {
        if (decision === void 0) {
          let n2 = 0;
          const decisionToDFA = this.atnSimulator.decisionToDFA;
          for (let i = 0; i < decisionToDFA.length; i++) {
            n2 += this.getDFASize(i);
          }
          return n2;
        } else {
          const decisionToDFA = this.atnSimulator.decisionToDFA[decision];
          return decisionToDFA.length;
        }
      }
    };
    var NoViableAltException = class extends RecognitionException {
      static {
        __name(this, "NoViableAltException");
      }
      /** Which configurations did we try at input.index() that couldn't match input.LT(1)? */
      deadEndConfigs = null;
      /**
       * The token object at the start index; the input stream might
       * 	not be buffering tokens so get a reference to it. (At the
       *  time the error occurred, of course the stream needs to keep a
       *  buffer all of the tokens but later we might not have access to those.)
       */
      startToken;
      constructor(recognizer, input = null, startToken = null, offendingToken = null, deadEndConfigs = null, ctx = null) {
        ctx = ctx ?? recognizer.context;
        offendingToken = offendingToken ?? recognizer.getCurrentToken();
        startToken = startToken ?? recognizer.getCurrentToken();
        input = input ?? recognizer.inputStream;
        super({ message: "", recognizer, input, ctx });
        this.deadEndConfigs = deadEndConfigs;
        this.startToken = startToken;
        this.offendingToken = offendingToken;
      }
    };
    var DoubleDict = class {
      static {
        __name(this, "DoubleDict");
      }
      cacheMap;
      constructor() {
        this.cacheMap = new HashMap();
      }
      get(a, b) {
        const d = this.cacheMap.get(a) ?? null;
        return d === null ? null : d.get(b) ?? null;
      }
      set(a, b, o) {
        let d = this.cacheMap.get(a);
        if (!d) {
          d = new HashMap();
          this.cacheMap.set(a, d);
        }
        d.set(b, o);
      }
    };
    var SubsetEqualityComparer = class _SubsetEqualityComparer {
      static {
        __name(this, "SubsetEqualityComparer");
      }
      static instance = new _SubsetEqualityComparer();
      hashCode(config) {
        let hashCode = MurmurHash.initialize(7);
        hashCode = MurmurHash.update(hashCode, config.state.stateNumber);
        hashCode = MurmurHash.updateFromComparable(hashCode, config.context);
        hashCode = MurmurHash.finish(hashCode, 2);
        return hashCode;
      }
      equals(a, b) {
        return a.state.stateNumber === b.state.stateNumber && (a.context?.equals(b.context) ?? true);
      }
    };
    var PredictionMode = class _PredictionMode {
      static {
        __name(this, "PredictionMode");
      }
      /**
       * The SLL(*) prediction mode. This prediction mode ignores the current
       * parser context when making predictions. This is the fastest prediction
       * mode, and provides correct results for many grammars. This prediction
       * mode is more powerful than the prediction mode provided by ANTLR 3, but
       * may result in syntax errors for grammar and input combinations which are
       * not SLL.
       *
       *
       * When using this prediction mode, the parser will either return a correct
       * parse tree (i.e. the same parse tree that would be returned with the
       * {@link LL} prediction mode), or it will report a syntax error. If a
       * syntax error is encountered when using the {@link SLL} prediction mode,
       * it may be due to either an actual syntax error in the input or indicate
       * that the particular combination of grammar and input requires the more
       * powerful {@link LL} prediction abilities to complete successfully.
       *
       *
       * This prediction mode does not provide any guarantees for prediction
       * behavior for syntactically-incorrect inputs.
       */
      static SLL = 0;
      /**
       * The LL(*) prediction mode. This prediction mode allows the current parser
       * context to be used for resolving SLL conflicts that occur during
       * prediction. This is the fastest prediction mode that guarantees correct
       * parse results for all combinations of grammars with syntactically correct
       * inputs.
       *
       *
       * When using this prediction mode, the parser will make correct decisions
       * for all syntactically-correct grammar and input combinations. However, in
       * cases where the grammar is truly ambiguous this prediction mode might not
       * report a precise answer for *exactly which* alternatives are
       * ambiguous.
       *
       *
       * This prediction mode does not provide any guarantees for prediction
       * behavior for syntactically-incorrect inputs.
       */
      static LL = 1;
      /**
       *
       * The LL(*) prediction mode with exact ambiguity detection. In addition to
       * the correctness guarantees provided by the {@link LL} prediction mode,
       * this prediction mode instructs the prediction algorithm to determine the
       * complete and exact set of ambiguous alternatives for every ambiguous
       * decision encountered while parsing.
       *
       *
       * This prediction mode may be used for diagnosing ambiguities during
       * grammar development. Due to the performance overhead of calculating sets
       * of ambiguous alternatives, this prediction mode should be avoided when
       * the exact results are not necessary.
       *
       *
       * This prediction mode does not provide any guarantees for prediction
       * behavior for syntactically-incorrect inputs.
       */
      static LL_EXACT_AMBIG_DETECTION = 2;
      /**
       *
       *Computes the SLL prediction termination condition.
       *
       *
       *This method computes the SLL prediction termination condition for both of
       *the following cases.
       *
       * - The usual SLL+LL fallback upon SLL conflict
       * - Pure SLL without LL fallback
       *
       ***COMBINED SLL+LL PARSING**
       *
       *When LL-fallback is enabled upon SLL conflict, correct predictions are
       *ensured regardless of how the termination condition is computed by this
       *method. Due to the substantially higher cost of LL prediction, the
       *prediction should only fall back to LL when the additional lookahead
       *cannot lead to a unique SLL prediction.
       *
       *Assuming combined SLL+LL parsing, an SLL configuration set with only
       *conflicting subsets should fall back to full LL, even if the
       *configuration sets don't resolve to the same alternative (e.g.
       *`{1,2`} and `{3,4`}. If there is at least one non-conflicting
       *configuration, SLL could continue with the hopes that more lookahead will
       *resolve via one of those non-conflicting configurations.
       *
       *Here's the prediction termination rule them: SLL (for SLL+LL parsing)
       *stops when it sees only conflicting configuration subsets. In contrast,
       *full LL keeps going when there is uncertainty.
       *
       ***HEURISTIC**
       *
       *As a heuristic, we stop prediction when we see any conflicting subset
       *unless we see a state that only has one alternative associated with it.
       *The single-alt-state thing lets prediction continue upon rules like
       *(otherwise, it would admit defeat too soon):
       *
       *`[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;`
       *
       *When the ATN simulation reaches the state before `';'`, it has a
       *DFA state that looks like: `[12|1|[], 6|2|[], 12|2|[]]`. Naturally
       *`12|1|[]` and `12|2|[]` conflict, but we cannot stop
       *processing this node because alternative to has another way to continue,
       *via `[6|2|[]]`.
       *
       *It also let's us continue for this rule:
       *
       *`[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;`
       *
       *After matching input A, we reach the stop state for rule A, state 1.
       *State 8 is the state right before B. Clearly alternatives 1 and 2
       *conflict and no amount of further lookahead will separate the two.
       *However, alternative 3 will be able to continue and so we do not stop
       *working on this state. In the previous example, we're concerned with
       *states associated with the conflicting alternatives. Here alt 3 is not
       *associated with the conflicting configs, but since we can continue
       *looking for input reasonably, don't declare the state done.
       *
       ***PURE SLL PARSING**
       *
       *To handle pure SLL parsing, all we have to do is make sure that we
       *combine stack contexts for configurations that differ only by semantic
       *predicate. From there, we can do the usual SLL termination heuristic.
       *
       ***PREDICATES IN SLL+LL PARSING**
       *
       *SLL decisions don't evaluate predicates until after they reach DFA stop
       *states because they need to create the DFA cache that works in all
       *semantic situations. In contrast, full LL evaluates predicates collected
       *during start state computation so it can ignore predicates thereafter.
       *This means that SLL termination detection can totally ignore semantic
       *predicates.
       *
       *Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
       *semantic predicate contexts so we might see two configurations like the
       *following.
       *
       *`(s, 1, x, {`), (s, 1, x', {p})}
       *
       *Before testing these configurations against others, we have to merge
       *`x` and `x'` (without modifying the existing configurations).
       *For example, we test `(x+x')==x''` when looking for conflicts in
       *the following configurations.
       *
       *`(s, 1, x, {`), (s, 1, x', {p}), (s, 2, x'', {})}
       *
       *If the configuration set has predicates (as indicated by
       *{@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
       *the configurations to strip out all of the predicates so that a standard
       *{@link ATNConfigSet} will merge everything ignoring predicates.
       */
      static hasSLLConflictTerminatingPrediction(mode, configs) {
        if (_PredictionMode.allConfigsInRuleStopStates(configs)) {
          return true;
        }
        if (mode === _PredictionMode.SLL) {
          if (configs.hasSemanticContext) {
            const dup = new ATNConfigSet();
            for (let c of configs) {
              c = ATNConfig.duplicate(c, SemanticContext.NONE);
              dup.add(c);
            }
            configs = dup;
          }
        }
        const altSets = _PredictionMode.getConflictingAltSubsets(configs);
        return _PredictionMode.hasConflictingAltSet(altSets) && !_PredictionMode.hasStateAssociatedWithOneAlt(configs);
      }
      /**
       * Checks if any configuration in `configs` is in a
       * {@link RuleStopState}. Configurations meeting this condition have reached
       * the end of the decision rule (local context) or end of start rule (full
       * context).
       *
       * @param configs the configuration set to test
       * @returns `true` if any configuration in `configs` is in a
       * {@link RuleStopState}, otherwise `false`
       */
      static hasConfigInRuleStopState(configs) {
        for (const c of configs) {
          if (c.state instanceof RuleStopState) {
            return true;
          }
        }
        return false;
      }
      /**
       * Checks if all configurations in `configs` are in a
       * {@link RuleStopState}. Configurations meeting this condition have reached
       * the end of the decision rule (local context) or end of start rule (full
       * context).
       *
       * @param configs the configuration set to test
       * @returns `true` if all configurations in `configs` are in a
       * {@link RuleStopState}, otherwise `false`
       */
      static allConfigsInRuleStopStates(configs) {
        for (const c of configs) {
          if (!(c.state instanceof RuleStopState)) {
            return false;
          }
        }
        return true;
      }
      /**
       *
       * Full LL prediction termination.
       *
       * Can we stop looking ahead during ATN simulation or is there some
       * uncertainty as to which alternative we will ultimately pick, after
       * consuming more input? Even if there are partial conflicts, we might know
       * that everything is going to resolve to the same minimum alternative. That
       * means we can stop since no more lookahead will change that fact. On the
       * other hand, there might be multiple conflicts that resolve to different
       * minimums. That means we need more look ahead to decide which of those
       * alternatives we should predict.
       *
       * The basic idea is to split the set of configurations `C`, into
       * conflicting subsets `(s, _, ctx, _)` and singleton subsets with
       * non-conflicting configurations. Two configurations conflict if they have
       * identical {@link ATNConfig.state} and {@link ATNConfig.context} values
       * but different {@link ATNConfig.alt} value, e.g. `(s, i, ctx, _)`
       * and `(s, j, ctx, _)` for `i!=j`.
       *
       * Reduce these configuration subsets to the set of possible alternatives.
       * You can compute the alternative subsets in one pass as follows:
       *
       * `A_s,ctx = {i | (s, i, ctx, _)`} for each configuration in
       * `C` holding `s` and `ctx` fixed.
       *
       * Or in pseudo-code, for each configuration `c` in `C`:
       *
       * ```
       * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not
       * alt and not pred
       * ```
       *
       * The values in `map` are the set of `A_s,ctx` sets.
       *
       * If `|A_s,ctx|=1` then there is no conflict associated with
       * `s` and `ctx`.
       *
       * Reduce the subsets to singletons by choosing a minimum of each subset. If
       * the union of these alternative subsets is a singleton, then no amount of
       * more lookahead will help us. We will always pick that alternative. If,
       * however, there is more than one alternative, then we are uncertain which
       * alternative to predict and must continue looking for resolution. We may
       * or may not discover an ambiguity in the future, even if there are no
       * conflicting subsets this round.
       *
       * The biggest sin is to terminate early because it means we've made a
       * decision but were uncertain as to the eventual outcome. We haven't used
       * enough lookahead. On the other hand, announcing a conflict too late is no
       * big deal; you will still have the conflict. It's just inefficient. It
       * might even look until the end of file.
       *
       * No special consideration for semantic predicates is required because
       * predicates are evaluated on-the-fly for full LL prediction, ensuring that
       * no configuration contains a semantic context during the termination
       * check.
       *
       * **CONFLICTING CONFIGS**
       *
       * Two configurations `(s, i, x)` and `(s, j, x')`, conflict when `i!=j` but `x=x'`. Because we merge all
       * `(s, i, _)` configurations together, that means that there are at most `n` configurations associated with state
       * `s` for `n` possible alternatives in the decision. The merged stacks complicate the comparison of configuration
       * contexts `x` and `x'`. Sam checks to see if one is a subset of the other by calling merge and checking to see
       * if the merged result is either `x` or `x'`. If the `x` associated with lowest alternative `i` is the superset,
       * then `i` is the only possible prediction since the others resolve to `min(i)` as well. However, if `x` is
       * associated with `j>i` then at least one stack configuration for `j` is not in conflict with alternative `i`.
       * The algorithm should keep going, looking for more lookahead due to the uncertainty.
       *
       * For simplicity, I'm doing a equality check between `x` and `x'` that lets the algorithm continue to consume
       * lookahead longer than necessary. The reason I like the equality is of course the simplicity but also because
       * that is the test you need to detect the alternatives that are actually in conflict.
       *
       * **CONTINUE/STOP RULE**
       *
       * Continue if union of resolved alternative sets from non-conflicting and conflicting alternative subsets has more
       * than one alternative. We are uncertain about which alternative to predict.
       *
       * The complete set of alternatives, `[i for (_,i,_)]`, tells us which alternatives are still in the running for
       * the amount of input we've consumed at this point. The conflicting sets let us to strip away configurations that
       * won't lead to more states because we resolve conflicts to the configuration with a minimum alternate for the
       * conflicting set.
       *
       * **CASES**
       *
       * - no conflicts and more than 1 alternative in set => continue
       * -  `(s, 1, x)`, `(s, 2, x)`, `(s, 3, z)`, `(s', 1, y)`, `(s', 2, y)` yields non-conflicting set `{3`} U
       *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1,3`} => continue
       * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)`, `(s'', 1, z)` yields non-conflicting set `{1`} U
       *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1`} => stop and predict 1
       * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)` yields conflicting, reduced sets `{1`} U
       *   `{1`} = `{1`} => stop and predict 1, can announce ambiguity `{1,2`}
       * - `(s, 1, x)`, `(s, 2, x)`, `(s', 2, y)`, `(s', 3, y)` yields conflicting, reduced sets `{1`} U
       *   `{2`} = `{1,2`} => continue
       * - `(s, 1, x)`, `(s, 2, x)`, `(s', 3, y)`, `(s', 4, y)` yields conflicting, reduced sets `{1`} U
       *   `{3`} = `{1,3`} => continue
       *
       * **EXACT AMBIGUITY DETECTION**
       *
       *If all states report the same conflicting set of alternatives, then we
       *know we have the exact ambiguity set.
       *
       * `|A_*i*|>1` and `A_*i* = A_*j*` for all *i*, *j*.
       *
       * In other words, we continue examining lookahead until all `A_i` have more than one alternative and all `A_i`
       * are the same. If `A={{1,2`, {1,3}}}, then regular LL prediction would terminate because the resolved set
       * is `{1`}. To determine what the real ambiguity is, we have to know whether the ambiguity is between one and
       * two or one and three so we keep going. We can only stop prediction when we need exact ambiguity detection when
       * the sets look like `A={{1,2`}} or `{{1,2`,{1,2}}}, etc...
       */
      static resolvesToJustOneViableAlt(altSets) {
        return _PredictionMode.getSingleViableAlt(altSets);
      }
      /**
       * Determines if every alternative subset in `altSets` contains more
       * than one alternative.
       *
       * @param altSets a collection of alternative subsets
       * @returns `true` if every {@link BitSet} in `altSets` has
       * {@link BitSet//cardinality cardinality} > 1, otherwise `false`
       */
      static allSubsetsConflict(altSets) {
        return !_PredictionMode.hasNonConflictingAltSet(altSets);
      }
      /**
       * Determines if any single alternative subset in `altSets` contains
       * exactly one alternative.
       *
       * @param altSets a collection of alternative subsets
       * @returns `true` if `altSets` contains a {@link BitSet} with
       * {@link BitSet//cardinality cardinality} 1, otherwise `false`
       */
      static hasNonConflictingAltSet(altSets) {
        for (const alts of altSets) {
          if (alts.length === 1) {
            return true;
          }
        }
        return false;
      }
      /**
       * Determines if any single alternative subset in `altSets` contains
       * more than one alternative.
       *
       * @param altSets a collection of alternative subsets
       * @returns `true` if `altSets` contains a {@link BitSet} with
       * {@link BitSet//cardinality cardinality} > 1, otherwise `false`
       */
      static hasConflictingAltSet(altSets) {
        for (const alts of altSets) {
          if (alts.length > 1) {
            return true;
          }
        }
        return false;
      }
      /**
       * Determines if every alternative subset in `altSets` is equivalent.
       *
       * @param altSets a collection of alternative subsets
       * @returns `true` if every member of `altSets` is equal to the
       * others, otherwise `false`
       */
      static allSubsetsEqual(altSets) {
        let first = null;
        for (const alts of altSets) {
          if (first === null) {
            first = alts;
          } else if (alts !== first) {
            return false;
          }
        }
        return true;
      }
      /**
       * Returns the unique alternative predicted by all alternative subsets in
       * `altSets`. If no such alternative exists, this method returns
       * {@link ATN.INVALID_ALT_NUMBER}.
       *
       * @param altSets a collection of alternative subsets
       */
      static getUniqueAlt(altSets) {
        const all = _PredictionMode.getAlts(altSets);
        if (all.length === 1) {
          return all.nextSetBit(0);
        } else {
          return ATN.INVALID_ALT_NUMBER;
        }
      }
      /**
       * Gets the complete set of represented alternatives for a collection of
       * alternative subsets. This method returns the union of each {@link BitSet}
       * in `altSets`.
       *
       * @param altSets a collection of alternative subsets
       * @returns the set of represented alternatives in `altSets`
       */
      static getAlts(altSets) {
        const all = new BitSet();
        altSets.forEach((alts) => {
          all.or(alts);
        });
        return all;
      }
      /**
       * This function gets the conflicting alt subsets from a configuration set.
       * For each configuration `c` in `configs`:
       *
       * ```
       * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not
       * alt and not pred
       * ```
       */
      static getConflictingAltSubsets(configs) {
        const configToAlts = new HashMap(SubsetEqualityComparer.instance);
        for (const cfg of configs) {
          let alts = configToAlts.get(cfg);
          if (!alts) {
            alts = new BitSet();
            configToAlts.set(cfg, alts);
          }
          alts.set(cfg.alt);
        }
        return Array.from(configToAlts.values());
      }
      /**
       * Get a map from state to alt subset from a configuration set. For each configuration `c` in `configs`:
       *
       * ```
       * map[c.state] = c.alt
       * ```
       */
      static getStateToAltMap(configs) {
        const m2 = new HashMap(ObjectEqualityComparator.instance);
        for (const c of configs) {
          let alts = m2.get(c.state);
          if (!alts) {
            alts = new BitSet();
            m2.set(c.state, alts);
          }
          alts.set(c.alt);
        }
        return m2;
      }
      static hasStateAssociatedWithOneAlt(configs) {
        const counts = {};
        for (const c of configs) {
          const stateNumber = c.state.stateNumber;
          if (!counts[stateNumber]) {
            counts[stateNumber] = 0;
          }
          counts[stateNumber]++;
        }
        return Object.values(counts).some((count) => {
          return count === 1;
        });
      }
      static getSingleViableAlt(altSets) {
        let result = null;
        for (const alts of altSets) {
          const minAlt = alts.nextSetBit(0);
          if (result === null) {
            result = minAlt;
          } else if (result !== minAlt) {
            return ATN.INVALID_ALT_NUMBER;
          }
        }
        return result ?? 0;
      }
    };
    var ParserATNSimulator = class _ParserATNSimulator extends ATNSimulator {
      static {
        __name(this, "ParserATNSimulator");
      }
      static traceATNSimulator = false;
      static debug;
      static debugAdd = false;
      static debugClosure = false;
      static dfaDebug = false;
      static retryDebug = false;
      /** SLL, LL, or LL + exact ambig detection? */
      predictionMode;
      decisionToDFA;
      parser;
      /**
       * Each prediction operation uses a cache for merge of prediction contexts.
       * Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
       * isn't synchronized but we're ok since two threads shouldn't reuse same
       * parser/atn sim object because it can only handle one input at a time.
       * This maps graphs a and b to merged result c. (a,b)->c. We can avoid
       * the merge if we ever see a and b again.  Note that (b,a)->c should
       * also be examined during cache lookup.
       */
      mergeCache = new DoubleDict();
      // Used also in the profiling ATN simulator.
      predictionState;
      constructor(recog, atn, decisionToDFA, sharedContextCache) {
        super(atn, sharedContextCache);
        this.parser = recog;
        this.decisionToDFA = decisionToDFA;
      }
      static getUniqueAlt(configs) {
        let alt = ATN.INVALID_ALT_NUMBER;
        for (const c of configs) {
          if (alt === ATN.INVALID_ALT_NUMBER) {
            alt = c.alt;
          } else if (c.alt !== alt) {
            return ATN.INVALID_ALT_NUMBER;
          }
        }
        return alt;
      }
      reset() {
      }
      clearDFA() {
        for (let d = 0; d < this.decisionToDFA.length; d++) {
          this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);
        }
      }
      // TODO: make outerContext an optional parameter, not optional null.
      adaptivePredict(input, decision, outerContext) {
        if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
          console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
        }
        const dfa = this.decisionToDFA[decision];
        this.predictionState = {
          input,
          startIndex: input.index,
          outerContext: outerContext ?? void 0,
          dfa
        };
        const m2 = input.mark();
        const index = input.index;
        try {
          let s0;
          if (dfa.isPrecedenceDfa) {
            s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
          } else {
            s0 = dfa.s0;
          }
          if (!s0) {
            if (!outerContext) {
              outerContext = ParserRuleContext.empty;
            }
            if (_ParserATNSimulator.debug) {
              console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
            }
            const fullCtx = false;
            let s0_closure = this.computeStartState(dfa.atnStartState, ParserRuleContext.empty, fullCtx);
            if (dfa.isPrecedenceDfa) {
              s0_closure = this.applyPrecedenceFilter(s0_closure);
              s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));
              dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
            } else {
              s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));
              dfa.s0 = s0;
            }
          }
          const alt = this.execATN(dfa, s0, input, index, outerContext);
          if (_ParserATNSimulator.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this.parser.vocabulary));
          }
          return alt;
        } finally {
          this.predictionState.dfa = void 0;
          this.mergeCache = new DoubleDict();
          input.seek(index);
          input.release(m2);
        }
      }
      /**
       * Performs ATN simulation to compute a predicted alternative based
       *  upon the remaining input, but also updates the DFA cache to avoid
       *  having to traverse the ATN again for the same input sequence.
       *
       * There are some key conditions we're looking for after computing a new
       * set of ATN configs (proposed DFA state):
       *       if the set is empty, there is no viable alternative for current symbol
       *       does the state uniquely predict an alternative?
       *       does the state have a conflict that would prevent us from
       *         putting it on the work list?
       *
       * We also have some key operations to do:
       *       add an edge from previous DFA state to potentially new DFA state, D,
       *         upon current symbol but only if adding to work list, which means in all
       *         cases except no viable alternative (and possibly non-greedy decisions?)
       *       collecting predicates and adding semantic context to DFA accept states
       *       adding rule context to context-sensitive DFA accept states
       *       consuming an input symbol
       *       reporting a conflict
       *       reporting an ambiguity
       *       reporting a context sensitivity
       *       reporting insufficient predicates
       *
       * cover these cases:
       *    dead end
       *    single alt
       *    single alt + preds
       *    conflict
       *    conflict + preds
       */
      execATN(dfa, s0, input, startIndex, outerContext) {
        if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
          console.log("execATN decision " + dfa.decision + ", DFA state " + s0 + ", LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
        }
        let alt;
        let previousState = s0;
        let t = input.LA(1);
        while (true) {
          let nextState = this.getExistingTargetState(previousState, t);
          if (!nextState) {
            nextState = this.computeTargetState(dfa, previousState, t);
          }
          if (nextState === ATNSimulator.ERROR) {
            const e = this.noViableAlt(input, outerContext, previousState.configs, startIndex);
            input.seek(startIndex);
            alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousState.configs, outerContext);
            if (alt !== ATN.INVALID_ALT_NUMBER) {
              return alt;
            } else {
              throw e;
            }
          }
          if (nextState.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
            let conflictingAlts = null;
            if (nextState.predicates !== null) {
              if (_ParserATNSimulator.debug) {
                console.log("DFA state has preds in DFA sim LL failover");
              }
              const conflictIndex = input.index;
              if (conflictIndex !== startIndex) {
                input.seek(startIndex);
              }
              conflictingAlts = this.evalSemanticContext(nextState.predicates, outerContext, true);
              if (conflictingAlts.length === 1) {
                if (_ParserATNSimulator.debug) {
                  console.log("Full LL avoided");
                }
                return conflictingAlts.nextSetBit(0);
              }
              if (conflictIndex !== startIndex) {
                input.seek(conflictIndex);
              }
            }
            if (_ParserATNSimulator.dfaDebug) {
              console.log("ctx sensitive state " + outerContext + " in " + nextState);
            }
            const fullCtx = true;
            const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
            this.reportAttemptingFullContext(dfa, conflictingAlts, nextState.configs, startIndex, input.index);
            alt = this.execATNWithFullContext(dfa, nextState, s0_closure, input, startIndex, outerContext);
            return alt;
          }
          if (nextState.isAcceptState) {
            if (nextState.predicates === null) {
              return nextState.prediction;
            }
            const stopIndex = input.index;
            input.seek(startIndex);
            const alts = this.evalSemanticContext(nextState.predicates, outerContext, true);
            if (alts.length === 0) {
              throw this.noViableAlt(input, outerContext, nextState.configs, startIndex);
            }
            if (alts.length === 1) {
              return alts.nextSetBit(0);
            }
            this.reportAmbiguity(dfa, nextState, startIndex, stopIndex, false, alts, nextState.configs);
            return alts.nextSetBit(0);
          }
          previousState = nextState;
          if (t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
      }
      /**
       * Get an existing target state for an edge in the DFA. If the target state
       * for the edge has not yet been computed or is otherwise not available,
       * this method returns `null`.
       *
       * @param previousD The current DFA state
       * @param t The next input symbol
       * @returns The existing target DFA state for the given input symbol
       * `t`, or `null` if the target state for this edge is not
       * already cached
       */
      getExistingTargetState(previousD, t) {
        return previousD.edges[t + 1];
      }
      /**
       * Compute a target state for an edge in the DFA, and attempt to add the
       * computed state and corresponding edge to the DFA.
       *
       * @param dfa The DFA
       * @param previousD The current DFA state
       * @param t The next input symbol
       *
       * @returns The computed target DFA state for the given input symbol
       * `t`. If `t` does not lead to a valid DFA state, this method
       * returns {@link ERROR
       */
      computeTargetState(dfa, previousD, t) {
        const reach = this.computeReachSet(previousD.configs, t, false);
        if (reach === null) {
          this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
          return ATNSimulator.ERROR;
        }
        let D = DFAState.fromConfigs(reach);
        const predictedAlt = _ParserATNSimulator.getUniqueAlt(reach);
        if (_ParserATNSimulator.debug) {
          const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
          console.log("SLL altSubSets=" + arrayToString(altSubSets) + /*", previous=" + previousD.configs + */
          ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
        }
        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
          D.isAcceptState = true;
          D.configs.uniqueAlt = predictedAlt;
          D.prediction = predictedAlt;
        } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
          D.configs.conflictingAlts = this.getConflictingAlts(reach);
          D.requiresFullContext = true;
          D.isAcceptState = true;
          D.prediction = D.configs.conflictingAlts.nextSetBit(0);
        }
        if (D.isAcceptState && D.configs.hasSemanticContext) {
          this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
          if (D.predicates !== null) {
            D.prediction = ATN.INVALID_ALT_NUMBER;
          }
        }
        D = this.addDFAEdge(dfa, previousD, t, D);
        return D;
      }
      getRuleName(index) {
        if (this.parser !== null && index >= 0) {
          return this.parser.ruleNames[index];
        } else {
          return "<rule " + index + ">";
        }
      }
      getTokenName(t) {
        if (t === Token.EOF) {
          return "EOF";
        }
        const vocabulary = this.parser?.vocabulary ?? Vocabulary.EMPTY_VOCABULARY;
        const displayName = vocabulary.getDisplayName(t);
        if (displayName === t.toString()) {
          return displayName;
        }
        return displayName + "<" + t + ">";
      }
      getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
      }
      /**
       * Used for debugging in adaptivePredict around execATN but I cut
       * it out for clarity now that alg. works well. We can leave this
       * "dead" code for a bit
       */
      dumpDeadEndConfigs(e) {
        console.log("dead end configs: ");
        const decs = e.deadEndConfigs;
        for (const c of decs) {
          let trans = "no edges";
          if (c.state.transitions.length > 0) {
            const t = c.state.transitions[0];
            if (t instanceof AtomTransition) {
              trans = "Atom " + this.getTokenName(t.labelValue);
            } else if (t instanceof SetTransition) {
              const neg = t instanceof NotSetTransition;
              trans = (neg ? "~" : "") + "Set " + t.label;
            }
          }
          console.error(c.toString(this.parser, true) + ":" + trans);
        }
      }
      predicateDFAState(dfaState, decisionState) {
        const altCount = decisionState.transitions.length;
        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, altCount);
        if (altToPred !== null) {
          dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
          dfaState.prediction = ATN.INVALID_ALT_NUMBER;
        } else {
          dfaState.prediction = altsToCollectPredsFrom.nextSetBit(0);
        }
      }
      // comes back with reach.uniqueAlt set to a valid alt
      execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {
        if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
          console.log("execATNWithFullContext " + s0);
        }
        const fullCtx = true;
        let foundExactAmbig = false;
        let reach;
        let previous = s0;
        input.seek(startIndex);
        let t = input.LA(1);
        let predictedAlt = -1;
        for (; ; ) {
          reach = this.computeReachSet(previous, t, fullCtx);
          if (reach === null) {
            const e = this.noViableAlt(input, outerContext, previous, startIndex);
            input.seek(startIndex);
            const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
            if (alt !== ATN.INVALID_ALT_NUMBER) {
              return alt;
            } else {
              throw e;
            }
          }
          const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
          if (_ParserATNSimulator.debug) {
            console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));
          }
          reach.uniqueAlt = _ParserATNSimulator.getUniqueAlt(reach);
          if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
            predictedAlt = reach.uniqueAlt;
            break;
          } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
            if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
              break;
            }
          } else {
            if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
              foundExactAmbig = true;
              predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
              break;
            }
          }
          previous = reach;
          if (t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
          this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
          return predictedAlt;
        }
        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, reach.getAlts(), reach);
        return predictedAlt;
      }
      computeReachSet(closure, t, fullCtx) {
        if (_ParserATNSimulator.debug) {
          console.log("in computeReachSet, starting closure: " + closure);
        }
        const intermediate = new ATNConfigSet(fullCtx);
        let skippedStopStates = null;
        for (const c of closure) {
          if (_ParserATNSimulator.debug) {
            console.log("testing " + this.getTokenName(t) + " at " + c);
          }
          if (c.state instanceof RuleStopState) {
            if (fullCtx || t === Token.EOF) {
              if (skippedStopStates === null) {
                skippedStopStates = [];
              }
              skippedStopStates.push(c);
            }
            continue;
          }
          for (const trans of c.state.transitions) {
            const target = this.getReachableTarget(trans, t);
            if (target !== null) {
              const cfg = ATNConfig.createWithConfig(target, c);
              intermediate.add(cfg, this.mergeCache);
              if (_ParserATNSimulator.debugAdd) {
                console.log("added " + cfg + " to intermediate");
              }
            }
          }
        }
        let reach = null;
        if (skippedStopStates === null && t !== Token.EOF) {
          if (intermediate.length === 1) {
            reach = intermediate;
          } else if (_ParserATNSimulator.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {
            reach = intermediate;
          }
        }
        if (reach === null) {
          reach = new ATNConfigSet(fullCtx);
          const closureBusy = new HashSet();
          const treatEofAsEpsilon = t === Token.EOF;
          for (const config of intermediate) {
            this.closure(config, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
          }
        }
        if (t === Token.EOF) {
          reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
        }
        if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
          for (const config of skippedStopStates) {
            reach.add(config, this.mergeCache);
          }
        }
        if (_ParserATNSimulator.traceATNSimulator) {
          console.log("computeReachSet " + closure + " -> " + reach);
        }
        if (reach.length === 0) {
          return null;
        } else {
          return reach;
        }
      }
      /**
       * Return a configuration set containing only the configurations from
       * `configs` which are in a {@link RuleStopState}. If all
       * configurations in `configs` are already in a rule stop state, this
       * method simply returns `configs`.
       *
       * When `lookToEndOfRule` is true, this method uses
       * {@link ATN.nextTokens} for each configuration in `configs` which is
       * not already in a rule stop state to see if a rule stop state is reachable
       * from the configuration via epsilon-only transitions.
       *
       * @param configs the configuration set to update
       * @param lookToEndOfRule when true, this method checks for rule stop states
       * reachable by epsilon-only transitions from each configuration in
       * `configs`.
       *
       * @returns `configs` if all configurations in `configs` are in a
       * rule stop state, otherwise return a new configuration set containing only
       * the configurations from `configs` which are in a rule stop state
       */
      removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
        if (PredictionMode.allConfigsInRuleStopStates(configs)) {
          return configs;
        }
        const result = new ATNConfigSet(configs.fullCtx);
        for (const config of configs) {
          if (config.state instanceof RuleStopState) {
            result.add(config, this.mergeCache);
            continue;
          }
          if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
            const nextTokens = this.atn.nextTokens(config.state);
            if (nextTokens.contains(Token.EPSILON)) {
              const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
              result.add(ATNConfig.createWithConfig(endOfRuleState, config), this.mergeCache);
            }
          }
        }
        return result;
      }
      computeStartState(p, ctx, fullCtx) {
        const initialContext = predictionContextFromRuleContext(this.atn, ctx);
        const configs = new ATNConfigSet(fullCtx);
        if (_ParserATNSimulator.traceATNSimulator) {
          console.log("computeStartState from ATN state " + p + " initialContext=" + initialContext.toString(this.parser));
        }
        for (let i = 0; i < p.transitions.length; i++) {
          const target = p.transitions[i].target;
          const c = ATNConfig.createWithContext(target, i + 1, initialContext);
          const closureBusy = new HashSet();
          this.closure(c, configs, closureBusy, true, fullCtx, false);
        }
        return configs;
      }
      /**
       * This method transforms the start state computed by
       * {@link computeStartState} to the special start state used by a
       * precedence DFA for a particular precedence value. The transformation
       * process applies the following changes to the start state's configuration
       * set.
       *
       * 1. Evaluate the precedence predicates for each configuration using
       * {@link SemanticContext//evalPrecedence}.
       * 2. Remove all configurations which predict an alternative greater than
       * 1, for which another configuration that predicts alternative 1 is in the
       * same ATN state with the same prediction context. This transformation is
       * valid for the following reasons:
       * 3. The closure block cannot contain any epsilon transitions which bypass
       * the body of the closure, so all states reachable via alternative 1 are
       * part of the precedence alternatives of the transformed left-recursive
       * rule.
       * 4. The "primary" portion of a left recursive rule cannot contain an
       * epsilon transition, so the only way an alternative other than 1 can exist
       * in a state that is also reachable via alternative 1 is by nesting calls
       * to the left-recursive rule, with the outer calls not being at the
       * preferred precedence level.
       *
       *
       * The prediction context must be considered by this filter to address
       * situations like the following.
       *
       * `
       * ```
       * grammar TA;
       * prog: statement* EOF;
       * statement: letterA | statement letterA 'b' ;
       * letterA: 'a';
       * ```
       * `
       *
       * If the above grammar, the ATN state immediately before the token
       * reference `'a'` in `letterA` is reachable from the left edge
       * of both the primary and closure blocks of the left-recursive rule
       * `statement`. The prediction context associated with each of these
       * configurations distinguishes between them, and prevents the alternative
       * which stepped out to `prog` (and then back in to `statement`
       * from being eliminated by the filter.
       *
       * @param configs The configuration set computed by
       * {@link computeStartState} as the start state for the DFA.
       * @returns The transformed configuration set representing the start state
       * for a precedence DFA at a particular precedence level (determined by
       * calling {@link Parser//getPrecedence})
       */
      applyPrecedenceFilter(configs) {
        const statesFromAlt1 = [];
        const configSet = new ATNConfigSet(configs.fullCtx);
        for (const config of configs) {
          if (config.alt !== 1) {
            continue;
          }
          const updatedContext = config.semanticContext.evalPrecedence(
            this.parser,
            this.predictionState.outerContext
          );
          if (updatedContext === null) {
            continue;
          }
          statesFromAlt1[config.state.stateNumber] = config.context;
          if (updatedContext !== config.semanticContext) {
            configSet.add(ATNConfig.duplicate(config, updatedContext), this.mergeCache);
          } else {
            configSet.add(config, this.mergeCache);
          }
        }
        for (const config of configs) {
          if (config.alt === 1) {
            continue;
          }
          if (!config.precedenceFilterSuppressed) {
            const context = statesFromAlt1[config.state.stateNumber] || null;
            if (context !== null && context.equals(config.context)) {
              continue;
            }
          }
          configSet.add(config, this.mergeCache);
        }
        return configSet;
      }
      getReachableTarget(trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
          return trans.target;
        } else {
          return null;
        }
      }
      getPredsForAmbigAlts(ambigAlts, configs, altCount) {
        let altToPred = [];
        for (const c of configs) {
          if (ambigAlts.get(c.alt)) {
            altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] ?? null, c.semanticContext);
          }
        }
        let nPredAlts = 0;
        for (let i = 1; i < altCount + 1; i++) {
          const pred = altToPred[i] ?? null;
          if (pred === null) {
            altToPred[i] = SemanticContext.NONE;
          } else if (pred !== SemanticContext.NONE) {
            nPredAlts += 1;
          }
        }
        if (nPredAlts === 0) {
          altToPred = null;
        }
        if (_ParserATNSimulator.debug) {
          console.log("getPredsForAmbigAlts result " + arrayToString(altToPred));
        }
        return altToPred;
      }
      getPredicatePredictions(ambigAlts, altToPred) {
        const pairs = [];
        let containsPredicate = false;
        for (let i = 1; i < altToPred.length; i++) {
          const pred = altToPred[i];
          if (ambigAlts.get(i)) {
            pairs.push({ pred, alt: i });
          }
          if (pred !== SemanticContext.NONE) {
            containsPredicate = true;
          }
        }
        if (!containsPredicate) {
          return null;
        }
        return pairs;
      }
      /**
       * This method is used to improve the localization of error messages by
       * choosing an alternative rather than throwing a
       * {@link NoViableAltException} in particular prediction scenarios where the
       * {@link ERROR} state was reached during ATN simulation.
       *
       *
       * The default implementation of this method uses the following
       * algorithm to identify an ATN configuration which successfully parsed the
       * decision entry rule. Choosing such an alternative ensures that the
       * {@link ParserRuleContext} returned by the calling rule will be complete
       * and valid, and the syntax error will be reported later at a more
       * localized location.
       *
       * - If a syntactically valid path or paths reach the end of the decision rule and
       * they are semantically valid if predicated, return the min associated alt.
       * - Else, if a semantically invalid but syntactically valid path exist
       * or paths exist, return the minimum associated alt.
       *
       * - Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.
       *
       *
       * In some scenarios, the algorithm described above could predict an
       * alternative which will result in a {@link FailedPredicateException} in
       * the parser. Specifically, this could occur if the *only* configuration
       * capable of successfully parsing to the end of the decision rule is
       * blocked by a semantic predicate. By choosing this alternative within
       * {@link adaptivePredict} instead of throwing a
       * {@link NoViableAltException}, the resulting
       * {@link FailedPredicateException} in the parser will identify the specific
       * predicate which is preventing the parser from successfully parsing the
       * decision rule, which helps developers identify and correct logic errors
       * in semantic predicates.
       *
       * @param configs The ATN configurations which were valid immediately before
       * the {@link ERROR} state was reached
       * @param outerContext The is the \gamma_0 initial parser context from the paper
       * or the parser stack at the instant before prediction commences.
       *
       * @returns The value to return from {@link adaptivePredict}, or
       * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
       * identified and {@link adaptivePredict} should report an error instead
       */
      getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
        const splitConfigs = this.splitAccordingToSemanticValidity(configs, outerContext);
        const semValidConfigs = splitConfigs[0];
        const semInvalidConfigs = splitConfigs[1];
        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        }
        if (semInvalidConfigs.length > 0) {
          alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
          if (alt !== ATN.INVALID_ALT_NUMBER) {
            return alt;
          }
        }
        return ATN.INVALID_ALT_NUMBER;
      }
      getAltThatFinishedDecisionEntryRule(configs) {
        const alts = [];
        for (const c of configs) {
          if (c.reachesIntoOuterContext || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {
            if (alts.indexOf(c.alt) < 0) {
              alts.push(c.alt);
            }
          }
        }
        if (alts.length === 0) {
          return ATN.INVALID_ALT_NUMBER;
        } else {
          return Math.min(...alts);
        }
      }
      /**
       * Walk the list of configurations and split them according to
       * those that have preds evaluating to true/false.  If no pred, assume
       * true pred and include in succeeded set.  Returns Pair of sets.
       *
       * Create a new set so as not to alter the incoming parameter.
       *
       * Assumption: the input stream has been restored to the starting point
       * prediction, which is where predicates need to evaluate.
       */
      splitAccordingToSemanticValidity(configs, outerContext) {
        const succeeded = new ATNConfigSet(configs.fullCtx);
        const failed = new ATNConfigSet(configs.fullCtx);
        for (const c of configs) {
          if (c.semanticContext !== SemanticContext.NONE) {
            const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
            if (predicateEvaluationResult) {
              succeeded.add(c);
            } else {
              failed.add(c);
            }
          } else {
            succeeded.add(c);
          }
        }
        return [succeeded, failed];
      }
      /**
       * Look through a list of predicate/alt pairs, returning alts for the
       * pairs that win. A `NONE` predicate indicates an alt containing an
       * unpredicated config which behaves as "always true." If !complete
       * then we stop at the first predicate that evaluates to true. This
       * includes pairs with null predicates.
       */
      evalSemanticContext(predPredictions, outerContext, complete) {
        const predictions = new BitSet();
        for (const pair of predPredictions) {
          if (pair.pred === SemanticContext.NONE) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
            continue;
          }
          const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
          if (_ParserATNSimulator.debug || _ParserATNSimulator.dfaDebug) {
            console.log("eval pred " + pair + "=" + predicateEvaluationResult);
          }
          if (predicateEvaluationResult) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
          }
        }
        return predictions;
      }
      // TODO: If we are doing predicates, there is no point in pursuing
      //     closure operations if we reach a DFA state that uniquely predicts
      //     alternative. We will not be caching that DFA state and it is a
      //     waste to pursue the closure. Might have to advance when we do
      //     ambig detection thought :(
      //
      closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
        const initialDepth = 0;
        this.closureCheckingStopState(
          config,
          configs,
          closureBusy,
          collectPredicates,
          fullCtx,
          initialDepth,
          treatEofAsEpsilon
        );
      }
      closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
        if (_ParserATNSimulator.traceATNSimulator || _ParserATNSimulator.debugClosure) {
          console.log("closure(" + config.toString(this.parser, true) + ")");
        }
        if (config.state instanceof RuleStopState) {
          if (config.context && !config.context.isEmpty()) {
            for (let i = 0; i < config.context.length; i++) {
              if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
                if (fullCtx) {
                  configs.add(
                    ATNConfig.createWithConfig(
                      config.state,
                      config,
                      EmptyPredictionContext.instance
                    ),
                    this.mergeCache
                  );
                  continue;
                } else {
                  if (_ParserATNSimulator.debug) {
                    console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                  }
                  this.closure_(
                    config,
                    configs,
                    closureBusy,
                    collectPredicates,
                    fullCtx,
                    depth,
                    treatEofAsEpsilon
                  );
                }
                continue;
              }
              const returnState = this.atn.states[config.context.getReturnState(i)];
              const newContext = config.context.getParent(i);
              const c = ATNConfig.createWithContext(returnState, config.alt, newContext, config.semanticContext);
              c.reachesIntoOuterContext = config.reachesIntoOuterContext;
              this.closureCheckingStopState(
                c,
                configs,
                closureBusy,
                collectPredicates,
                fullCtx,
                depth - 1,
                treatEofAsEpsilon
              );
            }
            return;
          } else if (fullCtx) {
            configs.add(config, this.mergeCache);
            return;
          } else {
            if (_ParserATNSimulator.debug) {
              console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
          }
        }
        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
      }
      // Do the actual work of walking epsilon edges//
      closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
        const p = config.state;
        if (!p.epsilonOnlyTransitions) {
          configs.add(config, this.mergeCache);
        }
        for (let i = 0; i < p.transitions.length; i++) {
          if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) {
            continue;
          }
          const t = p.transitions[i];
          const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
          const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
          if (c) {
            let newDepth = depth;
            if (config.state.constructor.stateType === ATNState.RULE_STOP) {
              if (this.predictionState.dfa && this.predictionState?.dfa.isPrecedenceDfa) {
                const outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                if (outermostPrecedenceReturn === this.predictionState?.dfa.atnStartState?.ruleIndex) {
                  c.precedenceFilterSuppressed = true;
                }
              }
              c.reachesIntoOuterContext = true;
              if (closureBusy.getOrAdd(c) !== c) {
                continue;
              }
              configs.dipsIntoOuterContext = true;
              newDepth -= 1;
              if (_ParserATNSimulator.debug) {
                console.log("dips into outer ctx: " + c);
              }
            } else {
              if (!t.isEpsilon && closureBusy.getOrAdd(c) !== c) {
                continue;
              }
              if (t instanceof RuleTransition) {
                if (newDepth >= 0) {
                  newDepth += 1;
                }
              }
            }
            this.closureCheckingStopState(
              c,
              configs,
              closureBusy,
              continueCollecting,
              fullCtx,
              newDepth,
              treatEofAsEpsilon
            );
          }
        }
      }
      canDropLoopEntryEdgeInLeftRecursiveRule(config) {
        const p = config.state;
        if (p.constructor.stateType !== ATNState.STAR_LOOP_ENTRY || !config.context) {
          return false;
        }
        if (!p.precedenceRuleDecision || config.context.isEmpty() || config.context.hasEmptyPath()) {
          return false;
        }
        const numCtxs = config.context.length;
        for (let i = 0; i < numCtxs; i++) {
          const returnState = this.atn.states[config.context.getReturnState(i)];
          if (returnState.ruleIndex !== p.ruleIndex) {
            return false;
          }
        }
        const decisionStartState = p.transitions[0].target;
        const blockEndStateNum = decisionStartState.endState.stateNumber;
        const blockEndState = this.atn.states[blockEndStateNum];
        for (let i = 0; i < numCtxs; i++) {
          const returnStateNumber = config.context.getReturnState(i);
          const returnState = this.atn.states[returnStateNumber];
          if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) {
            return false;
          }
          const returnStateTarget = returnState.transitions[0].target;
          if (returnState.constructor.stateType === ATNState.BLOCK_END && returnStateTarget === p) {
            continue;
          }
          if (returnState === blockEndState) {
            continue;
          }
          if (returnStateTarget === blockEndState) {
            continue;
          }
          if (returnStateTarget.constructor.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) {
            continue;
          }
          return false;
        }
        return true;
      }
      getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
        switch (t.transitionType) {
          case Transition.RULE: {
            return this.ruleTransition(config, t);
          }
          case Transition.PRECEDENCE: {
            return this.precedenceTransition(
              config,
              t,
              collectPredicates,
              inContext,
              fullCtx
            );
          }
          case Transition.PREDICATE: {
            return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
          }
          case Transition.ACTION: {
            if (_ParserATNSimulator.debug) {
              const at = t;
              const index = at.actionIndex === -1 ? 65535 : at.actionIndex;
              console.log("ACTION edge " + at.ruleIndex + ":" + index);
            }
            return ATNConfig.createWithConfig(t.target, config);
          }
          case Transition.EPSILON: {
            return ATNConfig.createWithConfig(t.target, config);
          }
          case Transition.ATOM:
          case Transition.RANGE:
          case Transition.SET: {
            if (treatEofAsEpsilon) {
              if (t.matches(Token.EOF, 0, 1)) {
                return ATNConfig.createWithConfig(t.target, config);
              }
            }
            return null;
          }
          default:
            return null;
        }
      }
      precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
        if (_ParserATNSimulator.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
          if (this.parser !== null) {
            console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
          }
        }
        let c = null;
        if (collectPredicates && inContext) {
          if (fullCtx && this.predictionState?.input) {
            const currentPosition = this.predictionState.input.index;
            this.predictionState.input.seek(this.predictionState.startIndex);
            const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);
            this.predictionState.input.seek(currentPosition);
            if (predSucceeds) {
              c = ATNConfig.createWithConfig(pt.target, config);
            }
          } else {
            const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);
          }
        } else {
          c = ATNConfig.createWithConfig(pt.target, config);
        }
        if (_ParserATNSimulator.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      predTransition(config, pt, collectPredicates, inContext, fullCtx) {
        if (_ParserATNSimulator.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
          if (this.parser !== null) {
            console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
          }
        }
        let c = null;
        if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {
          if (fullCtx && this.predictionState?.input) {
            const currentPosition = this.predictionState.input.index;
            this.predictionState.input.seek(this.predictionState.startIndex);
            const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);
            this.predictionState.input.seek(currentPosition);
            if (predSucceeds) {
              c = ATNConfig.createWithConfig(pt.target, config);
            }
          } else {
            const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);
          }
        } else {
          c = ATNConfig.createWithConfig(pt.target, config);
        }
        if (_ParserATNSimulator.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      ruleTransition(config, t) {
        if (_ParserATNSimulator.debug) {
          console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
        }
        const returnState = t.followState;
        const newContext = createSingletonPredictionContext(config.context ?? void 0, returnState.stateNumber);
        return ATNConfig.createWithConfig(t.target, config, newContext);
      }
      getConflictingAlts(configs) {
        const altSets = PredictionMode.getConflictingAltSubsets(configs);
        return PredictionMode.getAlts(altSets);
      }
      /**
       * Sam pointed out a problem with the previous definition, v3, of
       * ambiguous states. If we have another state associated with conflicting
       * alternatives, we should keep going. For example, the following grammar
       *
       * s : (ID | ID ID?) ';' ;
       *
       * When the ATN simulation reaches the state before ';', it has a DFA
       * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
       * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
       * because alternative to has another way to continue, via [6|2|[]].
       * The key is that we have a single state that has config's only associated
       * with a single alternative, 2, and crucially the state transitions
       * among the configurations are all non-epsilon transitions. That means
       * we don't consider any conflicts that include alternative 2. So, we
       * ignore the conflict between alts 1 and 2. We ignore a set of
       * conflicting alts when there is an intersection with an alternative
       * associated with a single alt state in the state -> config-list map.
       *
       * It's also the case that we might have two conflicting configurations but
       * also a 3rd nonconflicting configuration for a different alternative:
       * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
       *
       * a : A | A | A B ;
       *
       * After matching input A, we reach the stop state for rule A, state 1.
       * State 8 is the state right before B. Clearly alternatives 1 and 2
       * conflict and no amount of further lookahead will separate the two.
       * However, alternative 3 will be able to continue and so we do not
       * stop working on this state. In the previous example, we're concerned
       * with states associated with the conflicting alternatives. Here alt
       * 3 is not associated with the conflicting configs, but since we can continue
       * looking for input reasonably, I don't declare the state done. We
       * ignore a set of conflicting alts when we have an alternative
       * that we still need to pursue
       */
      getConflictingAltsOrUniqueAlt(configs) {
        let conflictingAlts;
        if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
          conflictingAlts = new BitSet();
          conflictingAlts.set(configs.uniqueAlt);
        } else {
          conflictingAlts = configs.conflictingAlts;
        }
        return conflictingAlts;
      }
      noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
      }
      /**
       * Add an edge to the DFA, if possible. This method calls
       * {@link addDFAState} to ensure the `to` state is present in the
       * DFA. If `from` is `null`, or if `t` is outside the
       * range of edges that can be represented in the DFA tables, this method
       * returns without adding the edge to the DFA.
       *
       * If `to` is `null`, this method returns `null`.
       * Otherwise, this method returns the {@link DFAState} returned by calling
       * {@link addDFAState} for the `to` state.
       *
       * @param dfa The DFA
       * @param from The source state for the edge
       * @param t The input symbol
       * @param to The target state for the edge
       *
       * @returns If `to` is `null`, this method returns `null`;
       * otherwise this method returns the result of calling {@link addDFAState}
       * on `to`
       */
      addDFAEdge(dfa, from, t, to) {
        if (_ParserATNSimulator.debug) {
          console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
        }
        to = this.addDFAState(dfa, to);
        if (t < -1 || t > this.atn.maxTokenType) {
          return to;
        }
        if (_ParserATNSimulator.debug) {
          console.log("DFA=\n" + dfa.toString(this.parser != null ? this.parser.vocabulary : Vocabulary.EMPTY_VOCABULARY));
        }
        from.edges[t + 1] = to;
        return to;
      }
      /**
       * Add state `D` to the DFA if it is not already present, and return
       * the actual instance stored in the DFA. If a state equivalent to `D`
       * is already in the DFA, the existing state is returned. Otherwise this
       * method returns `D` after adding it to the DFA.
       *
       * If `D` is {@link ERROR}, this method returns {@link ERROR} and
       * does not change the DFA.
       *
       * @param dfa The dfa.
       * @param newState The DFA state to add.
       *
       * @returns The state stored in the DFA. This will be either the existing state if `newState` is already in
       *          the DFA, or `newState` itself if the state was not already present.
       */
      addDFAState(dfa, newState) {
        if (newState === ATNSimulator.ERROR) {
          return newState;
        }
        const existing = dfa.getState(newState);
        if (existing !== null) {
          return existing;
        }
        if (!newState.configs.readOnly) {
          newState.configs.optimizeConfigs(this);
          newState.configs.setReadonly(true);
        }
        if (_ParserATNSimulator.traceATNSimulator) {
          console.log("addDFAState new " + newState);
        }
        dfa.addState(newState);
        return newState;
      }
      reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
        if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
          const interval = new Interval(startIndex, stopIndex + 1);
          console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
        }
        this.parser.errorListenerDispatch.reportAttemptingFullContext(
          this.parser,
          dfa,
          startIndex,
          stopIndex,
          conflictingAlts,
          configs
        );
      }
      reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
        if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
          const interval = new Interval(startIndex, stopIndex + 1);
          console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
        }
        this.parser.errorListenerDispatch.reportContextSensitivity(
          this.parser,
          dfa,
          startIndex,
          stopIndex,
          prediction,
          configs
        );
      }
      // If context sensitive parsing, we know it's ambiguity not conflict.
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
          const interval = new Interval(startIndex, stopIndex + 1);
          console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
        }
        this.parser.errorListenerDispatch.reportAmbiguity(
          this.parser,
          dfa,
          startIndex,
          stopIndex,
          exact,
          ambigAlts,
          configs
        );
      }
    };
    var PredictionContextCache = class {
      static {
        __name(this, "PredictionContextCache");
      }
      cache = new HashMap(ObjectEqualityComparator.instance);
      /**
       * Add a context to the cache and return it. If the context already exists,
       * return that one instead and do not add a new context to the cache.
       * Protect shared cache from unsafe thread access.
       *
       * @param ctx tbd
       * @returns tbd
       */
      add(ctx) {
        if (ctx === EmptyPredictionContext.instance) {
          return ctx;
        }
        const existing = this.cache.get(ctx);
        if (existing) {
          return existing;
        }
        this.cache.set(ctx, ctx);
        return ctx;
      }
      get(ctx) {
        return this.cache.get(ctx);
      }
      get length() {
        return this.cache.size;
      }
    };
    var ProfilingATNSimulator = class extends ParserATNSimulator {
      static {
        __name(this, "ProfilingATNSimulator");
      }
      decisions;
      numDecisions = 0;
      currentDecision = 0;
      currentState;
      /**
       * At the point of LL failover, we record how SLL would resolve the conflict so that
       *  we can determine whether or not a decision / input pair is context-sensitive.
       *  If LL gives a different result than SLL's predicted alternative, we have a
       *  context sensitivity for sure. The converse is not necessarily true, however.
       *  It's possible that after conflict resolution chooses minimum alternatives,
       *  SLL could get the same answer as LL. Regardless of whether or not the result indicates
       *  an ambiguity, it is not treated as a context sensitivity because LL prediction
       *  was not required in order to produce a correct prediction for this decision and input sequence.
       *  It may in fact still be a context sensitivity but we don't know by looking at the
       *  minimum alternatives for the current input.
       */
      conflictingAltResolvedBySLL;
      sllStopIndex = 0;
      llStopIndex = 0;
      constructor(parser) {
        const sharedContextCache = parser.interpreter.sharedContextCache;
        super(parser, parser.interpreter.atn, parser.interpreter.decisionToDFA, sharedContextCache);
        if (sharedContextCache) {
          this.numDecisions = this.atn.decisionToState.length;
          this.decisions = new Array(this.numDecisions);
          for (let i = 0; i < this.numDecisions; i++) {
            this.decisions[i] = new DecisionInfo(i);
          }
        }
      }
      adaptivePredict(input, decision, outerContext) {
        try {
          this.sllStopIndex = -1;
          this.llStopIndex = -1;
          this.currentDecision = decision;
          const start = performance.now();
          const alt = super.adaptivePredict(input, decision, outerContext);
          const stop = performance.now();
          this.decisions[decision].timeInPrediction += stop - start;
          this.decisions[decision].invocations++;
          const sllLook = this.sllStopIndex - this.predictionState.startIndex + 1;
          this.decisions[decision].sllTotalLook += sllLook;
          this.decisions[decision].sllMinLook = this.decisions[decision].sllMinLook === 0 ? sllLook : Math.min(this.decisions[decision].sllMinLook, sllLook);
          if (sllLook > this.decisions[decision].sllMaxLook) {
            this.decisions[decision].sllMaxLook = sllLook;
            this.decisions[decision].sllMaxLookEvent = {
              decision,
              configs: null,
              predictedAlt: alt,
              input,
              startIndex: this.predictionState.startIndex,
              stopIndex: this.sllStopIndex,
              fullCtx: false
            };
          }
          if (this.llStopIndex >= 0) {
            const llLook = this.llStopIndex - this.predictionState.startIndex + 1;
            this.decisions[decision].llTotalLook += llLook;
            this.decisions[decision].llMinLook = this.decisions[decision].llMinLook === 0 ? llLook : Math.min(this.decisions[decision].llMinLook, llLook);
            if (llLook > this.decisions[decision].llMaxLook) {
              this.decisions[decision].llMaxLook = llLook;
              this.decisions[decision].llMaxLookEvent = {
                decision,
                configs: null,
                predictedAlt: alt,
                input,
                startIndex: this.predictionState.startIndex,
                stopIndex: this.llStopIndex,
                fullCtx: true
              };
            }
          }
          return alt;
        } finally {
          this.currentDecision = -1;
        }
      }
      getExistingTargetState(previousD, t) {
        this.sllStopIndex = this.predictionState.input.index;
        const existingTargetState = super.getExistingTargetState(previousD, t);
        if (existingTargetState !== void 0) {
          this.decisions[this.currentDecision].sllDFATransitions++;
          if (existingTargetState === ATNSimulator.ERROR) {
            this.decisions[this.currentDecision].errors.push({
              decision: this.currentDecision,
              configs: previousD.configs,
              input: this.predictionState.input,
              startIndex: this.predictionState.startIndex,
              stopIndex: this.sllStopIndex,
              fullCtx: false
            });
          }
        }
        this.currentState = existingTargetState;
        return existingTargetState;
      }
      computeTargetState(dfa, previousD, t) {
        const state = super.computeTargetState(dfa, previousD, t);
        this.currentState = state;
        return state;
      }
      computeReachSet(closure, t, fullCtx) {
        if (fullCtx && this.predictionState?.input) {
          this.llStopIndex = this.predictionState.input.index;
        }
        const reachConfigs = super.computeReachSet(closure, t, fullCtx);
        if (this.predictionState?.input) {
          if (fullCtx) {
            this.decisions[this.currentDecision].llATNTransitions++;
            if (reachConfigs === null) {
              this.decisions[this.currentDecision].errors.push({
                decision: this.currentDecision,
                configs: closure,
                input: this.predictionState.input,
                startIndex: this.predictionState.startIndex,
                stopIndex: this.sllStopIndex,
                fullCtx: true
              });
            }
          } else {
            this.decisions[this.currentDecision].sllATNTransitions++;
            if (reachConfigs === null) {
              this.decisions[this.currentDecision].errors.push({
                decision: this.currentDecision,
                configs: closure,
                input: this.predictionState.input,
                startIndex: this.predictionState.startIndex,
                stopIndex: this.sllStopIndex,
                fullCtx: false
              });
            }
          }
        }
        return reachConfigs;
      }
      reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
        if (conflictingAlts !== null) {
          this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
        } else {
          this.conflictingAltResolvedBySLL = configs.getAlts().nextSetBit(0);
        }
        this.decisions[this.currentDecision].llFallback++;
        if (conflictingAlts) {
          super.reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex);
        }
      }
      reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
        if (prediction !== this.conflictingAltResolvedBySLL && this.predictionState.input) {
          this.decisions[this.currentDecision].contextSensitivities.push({
            decision: this.currentDecision,
            configs,
            input: this.predictionState.input,
            startIndex,
            stopIndex,
            fullCtx: true
          });
        }
        super.reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex);
      }
      reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs) {
        let prediction;
        if (ambigAlts) {
          prediction = ambigAlts.nextSetBit(0);
        } else {
          prediction = configs.getAlts().nextSetBit(0);
        }
        if (this.predictionState?.input) {
          if (configs.fullCtx && prediction !== this.conflictingAltResolvedBySLL) {
            this.decisions[this.currentDecision].contextSensitivities.push({
              decision: this.currentDecision,
              configs,
              input: this.predictionState.input,
              startIndex,
              stopIndex,
              fullCtx: true
            });
          }
          this.decisions[this.currentDecision].ambiguities.push({
            ambigAlts,
            decision: this.currentDecision,
            configs,
            input: this.predictionState.input,
            startIndex,
            stopIndex,
            fullCtx: configs.fullCtx
          });
        }
        super.reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs);
      }
      getDecisionInfo() {
        return this.decisions;
      }
      getCurrentState() {
        return this.currentState;
      }
    };
    var PredPrediction;
    ((PredPrediction2) => {
      PredPrediction2.toString = /* @__PURE__ */ __name((prediction) => {
        return `(${prediction.pred}, ${prediction.alt})`;
      }, "toString");
    })(PredPrediction || (PredPrediction = {}));
    var ParseCancellationException = class extends Error {
      static {
        __name(this, "ParseCancellationException");
      }
      constructor(e) {
        super();
        this.cause = e;
      }
    };
    var InterpreterDataReader = class {
      static {
        __name(this, "InterpreterDataReader");
      }
      /**
       * The structure of the data file is very simple. Everything is line based with empty lines
       * separating the different parts. For lexers the layout is:
       * token literal names:
       * ...
       *
       * token symbolic names:
       * ...
       *
       * rule names:
       * ...
       *
       * channel names:
       * ...
       *
       * mode names:
       * ...
       *
       * atn:
       * a single line with comma separated int values, enclosed in a pair of squared brackets.
       *
       * Data for a parser does not contain channel and mode names.
       */
      static parseInterpreterData(source) {
        const ruleNames = [];
        const channels = [];
        const modes = [];
        const literalNames = [];
        const symbolicNames = [];
        const lines = source.split("\n");
        let index = 0;
        let line = lines[index++];
        if (line !== "token literal names:") {
          throw new Error("Unexpected data entry");
        }
        do {
          line = lines[index++];
          if (line.length === 0) {
            break;
          }
          literalNames.push(line === "null" ? null : line);
        } while (true);
        line = lines[index++];
        if (line !== "token symbolic names:") {
          throw new Error("Unexpected data entry");
        }
        do {
          line = lines[index++];
          if (line.length === 0) {
            break;
          }
          symbolicNames.push(line === "null" ? null : line);
        } while (true);
        line = lines[index++];
        if (line !== "rule names:") {
          throw new Error("Unexpected data entry");
        }
        do {
          line = lines[index++];
          if (line.length === 0) {
            break;
          }
          ruleNames.push(line);
        } while (true);
        line = lines[index++];
        if (line === "channel names:") {
          do {
            line = lines[index++];
            if (line.length === 0) {
              break;
            }
            channels.push(line);
          } while (true);
          line = lines[index++];
          if (line !== "mode names:") {
            throw new Error("Unexpected data entry");
          }
          do {
            line = lines[index++];
            if (line.length === 0) {
              break;
            }
            modes.push(line);
          } while (true);
        }
        line = lines[index++];
        if (line !== "atn:") {
          throw new Error("Unexpected data entry");
        }
        line = lines[index++];
        const elements = line.split(",");
        let value;
        const serializedATN = [];
        for (let i = 0; i < elements.length; ++i) {
          const element = elements[i];
          if (element.startsWith("[")) {
            value = Number(element.substring(1).trim());
          } else if (element.endsWith("]")) {
            value = Number(element.substring(0, element.length - 1).trim());
          } else {
            value = Number(element.trim());
          }
          serializedATN[i] = value;
        }
        const deserializer = new ATNDeserializer();
        return {
          atn: deserializer.deserialize(serializedATN),
          vocabulary: new Vocabulary(literalNames, symbolicNames, []),
          ruleNames,
          channels: channels.length > 0 ? channels : void 0,
          modes: modes.length > 0 ? modes : void 0
        };
      }
    };
    var AbstractParseTreeVisitor = class {
      static {
        __name(this, "AbstractParseTreeVisitor");
      }
      visit(tree) {
        return tree.accept(this);
      }
      visitChildren(node) {
        let result = this.defaultResult();
        const n2 = node.getChildCount();
        for (let i = 0; i < n2; i++) {
          if (!this.shouldVisitNextChild(node, result)) {
            break;
          }
          const c = node.getChild(i);
          if (c) {
            const childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
          }
        }
        return result;
      }
      visitTerminal(_node) {
        return this.defaultResult();
      }
      visitErrorNode(_node) {
        return this.defaultResult();
      }
      defaultResult() {
        return null;
      }
      shouldVisitNextChild(_node, _currentResult) {
        return true;
      }
      aggregateResult(aggregate, nextResult) {
        return nextResult;
      }
    };
    var ParseTreeWalker = class _ParseTreeWalker {
      static {
        __name(this, "ParseTreeWalker");
      }
      static DEFAULT = new _ParseTreeWalker();
      /**
       * Performs a walk on the given parse tree starting at the root and going down recursively
       * with depth-first search. On each node, {@link ParseTreeWalker.enterRule} is called before
       * recursively walking down into child nodes, then
       * {@link ParseTreeWalker.exitRule} is called after the recursive call to wind up.
       *
       * @param listener The listener used by the walker to process grammar rules
       * @param t The parse tree to be walked on
       */
      walk(listener, t) {
        const errorNode = t instanceof ErrorNode;
        if (errorNode) {
          listener.visitErrorNode(t);
        } else if (t instanceof TerminalNode) {
          listener.visitTerminal(t);
        } else {
          const r = t;
          this.enterRule(listener, r);
          for (let i = 0; i < t.getChildCount(); i++) {
            this.walk(listener, t.getChild(i));
          }
          this.exitRule(listener, r);
        }
      }
      /**
       * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener.enterEveryRule}
       * then by triggering the event specific to the given parse tree node
       *
       * @param listener The listener responding to the trigger events
       * @param r The grammar rule containing the rule context
       */
      enterRule(listener, r) {
        const ctx = r.ruleContext;
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
      }
      /**
       * Exits a grammar rule by first triggering the event specific to the given parse tree node
       * then by triggering the generic event {@link ParseTreeListener.exitEveryRule}
       *
       * @param listener The listener responding to the trigger events
       * @param r The grammar rule containing the rule context
       */
      exitRule(listener, r) {
        const ctx = r.ruleContext;
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
      }
    };
    var CharStream;
    ((CharStream2) => {
      CharStream2.fromString = /* @__PURE__ */ __name((str) => {
        return new CharStreamImpl(str);
      }, "fromString");
    })(CharStream || (CharStream = {}));
    var CharStreamImpl = class {
      static {
        __name(this, "CharStreamImpl");
      }
      name = "";
      index = 0;
      data;
      constructor(input) {
        const codePoints = [];
        for (const char of input) {
          codePoints.push(char.codePointAt(0));
        }
        this.data = new Uint32Array(codePoints);
      }
      /**
       * Reset the stream so that it's in the same state it was
       * when the object was created *except* the data array is not
       * touched.
       */
      reset() {
        this.index = 0;
      }
      consume() {
        if (this.index >= this.data.length) {
          throw new Error("cannot consume EOF");
        }
        this.index += 1;
      }
      LA(offset) {
        if (offset === 0) {
          return 0;
        }
        if (offset < 0) {
          offset += 1;
        }
        const pos = this.index + offset - 1;
        if (pos < 0 || pos >= this.data.length) {
          return Token.EOF;
        }
        return this.data[pos];
      }
      // mark/release do nothing; we have entire buffer
      mark() {
        return -1;
      }
      release(_marker) {
      }
      /**
       * consume() ahead until p==_index; can't just set p=_index as we must
       * update line and column. If we seek backwards, just set p
       */
      seek(index) {
        if (index <= this.index) {
          this.index = index;
          return;
        }
        this.index = Math.min(index, this.data.length);
      }
      getTextFromRange(start, stop) {
        stop = stop ?? this.data.length - 1;
        if (stop >= this.data.length) {
          stop = this.data.length - 1;
        }
        if (start >= this.data.length) {
          return "";
        }
        return this.stringFromRange(start, stop + 1);
      }
      getTextFromInterval(interval) {
        const start = interval.start;
        let stop = interval.stop;
        if (stop >= this.data.length) {
          stop = this.data.length - 1;
        }
        if (start >= this.data.length) {
          return "";
        }
        return this.stringFromRange(start, stop + 1);
      }
      toString() {
        return this.stringFromRange(0);
      }
      get size() {
        return this.data.length;
      }
      getSourceName() {
        if (this.name) {
          return this.name;
        }
        return IntStream.UNKNOWN_SOURCE_NAME;
      }
      stringFromRange(start, stop) {
        const data = this.data.slice(start, stop);
        let result = "";
        data.forEach((value) => {
          result += String.fromCodePoint(value);
        });
        return result;
      }
    };
    var isWritableToken = /* @__PURE__ */ __name((candidate) => {
      return candidate.setText !== void 0;
    }, "isWritableToken");
    var BufferedTokenStream = class {
      static {
        __name(this, "BufferedTokenStream");
      }
      /**
       * The {@link TokenSource} from which tokens for this stream are fetched.
       */
      tokenSource;
      /**
       * A collection of all tokens fetched from the token source. The list is
       * considered a complete view of the input once {@link fetchedEOF} is set
       * to `true`.
       */
      tokens = [];
      /**
       * The index into {@link tokens} of the current token (next token to
       * {@link consume}). {@link tokens}`[p]` should be
       * {@link LT LT(1)}.
       *
       * This field is set to -1 when the stream is first constructed or when
       * {@link setTokenSource} is called, indicating that the first token has
       * not yet been fetched from the token source. For additional information,
       * see the documentation of {@link IntStream} for a description of
       * Initializing Methods.
       */
      p = -1;
      /**
       * Indicates whether the {@link Token.EOF} token has been fetched from
       * {@link tokenSource} and added to {@link tokens}. This field improves
       * performance for the following cases:
       *
       * - {@link consume}: The lookahead check in {@link consume} to prevent
       * consuming the EOF symbol is optimized by checking the values of
       * {@link fetchedEOF} and {@link p} instead of calling {@link LA}.
       * - {@link fetch}: The check to prevent adding multiple EOF symbols into
       * {@link tokens} is trivial with this field.
       */
      fetchedEOF = false;
      constructor(tokenSource) {
        this.tokenSource = tokenSource;
      }
      mark() {
        return 0;
      }
      release(_marker) {
      }
      reset() {
        this.seek(0);
      }
      seek(index) {
        this.lazyInit();
        this.p = this.adjustSeekIndex(index);
      }
      get size() {
        return this.tokens.length;
      }
      get index() {
        return this.p;
      }
      get(index) {
        this.lazyInit();
        return this.tokens[index];
      }
      consume() {
        let skipEofCheck = false;
        if (this.p >= 0) {
          if (this.fetchedEOF) {
            skipEofCheck = this.p < this.tokens.length - 1;
          } else {
            skipEofCheck = this.p < this.tokens.length;
          }
        } else {
          skipEofCheck = false;
        }
        if (!skipEofCheck && this.LA(1) === Token.EOF) {
          throw new Error("cannot consume EOF");
        }
        if (this.sync(this.p + 1)) {
          this.p = this.adjustSeekIndex(this.p + 1);
        }
      }
      /**
       * Make sure index `i` in tokens has a token.
       *
       * @returns {boolean} `true` if a token is located at index `i`, otherwise `false`.
       */
      sync(i) {
        const n2 = i - this.tokens.length + 1;
        if (n2 > 0) {
          const fetched = this.fetch(n2);
          return fetched >= n2;
        }
        return true;
      }
      /**
       * Add `n` elements to buffer.
       *
       * @returns {number} The actual number of elements added to the buffer.
       */
      fetch(n2) {
        if (this.fetchedEOF) {
          return 0;
        }
        for (let i = 0; i < n2; i++) {
          const t = this.tokenSource.nextToken();
          if (isWritableToken(t)) {
            t.tokenIndex = this.tokens.length;
          }
          this.tokens.push(t);
          if (t.type === Token.EOF) {
            this.fetchedEOF = true;
            return i + 1;
          }
        }
        return n2;
      }
      /** Get all tokens from start..stop, inclusively. */
      getTokens(start, stop, types) {
        this.lazyInit();
        if (start === void 0 && stop === void 0) {
          return this.tokens;
        }
        start ??= 0;
        if (stop === void 0) {
          stop = this.tokens.length - 1;
        }
        if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
          throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
        }
        if (start > stop) {
          return [];
        }
        if (types === void 0) {
          return this.tokens.slice(start, stop + 1);
        }
        const subset = [];
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        for (let i = start; i < stop; i++) {
          const t = this.tokens[i];
          if (t.type === Token.EOF) {
            subset.push(t);
            break;
          }
          if (types.has(t.type)) {
            subset.push(t);
          }
        }
        return subset;
      }
      LA(k) {
        return this.LT(k)?.type ?? Token.INVALID_TYPE;
      }
      LB(k) {
        if (this.p - k < 0) {
          return null;
        }
        return this.tokens[this.p - k];
      }
      LT(k) {
        this.lazyInit();
        if (k === 0) {
          return null;
        }
        if (k < 0) {
          return this.LB(-k);
        }
        const i = this.p + k - 1;
        this.sync(i);
        if (i >= this.tokens.length) {
          return this.tokens[this.tokens.length - 1];
        }
        return this.tokens[i];
      }
      /**
       * Allowed derived classes to modify the behavior of operations which change
       * the current stream position by adjusting the target token index of a seek
       * operation. The default implementation simply returns `i`. If an
       * exception is thrown in this method, the current stream index should not be
       * changed.
       *
       * For example, {@link CommonTokenStream} overrides this method to ensure that
       * the seek target is always an on-channel token.
       *
       * @param  i The target token index.
       *
       * @returns The adjusted target token index.
       */
      adjustSeekIndex(i) {
        return i;
      }
      lazyInit() {
        if (this.p === -1) {
          this.setup();
        }
      }
      setup() {
        this.sync(0);
        this.p = this.adjustSeekIndex(0);
      }
      /** Reset this token stream by setting its token source. */
      setTokenSource(tokenSource) {
        this.tokenSource = tokenSource;
        this.tokens = [];
        this.p = -1;
        this.fetchedEOF = false;
      }
      /**
       * Given a starting index, return the index of the next token on channel.
       * Return i if tokens[i] is on channel. Return -1 if there are no tokens
       * on channel between i and EOF.
       */
      nextTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.tokens.length) {
          return -1;
        }
        let token = this.tokens[i];
        while (token.channel !== channel) {
          if (token.type === Token.EOF) {
            return -1;
          }
          i += 1;
          this.sync(i);
          token = this.tokens[i];
        }
        return i;
      }
      /**
       * Given a starting index, return the index of the previous token on
       * channel. Return `i` if `tokens[i]` is on channel. Return -1
       * if there are no tokens on channel between `i` and 0.
       *
       * If `i` specifies an index at or after the EOF token, the EOF token
       * index is returned. This is due to the fact that the EOF token is treated
       * as though it were on every channel.
       */
      previousTokenOnChannel(i, channel) {
        if (i >= this.tokens.length) {
          return this.tokens.length - 1;
        }
        while (i >= 0) {
          const token = this.tokens[i];
          if (token.type === Token.EOF || token.channel === channel) {
            return i;
          }
          --i;
        }
        return i;
      }
      /**
       * Collect all tokens on specified channel to the right of
       * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
       * EOF. If channel is -1, find any non default channel token.
       */
      getHiddenTokensToRight(tokenIndex, channel) {
        if (channel === void 0) {
          channel = -1;
        }
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);
        }
        const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
        const from = tokenIndex + 1;
        const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
        return this.filterForChannel(from, to, channel);
      }
      /**
       * Collect all tokens on specified channel to the left of
       * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
       * If channel is -1, find any non default channel token.
       */
      getHiddenTokensToLeft(tokenIndex, channel) {
        if (channel === void 0) {
          channel = -1;
        }
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);
        }
        const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
        if (prevOnChannel === tokenIndex - 1) {
          return void 0;
        }
        const from = prevOnChannel + 1;
        const to = tokenIndex - 1;
        return this.filterForChannel(from, to, channel);
      }
      filterForChannel(left, right, channel) {
        const hidden = [];
        for (let i = left; i < right + 1; i++) {
          const t = this.tokens[i];
          if (channel === -1) {
            if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
              hidden.push(t);
            }
          } else if (t.channel === channel) {
            hidden.push(t);
          }
        }
        if (hidden.length === 0) {
          return void 0;
        }
        return hidden;
      }
      getSourceName() {
        return this.tokenSource.sourceName;
      }
      /** Get the text of all tokens in this buffer. */
      getText() {
        return this.getTextFromInterval(Interval.of(0, this.size - 1));
      }
      getTextFromInterval(interval) {
        const start = interval.start;
        let stop = interval.stop;
        if (start < 0 || stop < 0) {
          return "";
        }
        this.sync(stop);
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        let result = "";
        for (let i = start; i <= stop; ++i) {
          const t = this.tokens[i];
          if (t.type === Token.EOF) {
            break;
          }
          result += t.text;
        }
        return result;
      }
      getTextFromContext(ctx) {
        return this.getTextFromInterval(ctx.getSourceInterval());
      }
      getTextFromRange(start, stop) {
        if (start !== null && stop !== null) {
          return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));
        }
        return "";
      }
      /** Get all tokens from lexer until EOF. */
      fill() {
        this.lazyInit();
        while (this.fetch(1e3) === 1e3) {
          ;
        }
      }
      setLine(line) {
        this.tokenSource.line = line;
      }
      setColumn(column) {
        this.tokenSource.column = column;
      }
    };
    var CommonTokenStream = class extends BufferedTokenStream {
      static {
        __name(this, "CommonTokenStream");
      }
      /**
       * Specifies the channel to use for filtering tokens.
       *
       *
       * The default value is {@link Token.DEFAULT_CHANNEL}, which matches the
       * default channel assigned to tokens created by the lexer.
       */
      channel = Token.DEFAULT_CHANNEL;
      constructor(lexer, channel) {
        super(lexer);
        this.channel = channel ?? Token.DEFAULT_CHANNEL;
      }
      adjustSeekIndex(i) {
        return this.nextTokenOnChannel(i, this.channel);
      }
      LB(k) {
        if (k === 0 || this.index - k < 0) {
          return null;
        }
        let i = this.index;
        let n2 = 1;
        while (n2 <= k) {
          i = this.previousTokenOnChannel(i - 1, this.channel);
          n2 += 1;
        }
        if (i < 0) {
          return null;
        }
        return this.tokens[i];
      }
      LT(k) {
        this.lazyInit();
        if (k === 0) {
          return null;
        }
        if (k < 0) {
          return this.LB(-k);
        }
        let i = this.index;
        let n2 = 1;
        while (n2 < k) {
          if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
          }
          n2 += 1;
        }
        return this.tokens[i];
      }
      // Count EOF just once.
      getNumberOfOnChannelTokens() {
        let n2 = 0;
        this.fill();
        for (const t of this.tokens) {
          if (t.channel === this.channel) {
            n2 += 1;
          }
          if (t.type === Token.EOF) {
            break;
          }
        }
        return n2;
      }
    };
    var XPathLexer = class _XPathLexer extends Lexer {
      static {
        __name(this, "XPathLexer");
      }
      static TOKEN_REF = 1;
      static RULE_REF = 2;
      static ANYWHERE = 3;
      static ROOT = 4;
      static WILDCARD = 5;
      static BANG = 6;
      static ID = 7;
      static STRING = 8;
      static channelNames = [
        "DEFAULT_TOKEN_CHANNEL",
        "HIDDEN"
      ];
      static literalNames = [
        null,
        null,
        null,
        "'//'",
        "'/'",
        "'*'",
        "'!'"
      ];
      static symbolicNames = [
        null,
        "TOKEN_REF",
        "RULE_REF",
        "ANYWHERE",
        "ROOT",
        "WILDCARD",
        "BANG",
        "ID",
        "STRING"
      ];
      static modeNames = [
        "DEFAULT_MODE"
      ];
      static ruleNames = [
        "ANYWHERE",
        "ROOT",
        "WILDCARD",
        "BANG",
        "ID",
        "NameChar",
        "NameStartChar",
        "STRING"
      ];
      constructor(input) {
        super(input);
        this.interpreter = new LexerATNSimulator(this, _XPathLexer._ATN, _XPathLexer.decisionsToDFA, new PredictionContextCache());
      }
      get grammarFileName() {
        return "XPathLexer.g4";
      }
      get literalNames() {
        return _XPathLexer.literalNames;
      }
      get symbolicNames() {
        return _XPathLexer.symbolicNames;
      }
      get ruleNames() {
        return _XPathLexer.ruleNames;
      }
      get serializedATN() {
        return _XPathLexer._serializedATN;
      }
      get channelNames() {
        return _XPathLexer.channelNames;
      }
      get modeNames() {
        return _XPathLexer.modeNames;
      }
      action(localContext, ruleIndex, actionIndex) {
        switch (ruleIndex) {
          case 4:
            this.ID_action(localContext, actionIndex);
            break;
        }
      }
      ID_action(localContext, actionIndex) {
        switch (actionIndex) {
          case 0:
            const text = this.text;
            if (text.charAt(0) === text.charAt(0).toUpperCase()) {
              this.type = _XPathLexer.TOKEN_REF;
            } else {
              this.type = _XPathLexer.RULE_REF;
            }
            break;
        }
      }
      static _serializedATN = [
        4,
        0,
        8,
        48,
        6,
        -1,
        2,
        0,
        7,
        0,
        2,
        1,
        7,
        1,
        2,
        2,
        7,
        2,
        2,
        3,
        7,
        3,
        2,
        4,
        7,
        4,
        2,
        5,
        7,
        5,
        2,
        6,
        7,
        6,
        2,
        7,
        7,
        7,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        2,
        1,
        2,
        1,
        3,
        1,
        3,
        1,
        4,
        1,
        4,
        5,
        4,
        29,
        8,
        4,
        10,
        4,
        12,
        4,
        32,
        9,
        4,
        1,
        4,
        1,
        4,
        1,
        5,
        1,
        5,
        1,
        6,
        1,
        6,
        1,
        7,
        1,
        7,
        5,
        7,
        42,
        8,
        7,
        10,
        7,
        12,
        7,
        45,
        9,
        7,
        1,
        7,
        1,
        7,
        1,
        43,
        0,
        8,
        1,
        3,
        3,
        4,
        5,
        5,
        7,
        6,
        9,
        7,
        11,
        0,
        13,
        0,
        15,
        8,
        1,
        0,
        2,
        784,
        0,
        0,
        8,
        14,
        27,
        48,
        57,
        65,
        90,
        95,
        95,
        97,
        122,
        127,
        159,
        170,
        170,
        173,
        173,
        181,
        181,
        186,
        186,
        192,
        214,
        216,
        246,
        248,
        705,
        710,
        721,
        736,
        740,
        748,
        748,
        750,
        750,
        768,
        884,
        886,
        887,
        890,
        893,
        895,
        895,
        902,
        902,
        904,
        906,
        908,
        908,
        910,
        929,
        931,
        1013,
        1015,
        1153,
        1155,
        1159,
        1162,
        1327,
        1329,
        1366,
        1369,
        1369,
        1376,
        1416,
        1425,
        1469,
        1471,
        1471,
        1473,
        1474,
        1476,
        1477,
        1479,
        1479,
        1488,
        1514,
        1519,
        1522,
        1536,
        1541,
        1552,
        1562,
        1564,
        1564,
        1568,
        1641,
        1646,
        1747,
        1749,
        1757,
        1759,
        1768,
        1770,
        1788,
        1791,
        1791,
        1807,
        1866,
        1869,
        1969,
        1984,
        2037,
        2042,
        2042,
        2045,
        2045,
        2048,
        2093,
        2112,
        2139,
        2144,
        2154,
        2160,
        2183,
        2185,
        2190,
        2192,
        2193,
        2200,
        2403,
        2406,
        2415,
        2417,
        2435,
        2437,
        2444,
        2447,
        2448,
        2451,
        2472,
        2474,
        2480,
        2482,
        2482,
        2486,
        2489,
        2492,
        2500,
        2503,
        2504,
        2507,
        2510,
        2519,
        2519,
        2524,
        2525,
        2527,
        2531,
        2534,
        2545,
        2556,
        2556,
        2558,
        2558,
        2561,
        2563,
        2565,
        2570,
        2575,
        2576,
        2579,
        2600,
        2602,
        2608,
        2610,
        2611,
        2613,
        2614,
        2616,
        2617,
        2620,
        2620,
        2622,
        2626,
        2631,
        2632,
        2635,
        2637,
        2641,
        2641,
        2649,
        2652,
        2654,
        2654,
        2662,
        2677,
        2689,
        2691,
        2693,
        2701,
        2703,
        2705,
        2707,
        2728,
        2730,
        2736,
        2738,
        2739,
        2741,
        2745,
        2748,
        2757,
        2759,
        2761,
        2763,
        2765,
        2768,
        2768,
        2784,
        2787,
        2790,
        2799,
        2809,
        2815,
        2817,
        2819,
        2821,
        2828,
        2831,
        2832,
        2835,
        2856,
        2858,
        2864,
        2866,
        2867,
        2869,
        2873,
        2876,
        2884,
        2887,
        2888,
        2891,
        2893,
        2901,
        2903,
        2908,
        2909,
        2911,
        2915,
        2918,
        2927,
        2929,
        2929,
        2946,
        2947,
        2949,
        2954,
        2958,
        2960,
        2962,
        2965,
        2969,
        2970,
        2972,
        2972,
        2974,
        2975,
        2979,
        2980,
        2984,
        2986,
        2990,
        3001,
        3006,
        3010,
        3014,
        3016,
        3018,
        3021,
        3024,
        3024,
        3031,
        3031,
        3046,
        3055,
        3072,
        3084,
        3086,
        3088,
        3090,
        3112,
        3114,
        3129,
        3132,
        3140,
        3142,
        3144,
        3146,
        3149,
        3157,
        3158,
        3160,
        3162,
        3165,
        3165,
        3168,
        3171,
        3174,
        3183,
        3200,
        3203,
        3205,
        3212,
        3214,
        3216,
        3218,
        3240,
        3242,
        3251,
        3253,
        3257,
        3260,
        3268,
        3270,
        3272,
        3274,
        3277,
        3285,
        3286,
        3293,
        3294,
        3296,
        3299,
        3302,
        3311,
        3313,
        3315,
        3328,
        3340,
        3342,
        3344,
        3346,
        3396,
        3398,
        3400,
        3402,
        3406,
        3412,
        3415,
        3423,
        3427,
        3430,
        3439,
        3450,
        3455,
        3457,
        3459,
        3461,
        3478,
        3482,
        3505,
        3507,
        3515,
        3517,
        3517,
        3520,
        3526,
        3530,
        3530,
        3535,
        3540,
        3542,
        3542,
        3544,
        3551,
        3558,
        3567,
        3570,
        3571,
        3585,
        3642,
        3648,
        3662,
        3664,
        3673,
        3713,
        3714,
        3716,
        3716,
        3718,
        3722,
        3724,
        3747,
        3749,
        3749,
        3751,
        3773,
        3776,
        3780,
        3782,
        3782,
        3784,
        3790,
        3792,
        3801,
        3804,
        3807,
        3840,
        3840,
        3864,
        3865,
        3872,
        3881,
        3893,
        3893,
        3895,
        3895,
        3897,
        3897,
        3902,
        3911,
        3913,
        3948,
        3953,
        3972,
        3974,
        3991,
        3993,
        4028,
        4038,
        4038,
        4096,
        4169,
        4176,
        4253,
        4256,
        4293,
        4295,
        4295,
        4301,
        4301,
        4304,
        4346,
        4348,
        4680,
        4682,
        4685,
        4688,
        4694,
        4696,
        4696,
        4698,
        4701,
        4704,
        4744,
        4746,
        4749,
        4752,
        4784,
        4786,
        4789,
        4792,
        4798,
        4800,
        4800,
        4802,
        4805,
        4808,
        4822,
        4824,
        4880,
        4882,
        4885,
        4888,
        4954,
        4957,
        4959,
        4992,
        5007,
        5024,
        5109,
        5112,
        5117,
        5121,
        5740,
        5743,
        5759,
        5761,
        5786,
        5792,
        5866,
        5870,
        5880,
        5888,
        5909,
        5919,
        5940,
        5952,
        5971,
        5984,
        5996,
        5998,
        6e3,
        6002,
        6003,
        6016,
        6099,
        6103,
        6103,
        6108,
        6109,
        6112,
        6121,
        6155,
        6169,
        6176,
        6264,
        6272,
        6314,
        6320,
        6389,
        6400,
        6430,
        6432,
        6443,
        6448,
        6459,
        6470,
        6509,
        6512,
        6516,
        6528,
        6571,
        6576,
        6601,
        6608,
        6617,
        6656,
        6683,
        6688,
        6750,
        6752,
        6780,
        6783,
        6793,
        6800,
        6809,
        6823,
        6823,
        6832,
        6845,
        6847,
        6862,
        6912,
        6988,
        6992,
        7001,
        7019,
        7027,
        7040,
        7155,
        7168,
        7223,
        7232,
        7241,
        7245,
        7293,
        7296,
        7304,
        7312,
        7354,
        7357,
        7359,
        7376,
        7378,
        7380,
        7418,
        7424,
        7957,
        7960,
        7965,
        7968,
        8005,
        8008,
        8013,
        8016,
        8023,
        8025,
        8025,
        8027,
        8027,
        8029,
        8029,
        8031,
        8061,
        8064,
        8116,
        8118,
        8124,
        8126,
        8126,
        8130,
        8132,
        8134,
        8140,
        8144,
        8147,
        8150,
        8155,
        8160,
        8172,
        8178,
        8180,
        8182,
        8188,
        8203,
        8207,
        8234,
        8238,
        8255,
        8256,
        8276,
        8276,
        8288,
        8292,
        8294,
        8303,
        8305,
        8305,
        8319,
        8319,
        8336,
        8348,
        8400,
        8412,
        8417,
        8417,
        8421,
        8432,
        8450,
        8450,
        8455,
        8455,
        8458,
        8467,
        8469,
        8469,
        8473,
        8477,
        8484,
        8484,
        8486,
        8486,
        8488,
        8488,
        8490,
        8493,
        8495,
        8505,
        8508,
        8511,
        8517,
        8521,
        8526,
        8526,
        8544,
        8584,
        11264,
        11492,
        11499,
        11507,
        11520,
        11557,
        11559,
        11559,
        11565,
        11565,
        11568,
        11623,
        11631,
        11631,
        11647,
        11670,
        11680,
        11686,
        11688,
        11694,
        11696,
        11702,
        11704,
        11710,
        11712,
        11718,
        11720,
        11726,
        11728,
        11734,
        11736,
        11742,
        11744,
        11775,
        11823,
        11823,
        12293,
        12295,
        12321,
        12335,
        12337,
        12341,
        12344,
        12348,
        12353,
        12438,
        12441,
        12442,
        12445,
        12447,
        12449,
        12538,
        12540,
        12543,
        12549,
        12591,
        12593,
        12686,
        12704,
        12735,
        12784,
        12799,
        13312,
        19903,
        19968,
        42124,
        42192,
        42237,
        42240,
        42508,
        42512,
        42539,
        42560,
        42607,
        42612,
        42621,
        42623,
        42737,
        42775,
        42783,
        42786,
        42888,
        42891,
        42954,
        42960,
        42961,
        42963,
        42963,
        42965,
        42969,
        42994,
        43047,
        43052,
        43052,
        43072,
        43123,
        43136,
        43205,
        43216,
        43225,
        43232,
        43255,
        43259,
        43259,
        43261,
        43309,
        43312,
        43347,
        43360,
        43388,
        43392,
        43456,
        43471,
        43481,
        43488,
        43518,
        43520,
        43574,
        43584,
        43597,
        43600,
        43609,
        43616,
        43638,
        43642,
        43714,
        43739,
        43741,
        43744,
        43759,
        43762,
        43766,
        43777,
        43782,
        43785,
        43790,
        43793,
        43798,
        43808,
        43814,
        43816,
        43822,
        43824,
        43866,
        43868,
        43881,
        43888,
        44010,
        44012,
        44013,
        44016,
        44025,
        44032,
        55203,
        55216,
        55238,
        55243,
        55291,
        63744,
        64109,
        64112,
        64217,
        64256,
        64262,
        64275,
        64279,
        64285,
        64296,
        64298,
        64310,
        64312,
        64316,
        64318,
        64318,
        64320,
        64321,
        64323,
        64324,
        64326,
        64433,
        64467,
        64829,
        64848,
        64911,
        64914,
        64967,
        65008,
        65019,
        65024,
        65039,
        65056,
        65071,
        65075,
        65076,
        65101,
        65103,
        65136,
        65140,
        65142,
        65276,
        65279,
        65279,
        65296,
        65305,
        65313,
        65338,
        65343,
        65343,
        65345,
        65370,
        65382,
        65470,
        65474,
        65479,
        65482,
        65487,
        65490,
        65495,
        65498,
        65500,
        65529,
        65531,
        65536,
        65547,
        65549,
        65574,
        65576,
        65594,
        65596,
        65597,
        65599,
        65613,
        65616,
        65629,
        65664,
        65786,
        65856,
        65908,
        66045,
        66045,
        66176,
        66204,
        66208,
        66256,
        66272,
        66272,
        66304,
        66335,
        66349,
        66378,
        66384,
        66426,
        66432,
        66461,
        66464,
        66499,
        66504,
        66511,
        66513,
        66517,
        66560,
        66717,
        66720,
        66729,
        66736,
        66771,
        66776,
        66811,
        66816,
        66855,
        66864,
        66915,
        66928,
        66938,
        66940,
        66954,
        66956,
        66962,
        66964,
        66965,
        66967,
        66977,
        66979,
        66993,
        66995,
        67001,
        67003,
        67004,
        67072,
        67382,
        67392,
        67413,
        67424,
        67431,
        67456,
        67461,
        67463,
        67504,
        67506,
        67514,
        67584,
        67589,
        67592,
        67592,
        67594,
        67637,
        67639,
        67640,
        67644,
        67644,
        67647,
        67669,
        67680,
        67702,
        67712,
        67742,
        67808,
        67826,
        67828,
        67829,
        67840,
        67861,
        67872,
        67897,
        67968,
        68023,
        68030,
        68031,
        68096,
        68099,
        68101,
        68102,
        68108,
        68115,
        68117,
        68119,
        68121,
        68149,
        68152,
        68154,
        68159,
        68159,
        68192,
        68220,
        68224,
        68252,
        68288,
        68295,
        68297,
        68326,
        68352,
        68405,
        68416,
        68437,
        68448,
        68466,
        68480,
        68497,
        68608,
        68680,
        68736,
        68786,
        68800,
        68850,
        68864,
        68903,
        68912,
        68921,
        69248,
        69289,
        69291,
        69292,
        69296,
        69297,
        69373,
        69404,
        69415,
        69415,
        69424,
        69456,
        69488,
        69509,
        69552,
        69572,
        69600,
        69622,
        69632,
        69702,
        69734,
        69749,
        69759,
        69818,
        69821,
        69821,
        69826,
        69826,
        69837,
        69837,
        69840,
        69864,
        69872,
        69881,
        69888,
        69940,
        69942,
        69951,
        69956,
        69959,
        69968,
        70003,
        70006,
        70006,
        70016,
        70084,
        70089,
        70092,
        70094,
        70106,
        70108,
        70108,
        70144,
        70161,
        70163,
        70199,
        70206,
        70209,
        70272,
        70278,
        70280,
        70280,
        70282,
        70285,
        70287,
        70301,
        70303,
        70312,
        70320,
        70378,
        70384,
        70393,
        70400,
        70403,
        70405,
        70412,
        70415,
        70416,
        70419,
        70440,
        70442,
        70448,
        70450,
        70451,
        70453,
        70457,
        70459,
        70468,
        70471,
        70472,
        70475,
        70477,
        70480,
        70480,
        70487,
        70487,
        70493,
        70499,
        70502,
        70508,
        70512,
        70516,
        70656,
        70730,
        70736,
        70745,
        70750,
        70753,
        70784,
        70853,
        70855,
        70855,
        70864,
        70873,
        71040,
        71093,
        71096,
        71104,
        71128,
        71133,
        71168,
        71232,
        71236,
        71236,
        71248,
        71257,
        71296,
        71352,
        71360,
        71369,
        71424,
        71450,
        71453,
        71467,
        71472,
        71481,
        71488,
        71494,
        71680,
        71738,
        71840,
        71913,
        71935,
        71942,
        71945,
        71945,
        71948,
        71955,
        71957,
        71958,
        71960,
        71989,
        71991,
        71992,
        71995,
        72003,
        72016,
        72025,
        72096,
        72103,
        72106,
        72151,
        72154,
        72161,
        72163,
        72164,
        72192,
        72254,
        72263,
        72263,
        72272,
        72345,
        72349,
        72349,
        72368,
        72440,
        72704,
        72712,
        72714,
        72758,
        72760,
        72768,
        72784,
        72793,
        72818,
        72847,
        72850,
        72871,
        72873,
        72886,
        72960,
        72966,
        72968,
        72969,
        72971,
        73014,
        73018,
        73018,
        73020,
        73021,
        73023,
        73031,
        73040,
        73049,
        73056,
        73061,
        73063,
        73064,
        73066,
        73102,
        73104,
        73105,
        73107,
        73112,
        73120,
        73129,
        73440,
        73462,
        73472,
        73488,
        73490,
        73530,
        73534,
        73538,
        73552,
        73561,
        73648,
        73648,
        73728,
        74649,
        74752,
        74862,
        74880,
        75075,
        77712,
        77808,
        77824,
        78933,
        82944,
        83526,
        92160,
        92728,
        92736,
        92766,
        92768,
        92777,
        92784,
        92862,
        92864,
        92873,
        92880,
        92909,
        92912,
        92916,
        92928,
        92982,
        92992,
        92995,
        93008,
        93017,
        93027,
        93047,
        93053,
        93071,
        93760,
        93823,
        93952,
        94026,
        94031,
        94087,
        94095,
        94111,
        94176,
        94177,
        94179,
        94180,
        94192,
        94193,
        94208,
        100343,
        100352,
        101589,
        101632,
        101640,
        110576,
        110579,
        110581,
        110587,
        110589,
        110590,
        110592,
        110882,
        110898,
        110898,
        110928,
        110930,
        110933,
        110933,
        110948,
        110951,
        110960,
        111355,
        113664,
        113770,
        113776,
        113788,
        113792,
        113800,
        113808,
        113817,
        113821,
        113822,
        113824,
        113827,
        118528,
        118573,
        118576,
        118598,
        119141,
        119145,
        119149,
        119170,
        119173,
        119179,
        119210,
        119213,
        119362,
        119364,
        119808,
        119892,
        119894,
        119964,
        119966,
        119967,
        119970,
        119970,
        119973,
        119974,
        119977,
        119980,
        119982,
        119993,
        119995,
        119995,
        119997,
        120003,
        120005,
        120069,
        120071,
        120074,
        120077,
        120084,
        120086,
        120092,
        120094,
        120121,
        120123,
        120126,
        120128,
        120132,
        120134,
        120134,
        120138,
        120144,
        120146,
        120485,
        120488,
        120512,
        120514,
        120538,
        120540,
        120570,
        120572,
        120596,
        120598,
        120628,
        120630,
        120654,
        120656,
        120686,
        120688,
        120712,
        120714,
        120744,
        120746,
        120770,
        120772,
        120779,
        120782,
        120831,
        121344,
        121398,
        121403,
        121452,
        121461,
        121461,
        121476,
        121476,
        121499,
        121503,
        121505,
        121519,
        122624,
        122654,
        122661,
        122666,
        122880,
        122886,
        122888,
        122904,
        122907,
        122913,
        122915,
        122916,
        122918,
        122922,
        122928,
        122989,
        123023,
        123023,
        123136,
        123180,
        123184,
        123197,
        123200,
        123209,
        123214,
        123214,
        123536,
        123566,
        123584,
        123641,
        124112,
        124153,
        124896,
        124902,
        124904,
        124907,
        124909,
        124910,
        124912,
        124926,
        124928,
        125124,
        125136,
        125142,
        125184,
        125259,
        125264,
        125273,
        126464,
        126467,
        126469,
        126495,
        126497,
        126498,
        126500,
        126500,
        126503,
        126503,
        126505,
        126514,
        126516,
        126519,
        126521,
        126521,
        126523,
        126523,
        126530,
        126530,
        126535,
        126535,
        126537,
        126537,
        126539,
        126539,
        126541,
        126543,
        126545,
        126546,
        126548,
        126548,
        126551,
        126551,
        126553,
        126553,
        126555,
        126555,
        126557,
        126557,
        126559,
        126559,
        126561,
        126562,
        126564,
        126564,
        126567,
        126570,
        126572,
        126578,
        126580,
        126583,
        126585,
        126588,
        126590,
        126590,
        126592,
        126601,
        126603,
        126619,
        126625,
        126627,
        126629,
        126633,
        126635,
        126651,
        130032,
        130041,
        131072,
        173791,
        173824,
        177977,
        177984,
        178205,
        178208,
        183969,
        183984,
        191456,
        194560,
        195101,
        196608,
        201546,
        201552,
        205743,
        917505,
        917505,
        917536,
        917631,
        917760,
        917999,
        662,
        0,
        65,
        90,
        97,
        122,
        170,
        170,
        181,
        181,
        186,
        186,
        192,
        214,
        216,
        246,
        248,
        705,
        710,
        721,
        736,
        740,
        748,
        748,
        750,
        750,
        880,
        884,
        886,
        887,
        890,
        893,
        895,
        895,
        902,
        902,
        904,
        906,
        908,
        908,
        910,
        929,
        931,
        1013,
        1015,
        1153,
        1162,
        1327,
        1329,
        1366,
        1369,
        1369,
        1376,
        1416,
        1488,
        1514,
        1519,
        1522,
        1568,
        1610,
        1646,
        1647,
        1649,
        1747,
        1749,
        1749,
        1765,
        1766,
        1774,
        1775,
        1786,
        1788,
        1791,
        1791,
        1808,
        1808,
        1810,
        1839,
        1869,
        1957,
        1969,
        1969,
        1994,
        2026,
        2036,
        2037,
        2042,
        2042,
        2048,
        2069,
        2074,
        2074,
        2084,
        2084,
        2088,
        2088,
        2112,
        2136,
        2144,
        2154,
        2160,
        2183,
        2185,
        2190,
        2208,
        2249,
        2308,
        2361,
        2365,
        2365,
        2384,
        2384,
        2392,
        2401,
        2417,
        2432,
        2437,
        2444,
        2447,
        2448,
        2451,
        2472,
        2474,
        2480,
        2482,
        2482,
        2486,
        2489,
        2493,
        2493,
        2510,
        2510,
        2524,
        2525,
        2527,
        2529,
        2544,
        2545,
        2556,
        2556,
        2565,
        2570,
        2575,
        2576,
        2579,
        2600,
        2602,
        2608,
        2610,
        2611,
        2613,
        2614,
        2616,
        2617,
        2649,
        2652,
        2654,
        2654,
        2674,
        2676,
        2693,
        2701,
        2703,
        2705,
        2707,
        2728,
        2730,
        2736,
        2738,
        2739,
        2741,
        2745,
        2749,
        2749,
        2768,
        2768,
        2784,
        2785,
        2809,
        2809,
        2821,
        2828,
        2831,
        2832,
        2835,
        2856,
        2858,
        2864,
        2866,
        2867,
        2869,
        2873,
        2877,
        2877,
        2908,
        2909,
        2911,
        2913,
        2929,
        2929,
        2947,
        2947,
        2949,
        2954,
        2958,
        2960,
        2962,
        2965,
        2969,
        2970,
        2972,
        2972,
        2974,
        2975,
        2979,
        2980,
        2984,
        2986,
        2990,
        3001,
        3024,
        3024,
        3077,
        3084,
        3086,
        3088,
        3090,
        3112,
        3114,
        3129,
        3133,
        3133,
        3160,
        3162,
        3165,
        3165,
        3168,
        3169,
        3200,
        3200,
        3205,
        3212,
        3214,
        3216,
        3218,
        3240,
        3242,
        3251,
        3253,
        3257,
        3261,
        3261,
        3293,
        3294,
        3296,
        3297,
        3313,
        3314,
        3332,
        3340,
        3342,
        3344,
        3346,
        3386,
        3389,
        3389,
        3406,
        3406,
        3412,
        3414,
        3423,
        3425,
        3450,
        3455,
        3461,
        3478,
        3482,
        3505,
        3507,
        3515,
        3517,
        3517,
        3520,
        3526,
        3585,
        3632,
        3634,
        3635,
        3648,
        3654,
        3713,
        3714,
        3716,
        3716,
        3718,
        3722,
        3724,
        3747,
        3749,
        3749,
        3751,
        3760,
        3762,
        3763,
        3773,
        3773,
        3776,
        3780,
        3782,
        3782,
        3804,
        3807,
        3840,
        3840,
        3904,
        3911,
        3913,
        3948,
        3976,
        3980,
        4096,
        4138,
        4159,
        4159,
        4176,
        4181,
        4186,
        4189,
        4193,
        4193,
        4197,
        4198,
        4206,
        4208,
        4213,
        4225,
        4238,
        4238,
        4256,
        4293,
        4295,
        4295,
        4301,
        4301,
        4304,
        4346,
        4348,
        4680,
        4682,
        4685,
        4688,
        4694,
        4696,
        4696,
        4698,
        4701,
        4704,
        4744,
        4746,
        4749,
        4752,
        4784,
        4786,
        4789,
        4792,
        4798,
        4800,
        4800,
        4802,
        4805,
        4808,
        4822,
        4824,
        4880,
        4882,
        4885,
        4888,
        4954,
        4992,
        5007,
        5024,
        5109,
        5112,
        5117,
        5121,
        5740,
        5743,
        5759,
        5761,
        5786,
        5792,
        5866,
        5870,
        5880,
        5888,
        5905,
        5919,
        5937,
        5952,
        5969,
        5984,
        5996,
        5998,
        6e3,
        6016,
        6067,
        6103,
        6103,
        6108,
        6108,
        6176,
        6264,
        6272,
        6276,
        6279,
        6312,
        6314,
        6314,
        6320,
        6389,
        6400,
        6430,
        6480,
        6509,
        6512,
        6516,
        6528,
        6571,
        6576,
        6601,
        6656,
        6678,
        6688,
        6740,
        6823,
        6823,
        6917,
        6963,
        6981,
        6988,
        7043,
        7072,
        7086,
        7087,
        7098,
        7141,
        7168,
        7203,
        7245,
        7247,
        7258,
        7293,
        7296,
        7304,
        7312,
        7354,
        7357,
        7359,
        7401,
        7404,
        7406,
        7411,
        7413,
        7414,
        7418,
        7418,
        7424,
        7615,
        7680,
        7957,
        7960,
        7965,
        7968,
        8005,
        8008,
        8013,
        8016,
        8023,
        8025,
        8025,
        8027,
        8027,
        8029,
        8029,
        8031,
        8061,
        8064,
        8116,
        8118,
        8124,
        8126,
        8126,
        8130,
        8132,
        8134,
        8140,
        8144,
        8147,
        8150,
        8155,
        8160,
        8172,
        8178,
        8180,
        8182,
        8188,
        8305,
        8305,
        8319,
        8319,
        8336,
        8348,
        8450,
        8450,
        8455,
        8455,
        8458,
        8467,
        8469,
        8469,
        8473,
        8477,
        8484,
        8484,
        8486,
        8486,
        8488,
        8488,
        8490,
        8493,
        8495,
        8505,
        8508,
        8511,
        8517,
        8521,
        8526,
        8526,
        8544,
        8584,
        11264,
        11492,
        11499,
        11502,
        11506,
        11507,
        11520,
        11557,
        11559,
        11559,
        11565,
        11565,
        11568,
        11623,
        11631,
        11631,
        11648,
        11670,
        11680,
        11686,
        11688,
        11694,
        11696,
        11702,
        11704,
        11710,
        11712,
        11718,
        11720,
        11726,
        11728,
        11734,
        11736,
        11742,
        11823,
        11823,
        12293,
        12295,
        12321,
        12329,
        12337,
        12341,
        12344,
        12348,
        12353,
        12438,
        12445,
        12447,
        12449,
        12538,
        12540,
        12543,
        12549,
        12591,
        12593,
        12686,
        12704,
        12735,
        12784,
        12799,
        13312,
        19903,
        19968,
        42124,
        42192,
        42237,
        42240,
        42508,
        42512,
        42527,
        42538,
        42539,
        42560,
        42606,
        42623,
        42653,
        42656,
        42735,
        42775,
        42783,
        42786,
        42888,
        42891,
        42954,
        42960,
        42961,
        42963,
        42963,
        42965,
        42969,
        42994,
        43009,
        43011,
        43013,
        43015,
        43018,
        43020,
        43042,
        43072,
        43123,
        43138,
        43187,
        43250,
        43255,
        43259,
        43259,
        43261,
        43262,
        43274,
        43301,
        43312,
        43334,
        43360,
        43388,
        43396,
        43442,
        43471,
        43471,
        43488,
        43492,
        43494,
        43503,
        43514,
        43518,
        43520,
        43560,
        43584,
        43586,
        43588,
        43595,
        43616,
        43638,
        43642,
        43642,
        43646,
        43695,
        43697,
        43697,
        43701,
        43702,
        43705,
        43709,
        43712,
        43712,
        43714,
        43714,
        43739,
        43741,
        43744,
        43754,
        43762,
        43764,
        43777,
        43782,
        43785,
        43790,
        43793,
        43798,
        43808,
        43814,
        43816,
        43822,
        43824,
        43866,
        43868,
        43881,
        43888,
        44002,
        44032,
        55203,
        55216,
        55238,
        55243,
        55291,
        63744,
        64109,
        64112,
        64217,
        64256,
        64262,
        64275,
        64279,
        64285,
        64285,
        64287,
        64296,
        64298,
        64310,
        64312,
        64316,
        64318,
        64318,
        64320,
        64321,
        64323,
        64324,
        64326,
        64433,
        64467,
        64829,
        64848,
        64911,
        64914,
        64967,
        65008,
        65019,
        65136,
        65140,
        65142,
        65276,
        65313,
        65338,
        65345,
        65370,
        65382,
        65470,
        65474,
        65479,
        65482,
        65487,
        65490,
        65495,
        65498,
        65500,
        65536,
        65547,
        65549,
        65574,
        65576,
        65594,
        65596,
        65597,
        65599,
        65613,
        65616,
        65629,
        65664,
        65786,
        65856,
        65908,
        66176,
        66204,
        66208,
        66256,
        66304,
        66335,
        66349,
        66378,
        66384,
        66421,
        66432,
        66461,
        66464,
        66499,
        66504,
        66511,
        66513,
        66517,
        66560,
        66717,
        66736,
        66771,
        66776,
        66811,
        66816,
        66855,
        66864,
        66915,
        66928,
        66938,
        66940,
        66954,
        66956,
        66962,
        66964,
        66965,
        66967,
        66977,
        66979,
        66993,
        66995,
        67001,
        67003,
        67004,
        67072,
        67382,
        67392,
        67413,
        67424,
        67431,
        67456,
        67461,
        67463,
        67504,
        67506,
        67514,
        67584,
        67589,
        67592,
        67592,
        67594,
        67637,
        67639,
        67640,
        67644,
        67644,
        67647,
        67669,
        67680,
        67702,
        67712,
        67742,
        67808,
        67826,
        67828,
        67829,
        67840,
        67861,
        67872,
        67897,
        67968,
        68023,
        68030,
        68031,
        68096,
        68096,
        68112,
        68115,
        68117,
        68119,
        68121,
        68149,
        68192,
        68220,
        68224,
        68252,
        68288,
        68295,
        68297,
        68324,
        68352,
        68405,
        68416,
        68437,
        68448,
        68466,
        68480,
        68497,
        68608,
        68680,
        68736,
        68786,
        68800,
        68850,
        68864,
        68899,
        69248,
        69289,
        69296,
        69297,
        69376,
        69404,
        69415,
        69415,
        69424,
        69445,
        69488,
        69505,
        69552,
        69572,
        69600,
        69622,
        69635,
        69687,
        69745,
        69746,
        69749,
        69749,
        69763,
        69807,
        69840,
        69864,
        69891,
        69926,
        69956,
        69956,
        69959,
        69959,
        69968,
        70002,
        70006,
        70006,
        70019,
        70066,
        70081,
        70084,
        70106,
        70106,
        70108,
        70108,
        70144,
        70161,
        70163,
        70187,
        70207,
        70208,
        70272,
        70278,
        70280,
        70280,
        70282,
        70285,
        70287,
        70301,
        70303,
        70312,
        70320,
        70366,
        70405,
        70412,
        70415,
        70416,
        70419,
        70440,
        70442,
        70448,
        70450,
        70451,
        70453,
        70457,
        70461,
        70461,
        70480,
        70480,
        70493,
        70497,
        70656,
        70708,
        70727,
        70730,
        70751,
        70753,
        70784,
        70831,
        70852,
        70853,
        70855,
        70855,
        71040,
        71086,
        71128,
        71131,
        71168,
        71215,
        71236,
        71236,
        71296,
        71338,
        71352,
        71352,
        71424,
        71450,
        71488,
        71494,
        71680,
        71723,
        71840,
        71903,
        71935,
        71942,
        71945,
        71945,
        71948,
        71955,
        71957,
        71958,
        71960,
        71983,
        71999,
        71999,
        72001,
        72001,
        72096,
        72103,
        72106,
        72144,
        72161,
        72161,
        72163,
        72163,
        72192,
        72192,
        72203,
        72242,
        72250,
        72250,
        72272,
        72272,
        72284,
        72329,
        72349,
        72349,
        72368,
        72440,
        72704,
        72712,
        72714,
        72750,
        72768,
        72768,
        72818,
        72847,
        72960,
        72966,
        72968,
        72969,
        72971,
        73008,
        73030,
        73030,
        73056,
        73061,
        73063,
        73064,
        73066,
        73097,
        73112,
        73112,
        73440,
        73458,
        73474,
        73474,
        73476,
        73488,
        73490,
        73523,
        73648,
        73648,
        73728,
        74649,
        74752,
        74862,
        74880,
        75075,
        77712,
        77808,
        77824,
        78895,
        78913,
        78918,
        82944,
        83526,
        92160,
        92728,
        92736,
        92766,
        92784,
        92862,
        92880,
        92909,
        92928,
        92975,
        92992,
        92995,
        93027,
        93047,
        93053,
        93071,
        93760,
        93823,
        93952,
        94026,
        94032,
        94032,
        94099,
        94111,
        94176,
        94177,
        94179,
        94179,
        94208,
        100343,
        100352,
        101589,
        101632,
        101640,
        110576,
        110579,
        110581,
        110587,
        110589,
        110590,
        110592,
        110882,
        110898,
        110898,
        110928,
        110930,
        110933,
        110933,
        110948,
        110951,
        110960,
        111355,
        113664,
        113770,
        113776,
        113788,
        113792,
        113800,
        113808,
        113817,
        119808,
        119892,
        119894,
        119964,
        119966,
        119967,
        119970,
        119970,
        119973,
        119974,
        119977,
        119980,
        119982,
        119993,
        119995,
        119995,
        119997,
        120003,
        120005,
        120069,
        120071,
        120074,
        120077,
        120084,
        120086,
        120092,
        120094,
        120121,
        120123,
        120126,
        120128,
        120132,
        120134,
        120134,
        120138,
        120144,
        120146,
        120485,
        120488,
        120512,
        120514,
        120538,
        120540,
        120570,
        120572,
        120596,
        120598,
        120628,
        120630,
        120654,
        120656,
        120686,
        120688,
        120712,
        120714,
        120744,
        120746,
        120770,
        120772,
        120779,
        122624,
        122654,
        122661,
        122666,
        122928,
        122989,
        123136,
        123180,
        123191,
        123197,
        123214,
        123214,
        123536,
        123565,
        123584,
        123627,
        124112,
        124139,
        124896,
        124902,
        124904,
        124907,
        124909,
        124910,
        124912,
        124926,
        124928,
        125124,
        125184,
        125251,
        125259,
        125259,
        126464,
        126467,
        126469,
        126495,
        126497,
        126498,
        126500,
        126500,
        126503,
        126503,
        126505,
        126514,
        126516,
        126519,
        126521,
        126521,
        126523,
        126523,
        126530,
        126530,
        126535,
        126535,
        126537,
        126537,
        126539,
        126539,
        126541,
        126543,
        126545,
        126546,
        126548,
        126548,
        126551,
        126551,
        126553,
        126553,
        126555,
        126555,
        126557,
        126557,
        126559,
        126559,
        126561,
        126562,
        126564,
        126564,
        126567,
        126570,
        126572,
        126578,
        126580,
        126583,
        126585,
        126588,
        126590,
        126590,
        126592,
        126601,
        126603,
        126619,
        126625,
        126627,
        126629,
        126633,
        126635,
        126651,
        131072,
        173791,
        173824,
        177977,
        177984,
        178205,
        178208,
        183969,
        183984,
        191456,
        194560,
        195101,
        196608,
        201546,
        201552,
        205743,
        47,
        0,
        1,
        1,
        0,
        0,
        0,
        0,
        3,
        1,
        0,
        0,
        0,
        0,
        5,
        1,
        0,
        0,
        0,
        0,
        7,
        1,
        0,
        0,
        0,
        0,
        9,
        1,
        0,
        0,
        0,
        0,
        15,
        1,
        0,
        0,
        0,
        1,
        17,
        1,
        0,
        0,
        0,
        3,
        20,
        1,
        0,
        0,
        0,
        5,
        22,
        1,
        0,
        0,
        0,
        7,
        24,
        1,
        0,
        0,
        0,
        9,
        26,
        1,
        0,
        0,
        0,
        11,
        35,
        1,
        0,
        0,
        0,
        13,
        37,
        1,
        0,
        0,
        0,
        15,
        39,
        1,
        0,
        0,
        0,
        17,
        18,
        5,
        47,
        0,
        0,
        18,
        19,
        5,
        47,
        0,
        0,
        19,
        2,
        1,
        0,
        0,
        0,
        20,
        21,
        5,
        47,
        0,
        0,
        21,
        4,
        1,
        0,
        0,
        0,
        22,
        23,
        5,
        42,
        0,
        0,
        23,
        6,
        1,
        0,
        0,
        0,
        24,
        25,
        5,
        33,
        0,
        0,
        25,
        8,
        1,
        0,
        0,
        0,
        26,
        30,
        3,
        13,
        6,
        0,
        27,
        29,
        3,
        11,
        5,
        0,
        28,
        27,
        1,
        0,
        0,
        0,
        29,
        32,
        1,
        0,
        0,
        0,
        30,
        28,
        1,
        0,
        0,
        0,
        30,
        31,
        1,
        0,
        0,
        0,
        31,
        33,
        1,
        0,
        0,
        0,
        32,
        30,
        1,
        0,
        0,
        0,
        33,
        34,
        6,
        4,
        0,
        0,
        34,
        10,
        1,
        0,
        0,
        0,
        35,
        36,
        7,
        0,
        0,
        0,
        36,
        12,
        1,
        0,
        0,
        0,
        37,
        38,
        7,
        1,
        0,
        0,
        38,
        14,
        1,
        0,
        0,
        0,
        39,
        43,
        5,
        39,
        0,
        0,
        40,
        42,
        9,
        0,
        0,
        0,
        41,
        40,
        1,
        0,
        0,
        0,
        42,
        45,
        1,
        0,
        0,
        0,
        43,
        44,
        1,
        0,
        0,
        0,
        43,
        41,
        1,
        0,
        0,
        0,
        44,
        46,
        1,
        0,
        0,
        0,
        45,
        43,
        1,
        0,
        0,
        0,
        46,
        47,
        5,
        39,
        0,
        0,
        47,
        16,
        1,
        0,
        0,
        0,
        3,
        0,
        30,
        43,
        1,
        1,
        4,
        0
      ];
      static __ATN;
      static get _ATN() {
        if (!_XPathLexer.__ATN) {
          _XPathLexer.__ATN = new ATNDeserializer().deserialize(_XPathLexer._serializedATN);
        }
        return _XPathLexer.__ATN;
      }
      static vocabulary = new Vocabulary(_XPathLexer.literalNames, _XPathLexer.symbolicNames, []);
      get vocabulary() {
        return _XPathLexer.vocabulary;
      }
      static decisionsToDFA = _XPathLexer._ATN.decisionToState.map((ds, index) => {
        return new DFA(ds, index);
      });
    };
    var XPathLexerErrorListener = class extends BaseErrorListener {
      static {
        __name(this, "XPathLexerErrorListener");
      }
      syntaxError(_recognizer, _offendingSymbol, _line, _charPositionInLine, _msg, _e) {
      }
    };
    var XPathElement = class {
      static {
        __name(this, "XPathElement");
      }
      invert;
      nodeName;
      /**
       * Construct element like `/ID` or `ID` or `/*` etc... `nodeName` is undefined if just node
       *
       * @param nodeName The name of the node; may be undefined for any node.
       */
      constructor(nodeName) {
        this.nodeName = nodeName;
        this.invert = false;
      }
      toString() {
        const inv = this.invert ? "!" : "";
        return "XPathElement[" + inv + this.nodeName + "]";
      }
    };
    var XPathRuleAnywhereElement = class extends XPathElement {
      static {
        __name(this, "XPathRuleAnywhereElement");
      }
      ruleIndex;
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        return Trees.findAllRuleNodes(t, this.ruleIndex);
      }
      toString() {
        const inv = this.invert ? "!" : "";
        return "XPathRuleAnywhereElement[" + inv + this.nodeName + "]";
      }
    };
    var XPathRuleElement = class extends XPathElement {
      static {
        __name(this, "XPathRuleElement");
      }
      ruleIndex;
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        const nodes = [];
        for (const c of Trees.getChildren(t)) {
          if (c instanceof ParserRuleContext) {
            if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
      toString() {
        const inv = this.invert ? "!" : "";
        return "XPathRuleElement[" + inv + this.nodeName + "]";
      }
    };
    var XPathTokenAnywhereElement = class extends XPathElement {
      static {
        __name(this, "XPathTokenAnywhereElement");
      }
      tokenType;
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        return Trees.findAllTokenNodes(t, this.tokenType);
      }
      toString() {
        const inv = this.invert ? "!" : "";
        return "XPathTokenAnywhereElement[" + inv + this.nodeName + "]";
      }
    };
    var XPathTokenElement = class extends XPathElement {
      static {
        __name(this, "XPathTokenElement");
      }
      tokenType;
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        const nodes = [];
        for (const c of Trees.getChildren(t)) {
          if (c instanceof TerminalNode && c.symbol) {
            if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
      toString() {
        const inv = this.invert ? "!" : "";
        return "XPathTokenElement[" + inv + this.nodeName + "]";
      }
    };
    var XPathWildcardAnywhereElement = class extends XPathElement {
      static {
        __name(this, "XPathWildcardAnywhereElement");
      }
      constructor() {
        super(XPath.WILDCARD);
      }
      evaluate(t) {
        if (this.invert) {
          return [];
        }
        return Trees.descendants(t);
      }
      toString() {
        const inv = this.invert ? "!" : "";
        return "XPathWildcardAnywhereElement[" + inv + this.nodeName + "]";
      }
    };
    var XPathWildcardElement = class extends XPathElement {
      static {
        __name(this, "XPathWildcardElement");
      }
      constructor() {
        super(XPath.WILDCARD);
      }
      evaluate(t) {
        const kids = [];
        if (this.invert) {
          return kids;
        }
        for (const c of Trees.getChildren(t)) {
          kids.push(c);
        }
        return kids;
      }
      toString() {
        const inv = this.invert ? "!" : "";
        return "XPathWildcardElement[" + inv + this.nodeName + "]";
      }
    };
    var XPath = class _XPath {
      static {
        __name(this, "XPath");
      }
      static WILDCARD = "*";
      // word not operator/separator
      static NOT = "!";
      // word for invert operator
      path;
      elements;
      parser;
      constructor(parser, path) {
        this.parser = parser;
        this.path = path;
        this.elements = this.split(path);
      }
      static findAll(tree, xpath, parser) {
        const p = new _XPath(parser, xpath);
        return p.evaluate(tree);
      }
      // TODO: check for invalid token/rule names, bad syntax
      split(path) {
        const lexer = new XPathLexer(CharStream.fromString(path));
        lexer.recover = (e) => {
          throw e;
        };
        lexer.removeErrorListeners();
        lexer.addErrorListener(new XPathLexerErrorListener());
        const tokenStream = new CommonTokenStream(lexer);
        try {
          tokenStream.fill();
        } catch (e) {
          if (e instanceof LexerNoViableAltException) {
            const pos = lexer.column;
            const msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
            throw new RangeError(msg);
          }
          throw e;
        }
        const tokens = tokenStream.getTokens();
        const elements = [];
        const n2 = tokens.length;
        let i = 0;
        loop:
          while (i < n2) {
            const el = tokens[i];
            let next;
            switch (el.type) {
              case XPathLexer.ROOT:
              case XPathLexer.ANYWHERE:
                const anywhere = el.type === XPathLexer.ANYWHERE;
                i++;
                next = tokens[i];
                const invert = next.type === XPathLexer.BANG;
                if (invert) {
                  i++;
                  next = tokens[i];
                }
                const pathElement = this.getXPathElement(next, anywhere);
                pathElement.invert = invert;
                elements.push(pathElement);
                i++;
                break;
              case XPathLexer.TOKEN_REF:
              case XPathLexer.RULE_REF:
              case XPathLexer.WILDCARD:
                elements.push(this.getXPathElement(el, false));
                ++i;
                break;
              case Token.EOF:
                break loop;
              default:
                throw new Error("Unknown path element " + el);
            }
          }
        return elements;
      }
      /**
       * Return a list of all nodes starting at `t` as root that satisfy the
       * path. The root `/` is relative to the node passed to {@link evaluate}.
       */
      evaluate(t) {
        const dummyRoot = new ParserRuleContext(null);
        dummyRoot.addChild(t);
        let work = /* @__PURE__ */ new Set([dummyRoot]);
        let i = 0;
        while (i < this.elements.length) {
          const next = /* @__PURE__ */ new Set();
          for (const node of work) {
            if (node.getChildCount() > 0) {
              const matching = this.elements[i].evaluate(node);
              matching.forEach((tree) => {
                next.add(tree);
              }, next);
            }
          }
          i++;
          work = next;
        }
        return work;
      }
      /**
       * Convert word like `*` or `ID` or `expr` to a path
       * element. `anywhere` is `true` if `//` precedes the
       * word.
       */
      getXPathElement(wordToken, anywhere) {
        if (wordToken.type === Token.EOF) {
          throw new Error("Missing path element at end of path");
        }
        const word = wordToken.text;
        if (word == null) {
          throw new Error("Expected wordToken to have text content.");
        }
        const ttype = this.parser.getTokenType(word);
        const ruleIndex = this.parser.getRuleIndex(word);
        switch (wordToken.type) {
          case XPathLexer.WILDCARD:
            return anywhere ? new XPathWildcardAnywhereElement() : new XPathWildcardElement();
          case XPathLexer.TOKEN_REF:
          case XPathLexer.STRING:
            if (ttype === Token.INVALID_TYPE) {
              throw new Error(word + " at index " + wordToken.start + " isn't a valid token name");
            }
            return anywhere ? new XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement(word, ttype);
          default:
            if (ruleIndex === -1) {
              throw new Error(word + " at index " + wordToken.start + " isn't a valid rule name");
            }
            return anywhere ? new XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement(word, ruleIndex);
        }
      }
    };
    var Chunk = class {
      static {
        __name(this, "Chunk");
      }
    };
    var ParseTreeMatch = class {
      static {
        __name(this, "ParseTreeMatch");
      }
      /**
       * This is the backing field for {@link #getTree()}.
       */
      tree;
      /**
       * This is the backing field for {@link #getPattern()}.
       */
      pattern;
      /**
       * This is the backing field for {@link #getLabels()}.
       */
      labels;
      /**
       * This is the backing field for {@link #getMismatchedNode()}.
       */
      mismatchedNode;
      /**
       * Constructs a new instance of {@link ParseTreeMatch} from the specified
       * parse tree and pattern.
       *
       * @param tree The parse tree to match against the pattern.
       * @param pattern The parse tree pattern.
       * @param labels A mapping from label names to collections of
       * {@link ParseTree} objects located by the tree pattern matching process.
       * @param mismatchedNode The first node which failed to match the tree
       * pattern during the matching process.
       */
      constructor(tree, pattern, labels, mismatchedNode) {
        this.tree = tree;
        this.pattern = pattern;
        this.labels = labels;
        this.mismatchedNode = mismatchedNode;
      }
      /**
       * Get the last node associated with a specific `label`.
       *
       * For example, for pattern `<id:ID>`, `get("id")` returns the
       * node matched for that `ID`. If more than one node
       * matched the specified label, only the last is returned. If there is
       * no node associated with the label, this returns `null`.
       *
       * Pattern tags like `<ID>` and `<expr>` without labels are
       * considered to be labeled with `ID` and `expr`, respectively.
       *
       * @param label The label to check.
       *
       * @returns The last {@link ParseTree} to match a tag with the specified
       * label, or `null` if no parse tree matched a tag with the label.
       */
      get(label) {
        const parseTrees = this.labels.get(label);
        if (!parseTrees || parseTrees.length === 0) {
          return null;
        }
        return parseTrees[parseTrees.length - 1];
      }
      /**
       * Return all nodes matching a rule or token tag with the specified label.
       *
       * If the `label` is the name of a parser rule or token in the
       * grammar, the resulting list will contain both the parse trees matching
       * rule or tags explicitly labeled with the label and the complete set of
       * parse trees matching the labeled and unlabeled tags in the pattern for
       * the parser rule or token. For example, if `label` is `"foo"`,
       * the result will contain *all* of the following.
       *
       * - Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
       * `<foo:AnyTokenName>`.
       * - Parse tree nodes matching tags of the form `<anyLabel:foo>`.
       * - Parse tree nodes matching tags of the form `<foo>`.
       *
       * @param label The label.
       *
       * @returns A collection of all {@link ParseTree} nodes matching tags with
       * the specified `label`. If no nodes matched the label, an empty list
       * is returned.
       */
      getAll(label) {
        const nodes = this.labels.get(label);
        return nodes ?? [];
      }
      /**
       * Return a mapping from label -> [list of nodes].
       *
       * The map includes special entries corresponding to the names of rules and
       * tokens referenced in tags in the original pattern. For additional
       * information, see the description of {@link getAll(String)}.
       *
       * @returns A mapping from labels to parse tree nodes. If the parse tree
       * pattern did not contain any rule or token tags, this map will be empty.
       */
      getLabels() {
        return this.labels;
      }
      /**
       * Get the node at which we first detected a mismatch.
       *
       * @returns the node at which we first detected a mismatch, or `null`
       * if the match was successful.
       */
      getMismatchedNode() {
        return this.mismatchedNode;
      }
      /**
       * Gets a value indicating whether the match operation succeeded.
       *
       * @returns `true` if the match operation succeeded; otherwise, `false`.
       */
      succeeded() {
        return !this.mismatchedNode;
      }
      /**
       * Get the tree pattern we are matching against.
       *
       * @returns The tree pattern we are matching against.
       */
      getPattern() {
        return this.pattern;
      }
      /**
       * Get the parse tree we are trying to match to a pattern.
       *
       * @returns The {@link ParseTree} we are trying to match to a pattern.
       */
      getTree() {
        return this.tree;
      }
      toString() {
        return `Match ${this.succeeded() ? "succeeded" : "failed"}; found ${this.getLabels().size} labels`;
      }
    };
    var ParseTreePattern = class {
      static {
        __name(this, "ParseTreePattern");
      }
      /**
       * This is the backing field for {@link #getPatternRuleIndex()}.
       */
      patternRuleIndex;
      /**
       * This is the backing field for {@link #getPattern()}.
       */
      pattern;
      /**
       * This is the backing field for {@link #getPatternTree()}.
       */
      patternTree;
      /**
       * This is the backing field for {@link #getMatcher()}.
       */
      matcher;
      /**
       * Construct a new instance of the {@link ParseTreePattern} class.
       *
       * @param matcher The {@link ParseTreePatternMatcher} which created this
       * tree pattern.
       * @param pattern The tree pattern in concrete syntax form.
       * @param patternRuleIndex The parser rule which serves as the root of the
       * tree pattern.
       * @param patternTree The tree pattern in {@link ParseTree} form.
       */
      constructor(matcher, pattern, patternRuleIndex, patternTree) {
        this.matcher = matcher;
        this.patternRuleIndex = patternRuleIndex;
        this.pattern = pattern;
        this.patternTree = patternTree;
      }
      /**
       * Match a specific parse tree against this tree pattern.
       *
       * @param tree The parse tree to match against this tree pattern.
       * @returns A {@link ParseTreeMatch} object describing the result of the
       * match operation. The {@link ParseTreeMatch#succeeded()} method can be
       * used to determine whether or not the match was successful.
       */
      match(tree) {
        return this.matcher.match(tree, this);
      }
      /**
       * Determine whether or not a parse tree matches this tree pattern.
       *
       * @param tree The parse tree to match against this tree pattern.
       * @returns `true` if `tree` is a match for the current tree
       * pattern; otherwise, `false`.
       */
      matches(tree) {
        return this.matcher.match(tree, this).succeeded();
      }
      /**
       * Find all nodes using XPath and then try to match those subtrees against
       * this tree pattern.
       *
       * @param tree The {@link ParseTree} to match against this pattern.
       * @param xpath An expression matching the nodes
       *
       * @returns A collection of {@link ParseTreeMatch} objects describing the
       * successful matches. Unsuccessful matches are omitted from the result,
       * regardless of the reason for the failure.
       */
      findAll(tree, xpath) {
        const subtrees = XPath.findAll(tree, xpath, this.matcher.getParser());
        const matches = new Array();
        for (const t of subtrees) {
          const match = this.match(t);
          if (match.succeeded()) {
            matches.push(match);
          }
        }
        return matches;
      }
      /**
       * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
       *
       * @returns The {@link ParseTreePatternMatcher} which created this tree
       * pattern.
       */
      getMatcher() {
        return this.matcher;
      }
      /**
       * Get the tree pattern in concrete syntax form.
       *
       * @returns The tree pattern in concrete syntax form.
       */
      getPattern() {
        return this.pattern;
      }
      /**
       * Get the parser rule which serves as the outermost rule for the tree
       * pattern.
       *
       * @returns The parser rule which serves as the outermost rule for the tree
       * pattern.
       */
      getPatternRuleIndex() {
        return this.patternRuleIndex;
      }
      /**
       * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
       * the pattern are present in the parse tree as terminal nodes with a symbol
       * of type {@link RuleTagToken} or {@link TokenTagToken}.
       *
       * @returns The tree pattern as a {@link ParseTree}.
       */
      getPatternTree() {
        return this.patternTree;
      }
    };
    var InputMismatchException = class extends RecognitionException {
      static {
        __name(this, "InputMismatchException");
      }
      constructor(recognizer) {
        super({ message: "", recognizer, input: recognizer.inputStream, ctx: recognizer.context });
        this.offendingToken = recognizer.getCurrentToken();
      }
    };
    var FailedPredicateException = class extends RecognitionException {
      static {
        __name(this, "FailedPredicateException");
      }
      ruleIndex = 0;
      predicateIndex = 0;
      predicate;
      constructor(recognizer, predicate, message = null) {
        super({
          message: formatMessage(predicate ?? "no predicate", message ?? null),
          recognizer,
          input: recognizer.inputStream,
          ctx: recognizer.context
        });
        const s = recognizer.atn.states[recognizer.state];
        const trans = s.transitions[0];
        if (trans instanceof PredicateTransition) {
          this.ruleIndex = trans.ruleIndex;
          this.predicateIndex = trans.predIndex;
        } else {
          this.ruleIndex = 0;
          this.predicateIndex = 0;
        }
        this.predicate = predicate;
        this.offendingToken = recognizer.getCurrentToken();
      }
    };
    var formatMessage = /* @__PURE__ */ __name((predicate, message) => {
      if (message !== null) {
        return message;
      }
      return "failed predicate: {" + predicate + "}?";
    }, "formatMessage");
    var DefaultErrorStrategy = class {
      static {
        __name(this, "DefaultErrorStrategy");
      }
      /**
       * Indicates whether the error strategy is currently "recovering from an
       * error". This is used to suppress reporting multiple error messages while
       * attempting to recover from a detected syntax error.
       *
       * @see #inErrorRecoveryMode
       */
      errorRecoveryMode = false;
      /**
       * The index into the input stream where the last error occurred.
       * 	This is used to prevent infinite loops where an error is found
       *  but no token is consumed during recovery...another error is found,
       *  ad nauseam.  This is a failsafe mechanism to guarantee that at least
       *  one token/tree node is consumed for two errors.
       */
      lastErrorIndex = -1;
      lastErrorStates = new IntervalSet();
      /**
       * This field is used to propagate information about the lookahead following
       * the previous match. Since prediction prefers completing the current rule
       * to error recovery efforts, error reporting may occur later than the
       * original point where it was discoverable. The original context is used to
       * compute the true expected sets as though the reporting occurred as early
       * as possible.
       */
      nextTokensContext = null;
      nextTokenState = 0;
      /**
       * The default implementation simply calls {@link endErrorCondition} to
       * ensure that the handler is not in error recovery mode.
       */
      reset(recognizer) {
        this.endErrorCondition(recognizer);
      }
      /**
       * This method is called to enter error recovery mode when a recognition
       * exception is reported.
       *
       * @param _recognizer the parser instance
       */
      beginErrorCondition(_recognizer) {
        this.errorRecoveryMode = true;
      }
      inErrorRecoveryMode(_recognizer) {
        return this.errorRecoveryMode;
      }
      /**
       * This method is called to leave error recovery mode after recovering from
       * a recognition exception.
       */
      endErrorCondition(_recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = new IntervalSet();
        this.lastErrorIndex = -1;
      }
      /**
       * The default implementation simply calls {@link endErrorCondition}.
       */
      reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
      }
      /**
       * The default implementation returns immediately if the handler is already
       * in error recovery mode. Otherwise, it calls {@link beginErrorCondition}
       * and dispatches the reporting task based on the runtime type of `e`
       * according to the following table.
       *
       * - {@link NoViableAltException}: Dispatches the call to {@link reportNoViableAlternative}
       * - {@link InputMismatchException}: Dispatches the call to {@link reportInputMismatch}
       * - {@link FailedPredicateException}: Dispatches the call to {@link reportFailedPredicate}
       * - All other types: calls {@link Parser.notifyErrorListeners} to report the exception
       */
      reportError(recognizer, e) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        if (e instanceof NoViableAltException) {
          this.reportNoViableAlternative(recognizer, e);
        } else if (e instanceof InputMismatchException) {
          this.reportInputMismatch(recognizer, e);
        } else if (e instanceof FailedPredicateException) {
          this.reportFailedPredicate(recognizer, e);
        } else {
          recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
        }
      }
      /**
       * The default implementation resynchronizes the parser by consuming tokens
       * until we find one in the resynchronization set--loosely the set of tokens
       * that can follow the current rule.
       *
       */
      recover(recognizer, _e) {
        if (this.lastErrorIndex === recognizer.inputStream?.index && this.lastErrorStates.contains(recognizer.state)) {
          recognizer.consume();
        }
        this.lastErrorIndex = recognizer.inputStream?.index ?? 0;
        this.lastErrorStates.addOne(recognizer.state);
        const followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
      }
      /**
       * The default implementation of {@link ANTLRErrorStrategy.sync} makes sure
       * that the current lookahead symbol is consistent with what were expecting
       * at this point in the ATN. You can call this anytime but ANTLR only
       * generates code to check before subrules/loops and each iteration.
       *
       * Implements Jim Idle's magic sync mechanism in closures and optional
       * subrules. E.g.,
       *
       * ```
       * a : sync ( stuff sync )* ;
       * sync : {consume to what can follow sync} ;
       * ```
       *
       * At the start of a sub rule upon error, {@link sync} performs single
       * token deletion, if possible. If it can't do that, it bails on the current
       * rule and uses the default error recovery, which consumes until the
       * resynchronization set of the current rule.
       *
       * If the sub rule is optional (`(...)?`, `(...)*`, or block
       * with an empty alternative), then the expected set includes what follows
       * the subrule.
       *
       * During loop iteration, it consumes until it sees a token that can start a
       * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
       * stay in the loop as long as possible.
       *
       * **ORIGINS**
       *
       * Previous versions of ANTLR did a poor job of their recovery within loops.
       * A single mismatch token or missing token would force the parser to bail
       * out of the entire rules surrounding the loop. So, for rule
       *
       * ```
       * classDef : 'class' ID '{' member* '}'
       * ```
       *
       * input with an extra token between members would force the parser to
       * consume until it found the next class definition rather than the next
       * member definition of the current class.
       *
       * This functionality cost a little bit of effort because the parser has to
       * compare token set at the start of the loop and at each iteration. If for
       * some reason speed is suffering for you, you can turn off this
       * functionality by simply overriding this method as a blank { }.
       *
       */
      sync(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        const s = recognizer.atn.states[recognizer.state];
        const la = recognizer.tokenStream.LA(1);
        const nextTokens = recognizer.atn.nextTokens(s);
        if (nextTokens.contains(la)) {
          this.nextTokensContext = null;
          this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
          return;
        }
        if (nextTokens.contains(Token.EPSILON)) {
          if (this.nextTokensContext === null) {
            this.nextTokensContext = recognizer.context;
            this.nextTokenState = recognizer.state;
          }
          return;
        }
        switch (s.constructor.stateType) {
          case ATNState.BLOCK_START:
          case ATNState.STAR_BLOCK_START:
          case ATNState.PLUS_BLOCK_START:
          case ATNState.STAR_LOOP_ENTRY: {
            if (this.singleTokenDeletion(recognizer) !== null) {
              return;
            }
            throw new InputMismatchException(recognizer);
          }
          case ATNState.PLUS_LOOP_BACK:
          case ATNState.STAR_LOOP_BACK: {
            this.reportUnwantedToken(recognizer);
            const expecting = new IntervalSet();
            expecting.addSet(recognizer.getExpectedTokens());
            const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
            break;
          }
          default:
        }
      }
      /**
       * This is called by {@link reportError} when the exception is a
       * {@link NoViableAltException}.
       *
       * @see reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportNoViableAlternative(recognizer, e) {
        if (e.message.length > 0) {
          recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
          return;
        }
        const tokens = recognizer.tokenStream;
        let input;
        if (tokens !== null && e.startToken) {
          if (e.startToken.type === Token.EOF) {
            input = "<EOF>";
          } else {
            input = tokens.getTextFromRange(e.startToken, e.offendingToken);
          }
        } else {
          input = "<unknown input>";
        }
        const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
      }
      /**
       * This is called by {@link reportError} when the exception is an {@link InputMismatchException}.
       *
       * @see reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportInputMismatch(recognizer, e) {
        if (e.message.length > 0) {
          recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
          return;
        }
        const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toStringWithVocabulary(recognizer.vocabulary);
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
      }
      /**
       * This is called by {@link reportError} when the exception is a
       * {@link FailedPredicateException}.
       *
       * @see reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportFailedPredicate(recognizer, e) {
        const ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
        const msg = "rule " + ruleName + " " + e.message;
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
      }
      /**
       * This method is called to report a syntax error which requires the removal
       * of a token from the input stream. At the time this method is called, the
       * erroneous symbol is current `LT(1)` symbol and has not yet been
       * removed from the input stream. When this method returns,
       * `recognizer` is in error recovery mode.
       *
       * This method is called when {@link singleTokenDeletion} identifies
       * single-token deletion as a viable recovery strategy for a mismatched
       * input error.
       *
       * The default implementation simply returns if the handler is already in
       * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to
       * enter error recovery mode, followed by calling
       * {@link Parser.notifyErrorListeners}.
       *
       * @param recognizer the parser instance
       */
      reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        const t = recognizer.getCurrentToken();
        const tokenName = this.getTokenErrorDisplay(t);
        const expecting = this.getExpectedTokens(recognizer);
        const msg = "extraneous input " + tokenName + " expecting " + expecting.toStringWithVocabulary(recognizer.vocabulary);
        recognizer.notifyErrorListeners(msg, t, null);
      }
      /**
       * This method is called to report a syntax error which requires the
       * insertion of a missing token into the input stream. At the time this
       * method is called, the missing token has not yet been inserted. When this
       * method returns, `recognizer` is in error recovery mode.
       *
       * This method is called when {@link singleTokenInsertion} identifies
       * single-token insertion as a viable recovery strategy for a mismatched
       * input error.
       *
       * The default implementation simply returns if the handler is already in
       * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to
       * enter error recovery mode, followed by calling
       * {@link Parser.notifyErrorListeners}.
       *
       * @param recognizer the parser instance
       */
      reportMissingToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        const t = recognizer.getCurrentToken();
        const expecting = this.getExpectedTokens(recognizer);
        const msg = "missing " + expecting.toStringWithVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, null);
      }
      /**
       * The default implementation attempts to recover from the mismatched input
       * by using single token insertion and deletion as described below. If the
       * recovery attempt fails, this method throws an
       * {@link InputMismatchException}.
       *
       * **EXTRA TOKEN** (single token deletion)
       *
       * `LA(1)` is not what we are looking for. If `LA(2)` has the
       * right token, however, then assume `LA(1)` is some extra spurious
       * token and delete it. Then consume and return the next token (which was
       * the `LA(2)` token) as the successful result of the match operation.
       *
       * This recovery strategy is implemented by {@link singleTokenDeletion}.
       *
       * **MISSING TOKEN** (single token insertion)
       *
       * If current token (at `LA(1)`) is consistent with what could come
       * after the expected `LA(1)` token, then assume the token is missing
       * and use the parser's {@link TokenFactory} to create it on the fly. The
       * "insertion" is performed by returning the created token as the successful
       * result of the match operation.
       *
       * This recovery strategy is implemented by {@link singleTokenInsertion}.
       *
       * **EXAMPLE**
       *
       * For example, Input `i=(3;` is clearly missing the `')'`. When
       * the parser returns from the nested call to `expr`, it will have
       * call chain:
       *
       * ```
       * stat -> expr -> atom
       * ```
       *
       * and it will be trying to match the `')'` at this point in the
       * derivation:
       *
       * ```
       * => ID '=' '(' INT ')' ('+' atom)* ';'
       * ^
       * ```
       *
       * The attempt to match `')'` will fail when it sees `';'` and
       * call {@link recoverInline}. To recover, it sees that `LA(1)==';'`
       * is in the set of tokens that can follow the `')'` token reference
       * in rule `atom`. It can assume that you forgot the `')'`.
       */
      recoverInline(recognizer) {
        const matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol) {
          recognizer.consume();
          return matchedSymbol;
        }
        if (this.singleTokenInsertion(recognizer)) {
          return this.getMissingSymbol(recognizer);
        }
        throw new InputMismatchException(recognizer);
      }
      /**
       * This method implements the single-token insertion inline error recovery
       * strategy. It is called by {@link recoverInline} if the single-token
       * deletion strategy fails to recover from the mismatched input. If this
       * method returns `true`, `recognizer` will be in error recovery
       * mode.
       *
       * This method determines whether or not single-token insertion is viable by
       * checking if the `LA(1)` input symbol could be successfully matched
       * if it were instead the `LA(2)` symbol. If this method returns
       * `true`, the caller is responsible for creating and inserting a
       * token with the correct type to produce this behavior.
       *
       * @param recognizer the parser instance
       * @returns `true` if single-token insertion is a viable recovery
       * strategy for the current mismatched input, otherwise `false`
       */
      singleTokenInsertion(recognizer) {
        const currentSymbolType = recognizer.tokenStream?.LA(1) ?? -1;
        const atn = recognizer.atn;
        const currentState = atn.states[recognizer.state];
        const next = currentState.transitions[0].target;
        const expectingAtLL2 = atn.nextTokens(next, recognizer.context ?? void 0);
        if (expectingAtLL2.contains(currentSymbolType)) {
          this.reportMissingToken(recognizer);
          return true;
        }
        return false;
      }
      /**
       * This method implements the single-token deletion inline error recovery
       * strategy. It is called by {@link recoverInline} to attempt to recover
       * from mismatched input. If this method returns null, the parser and error
       * handler state will not have changed. If this method returns non-null,
       * `recognizer` will *not* be in error recovery mode since the
       * returned token was a successful match.
       *
       * If the single-token deletion is successful, this method calls
       * {@link reportUnwantedToken} to report the error, followed by
       * {@link Parser.consume} to actually "delete" the extraneous token. Then,
       * before returning {@link reportMatch} is called to signal a successful
       * match.
       *
       * @param recognizer the parser instance
       * @returns the successfully matched {@link Token} instance if single-token
       * deletion successfully recovers from the mismatched input, otherwise
       * `null`
       */
      singleTokenDeletion(recognizer) {
        const nextTokenType = recognizer.tokenStream?.LA(2) ?? -1;
        const expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
          this.reportUnwantedToken(recognizer);
          recognizer.consume();
          const matchedSymbol = recognizer.getCurrentToken();
          this.reportMatch(recognizer);
          return matchedSymbol;
        }
        return null;
      }
      /**
       * Conjure up a missing token during error recovery.
       *
       * The recognizer attempts to recover from single missing
       * symbols. But, actions might refer to that missing symbol.
       * For example, x=ID {f($x);}. The action clearly assumes
       * that there has been an identifier matched previously and that
       * $x points at that token. If that token is missing, but
       * the next token in the stream is what we want we assume that
       * this token is missing and we keep going. Because we
       * have to return some token to replace the missing token,
       * we have to conjure one up. This method gives the user control
       * over the tokens returned for missing tokens. Mostly,
       * you will want to create something special for identifier
       * tokens. For literals such as '{' and ',', the default
       * action in the parser or tree parser works. It simply creates
       * a CommonToken of the appropriate type. The text will be the token.
       * If you change what tokens must be created by the lexer,
       * override this method to create the appropriate tokens.
       */
      getMissingSymbol(recognizer) {
        const currentSymbol = recognizer.getCurrentToken();
        const expecting = this.getExpectedTokens(recognizer);
        let expectedTokenType = Token.INVALID_TYPE;
        if (expecting.length !== 0) {
          expectedTokenType = expecting.minElement;
        }
        let tokenText;
        if (expectedTokenType === Token.EOF) {
          tokenText = "<missing EOF>";
        } else {
          tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
        }
        let current = currentSymbol;
        const lookBack = recognizer.tokenStream?.LT(-1);
        if (current.type === Token.EOF && lookBack !== null) {
          current = lookBack;
        }
        return recognizer.getTokenFactory().create(
          current.source,
          expectedTokenType,
          tokenText,
          Token.DEFAULT_CHANNEL,
          -1,
          -1,
          current.line,
          current.column
        );
      }
      getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
      }
      /**
       * How should a token be displayed in an error message? The default
       * is to display just the text, but during development you might
       * want to have a lot of information spit out. Override in that case
       * to use t.toString() (which, for CommonToken, dumps everything about
       * the token). This is better than forcing you to override a method in
       * your token objects because you don't have to go modify your lexer
       * so that it creates a new Java type.
       */
      getTokenErrorDisplay(t) {
        if (t === null) {
          return "<no token>";
        }
        let s = t.text;
        if (!s) {
          if (t.type === Token.EOF) {
            s = "<EOF>";
          } else {
            s = "<" + t.type + ">";
          }
        }
        return this.escapeWSAndQuote(s);
      }
      escapeWSAndQuote(s) {
        s = s.replace(/\n/g, "\\n");
        s = s.replace(/\r/g, "\\r");
        s = s.replace(/\t/g, "\\t");
        return "'" + s + "'";
      }
      /**
       * Compute the error recovery set for the current rule. During
       * rule invocation, the parser pushes the set of tokens that can
       * follow that rule reference on the stack; this amounts to
       * computing FIRST of what follows the rule reference in the
       * enclosing rule. See LinearApproximator.FIRST().
       * This local follow set only includes tokens
       * from within the rule; i.e., the FIRST computation done by
       * ANTLR stops at the end of a rule.
       *
       * EXAMPLE
       *
       * When you find a "no viable alt exception", the input is not
       * consistent with any of the alternatives for rule r. The best
       * thing to do is to consume tokens until you see something that
       * can legally follow a call to r//or* any rule that called r.
       * You don't want the exact set of viable next tokens because the
       * input might just be missing a token--you might consume the
       * rest of the input looking for one of the missing tokens.
       *
       * Consider grammar:
       *
       * a : '[' b ']'
       * | '(' b ')'
       * ;
       * b : c '^' INT ;
       * c : ID
       * | INT
       * ;
       *
       * At each rule invocation, the set of tokens that could follow
       * that rule is pushed on a stack. Here are the various
       * context-sensitive follow sets:
       *
       * FOLLOW(b1_in_a) = FIRST(']') = ']'
       * FOLLOW(b2_in_a) = FIRST(')') = ')'
       * FOLLOW(c_in_b) = FIRST('^') = '^'
       *
       * Upon erroneous input "[]", the call chain is
       *
       * a -> b -> c
       *
       * and, hence, the follow context stack is:
       *
       * depth follow set start of rule execution
       * 0 <EOF> a (from main())
       * 1 ']' b
       * 2 '^' c
       *
       * Notice that ')' is not included, because b would have to have
       * been called from a different context in rule a for ')' to be
       * included.
       *
       * For error recovery, we cannot consider FOLLOW(c)
       * (context-sensitive or otherwise). We need the combined set of
       * all context-sensitive FOLLOW sets--the set of all tokens that
       * could follow any reference in the call chain. We need to
       * resync to one of those tokens. Note that FOLLOW(c)='^' and if
       * we resync'd to that token, we'd consume until EOF. We need to
       * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
       * In this case, for input "[]", LA(1) is ']' and in the set, so we would
       * not consume anything. After printing an error, rule c would
       * return normally. Rule b would not find the required '^' though.
       * At this point, it gets a mismatched token error and throws an
       * exception (since LA(1) is not in the viable following token
       * set). The rule exception handler tries to recover, but finds
       * the same recovery set and doesn't consume anything. Rule b
       * exits normally returning to rule a. Now it finds the ']' (and
       * with the successful match exits errorRecovery mode).
       *
       * So, you can see that the parser walks up the call chain looking
       * for the token that was a member of the recovery set.
       *
       * Errors are not generated in errorRecovery mode.
       *
       * ANTLR's error recovery mechanism is based upon original ideas:
       *
       * "Algorithms + Data Structures = Programs" by Niklaus Wirth
       *
       * and
       *
       * "A note on error recovery in recursive descent parsers":
       * http://portal.acm.org/citation.cfm?id=947902.947905
       *
       * Later, Josef Grosch had some good ideas:
       *
       * "Efficient and Comfortable Error Recovery in Recursive Descent
       * Parsers":
       * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
       *
       * Like Grosch I implement context-sensitive FOLLOW sets that are combined
       * at run-time upon error to avoid overhead during parsing.
       */
      getErrorRecoverySet(recognizer) {
        const atn = recognizer.atn;
        let ctx = recognizer.context;
        const recoverSet = new IntervalSet();
        while (ctx !== null && ctx.invokingState >= 0) {
          const invokingState = atn.states[ctx.invokingState];
          const rt = invokingState.transitions[0];
          const follow = atn.nextTokens(rt.followState);
          recoverSet.addSet(follow);
          ctx = ctx.parent;
        }
        recoverSet.removeOne(Token.EPSILON);
        return recoverSet;
      }
      /** Consume tokens until one matches the given token set. */
      consumeUntil(recognizer, set) {
        let ttype = recognizer.tokenStream?.LA(1) ?? -1;
        while (ttype !== Token.EOF && !set.contains(ttype)) {
          recognizer.consume();
          ttype = recognizer.tokenStream?.LA(1) ?? -1;
        }
      }
    };
    var BailErrorStrategy = class extends DefaultErrorStrategy {
      static {
        __name(this, "BailErrorStrategy");
      }
      /**
       * Instead of recovering from exception `e`, re-throw it wrapped
       * in a {@link ParseCancellationException} so it is not caught by the
       * rule function catches. Use {@link Exception//getCause()} to get the
       * original {@link RecognitionException}.
       */
      recover(recognizer, e) {
        throw new ParseCancellationException(e);
      }
      /**
       * Make sure we don't attempt to recover inline; if the parser
       * successfully recovers, it won't throw an exception.
       */
      recoverInline(recognizer) {
        const exception = new InputMismatchException(recognizer);
        throw new ParseCancellationException(exception);
      }
      // Make sure we don't attempt to recover from problems in subrules.
      sync(_recognizer) {
      }
    };
    var ListTokenSource = class {
      static {
        __name(this, "ListTokenSource");
      }
      /**
       * The name of the input source. If this value is `null`, a call to
       * {@link #getSourceName} should return the source name used to create the
       * the next token in {@link #tokens} (or the previous token if the end of
       * the input has been reached).
       */
      sourceName;
      tokenFactory = CommonTokenFactory.DEFAULT;
      /**
       * The wrapped collection of {@link Token} objects to return.
       */
      tokens = [];
      /**
       * The index into {@link tokens} of token to return by the next call to
       * {@link #nextToken}. The end of the input is indicated by this value
       * being greater than or equal to the number of items in {@link #tokens}.
       */
      i = 0;
      /**
       * This field caches the EOF token for the token source.
       */
      eofToken = null;
      constructor(tokens, sourceName) {
        this.tokens = tokens;
        this.sourceName = sourceName ?? "";
      }
      get column() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].column;
        }
        if (this.eofToken !== null) {
          return this.eofToken.column;
        }
        if (this.tokens.length > 0) {
          const lastToken = this.tokens[this.tokens.length - 1];
          const tokenText = lastToken.text;
          if (tokenText) {
            const lastNewLine = tokenText.lastIndexOf("\n");
            if (lastNewLine >= 0) {
              return tokenText.length - lastNewLine - 1;
            }
          }
          return lastToken.column + lastToken.stop - lastToken.start + 1;
        }
        return 0;
      }
      nextToken() {
        if (this.i >= this.tokens.length) {
          if (this.eofToken === null) {
            let start = -1;
            if (this.tokens.length > 0) {
              const previousStop = this.tokens[this.tokens.length - 1].stop;
              if (previousStop !== -1) {
                start = previousStop + 1;
              }
            }
            const stop = Math.max(-1, start - 1);
            this.eofToken = this.tokenFactory.create(
              [this, this.inputStream],
              Token.EOF,
              "EOF",
              Token.DEFAULT_CHANNEL,
              start,
              stop,
              this.line,
              this.column
            );
          }
          return this.eofToken;
        }
        const t = this.tokens[this.i];
        if (this.i === this.tokens.length - 1 && t.type === Token.EOF) {
          this.eofToken = t;
        }
        this.i++;
        return t;
      }
      get line() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].line;
        }
        if (this.eofToken !== null) {
          return this.eofToken.line;
        }
        if (this.tokens.length > 0) {
          const lastToken = this.tokens[this.tokens.length - 1];
          let line = lastToken.line;
          const tokenText = lastToken.text;
          if (tokenText) {
            for (const char of tokenText) {
              if (char === "\n") {
                line++;
              }
            }
          }
          return line;
        }
        return 1;
      }
      get inputStream() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].inputStream;
        }
        if (this.eofToken !== null) {
          return this.eofToken.inputStream;
        }
        if (this.tokens.length > 0) {
          return this.tokens[this.tokens.length - 1].inputStream;
        }
        return null;
      }
      getSourceName() {
        if (this.sourceName !== null) {
          return this.sourceName;
        }
        const inputStream = this.inputStream;
        if (inputStream !== null) {
          return inputStream.getSourceName();
        }
        return "List";
      }
    };
    var InterpreterRuleContext = class extends ParserRuleContext {
      static {
        __name(this, "InterpreterRuleContext");
      }
      /** This is the backing field for {@link #getRuleIndex}. */
      #ruleIndex;
      constructor(ruleIndex, parent, invokingStateNumber) {
        super(parent, invokingStateNumber);
        this.#ruleIndex = ruleIndex;
      }
      get ruleIndex() {
        return this.#ruleIndex;
      }
    };
    var TraceListener = class {
      static {
        __name(this, "TraceListener");
      }
      parser;
      constructor(parser) {
        this.parser = parser;
      }
      enterEveryRule(ctx) {
        console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser.inputStream?.LT(1)?.text);
      }
      visitTerminal(node) {
        console.log("consume " + node.getSymbol() + " rule " + this.parser.ruleNames[this.parser.context.ruleIndex]);
      }
      exitEveryRule(ctx) {
        console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser.inputStream?.LT(1)?.text);
      }
      visitErrorNode(_node) {
      }
    };
    var Parser = class extends Recognizer {
      static {
        __name(this, "Parser");
      }
      /** For testing only. */
      printer = null;
      /**
       * Specifies whether or not the parser should construct a parse tree during
       * the parsing process. The default value is `true`.
       *
       * @see #getBuildParseTree
       * @see #setBuildParseTree
       */
      buildParseTrees = true;
      /**
       * The error handling strategy for the parser. The default value is a new
       * instance of {@link DefaultErrorStrategy}.
       *
       * @see #getErrorHandler
       * @see #setErrorHandler
       */
      errorHandler = new DefaultErrorStrategy();
      /**
       * The {@link ParserRuleContext} object for the currently executing rule.
       * This is always non-null during the parsing process.
       */
      // TODO: make private
      context = null;
      precedenceStack = [];
      /**
       * The list of {@link ParseTreeListener} listeners registered to receive
       * events during the parse.
       *
       * @see #addParseListener
       */
      parseListeners = null;
      /**
       * The number of syntax errors reported during parsing. This value is
       * incremented each time {@link #notifyErrorListeners} is called.
       */
      syntaxErrors = 0;
      /** Indicates parser has matched EOF token. See {@link #exitRule()}. */
      matchedEOF = false;
      /**
       * When {@link #setTrace}`(true)` is called, a reference to the
       * {@link TraceListener} is stored here so it can be easily removed in a
       * later call to {@link #setTrace}`(false)`. The listener itself is
       * implemented as a parser listener so this field is not directly used by
       * other parser methods.
       */
      tracer = null;
      /**
       * This field holds the deserialized {@link ATN} with bypass alternatives, created
       * lazily upon first demand. In 4.10 I changed from map<serializedATNString, ATN>
       * since we only need one per parser object and also it complicates other targets
       * that don't use ATN strings.
       *
       * @see ATNDeserializationOptions#isGenerateRuleBypassTransitions()
       */
      bypassAltsAtnCache = null;
      #inputStream;
      /**
       * This is all the parsing support code essentially. Most of it is error recovery stuff.
       */
      constructor(input) {
        super();
        this.precedenceStack.push(0);
        this.syntaxErrors = 0;
        this.#inputStream = input;
      }
      /** reset the parser's state */
      reset(rewindInputStream = true) {
        if (rewindInputStream) {
          this.inputStream.seek(0);
        }
        this.errorHandler.reset(this);
        this.context = null;
        this.syntaxErrors = 0;
        this.matchedEOF = false;
        this.setTrace(false);
        this.precedenceStack = [];
        this.precedenceStack.push(0);
        if (this.interpreter) {
          this.interpreter.reset();
        }
      }
      /**
       * Match current input symbol against `ttype`. If the symbol type
       * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link consume} are
       * called to complete the match process.
       *
       * If the symbol type does not match,
       * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
       * strategy to attempt recovery. If {@link buildParseTree} is
       * `true` and the token index of the symbol returned by
       * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
       * the parse tree by calling {@link ParserRuleContext//addErrorNode}.
       *
       * @param ttype the token type to match
       * @returns the matched symbol
       * @throws RecognitionException if the current input symbol did not match
       * `ttype` and the error strategy could not recover from the
       * mismatched symbol
       */
      match(ttype) {
        let t = this.getCurrentToken();
        if (t.type === ttype) {
          if (ttype === Token.EOF) {
            this.matchedEOF = true;
          }
          this.errorHandler.reportMatch(this);
          this.consume();
        } else {
          t = this.errorHandler.recoverInline(this);
          if (this.buildParseTrees && t.tokenIndex === -1) {
            this.context.addErrorNode(this.createErrorNode(this.context, t));
          }
        }
        return t;
      }
      /**
       * Match current input symbol as a wildcard. If the symbol type matches
       * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
       * and {@link consume} are called to complete the match process.
       *
       * If the symbol type does not match,
       * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
       * strategy to attempt recovery. If {@link buildParseTree} is
       * `true` and the token index of the symbol returned by
       * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
       * the parse tree by calling {@link ParserRuleContext//addErrorNode}.
       *
       * @returns the matched symbol
       * @throws RecognitionException if the current input symbol did not match
       * a wildcard and the error strategy could not recover from the mismatched
       * symbol
       */
      matchWildcard() {
        let t = this.getCurrentToken();
        if (t.type > 0) {
          this.errorHandler.reportMatch(this);
          this.consume();
        } else {
          t = this.errorHandler.recoverInline(this);
          if (this.buildParseTrees && t.tokenIndex === -1) {
            this.context.addErrorNode(this.createErrorNode(this.context, t));
          }
        }
        return t;
      }
      getParseListeners() {
        return this.parseListeners ?? [];
      }
      /**
       * Registers `listener` to receive events during the parsing process.
       *
       * To support output-preserving grammar transformations (including but not
       * limited to left-recursion removal, automated left-factoring, and
       * optimized code generation), calls to listener methods during the parse
       * may differ substantially from calls made by
       * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
       * particular, rule entry and exit events may occur in a different order
       * during the parse than after the parser. In addition, calls to certain
       * rule entry methods may be omitted.
       *
       * With the following specific exceptions, calls to listener events are
       * deterministic*, i.e. for identical input the calls to listener
       * methods will be the same.
       *
       * - Alterations to the grammar used to generate code may change the
       * behavior of the listener calls.
       * - Alterations to the command line options passed to ANTLR 4 when
       * generating the parser may change the behavior of the listener calls.
       * - Changing the version of the ANTLR Tool used to generate the parser
       * may change the behavior of the listener calls.
       *
       * @param listener the listener to add
       *
       * @throws NullPointerException if {@code} listener is `null`
       */
      addParseListener(listener) {
        if (listener === null) {
          throw new Error("listener");
        }
        if (this.parseListeners === null) {
          this.parseListeners = [];
        }
        this.parseListeners.push(listener);
      }
      /**
       * Remove `listener` from the list of parse listeners.
       *
       * If `listener` is `null` or has not been added as a parse
       * listener, this method does nothing.
       *
       * @param listener the listener to remove
       */
      removeParseListener(listener) {
        if (this.parseListeners !== null && listener !== null) {
          const idx = this.parseListeners.indexOf(listener);
          if (idx >= 0) {
            this.parseListeners.splice(idx, 1);
          }
          if (this.parseListeners.length === 0) {
            this.parseListeners = null;
          }
        }
      }
      // Remove all parse listeners.
      removeParseListeners() {
        this.parseListeners = null;
      }
      // Notify any parse listeners of an enter rule event.
      triggerEnterRuleEvent() {
        if (this.parseListeners !== null) {
          const ctx = this.context;
          this.parseListeners.forEach((listener) => {
            listener.enterEveryRule(ctx);
            ctx.enterRule(listener);
          });
        }
      }
      /**
       * Notify any parse listeners of an exit rule event.
       *
       * @see //addParseListener
       */
      triggerExitRuleEvent() {
        if (this.parseListeners !== null) {
          const ctx = this.context;
          this.parseListeners.slice(0).reverse().forEach((listener) => {
            ctx.exitRule(listener);
            listener.exitEveryRule(ctx);
          });
        }
      }
      getTokenFactory() {
        return this.inputStream.tokenSource.tokenFactory;
      }
      // Tell our token source and error strategy about a new way to create tokens.
      setTokenFactory(factory) {
        this.inputStream.tokenSource.tokenFactory = factory;
      }
      /**
       * The preferred method of getting a tree pattern. For example, here's a
       * sample use:
       *
       * ```
       * const t = parser.expr();
       * const p = parser.compileParseTreePattern("<ID>+0", MyParser.RULE_expr);
       * const m = p.match(t);
       * const id = m.get("ID");
       * ```
       */
      compileParseTreePattern(pattern, patternRuleIndex, lexer) {
        if (!lexer) {
          if (this.tokenStream !== null) {
            const tokenSource = this.tokenStream.tokenSource;
            if (tokenSource instanceof Lexer) {
              lexer = tokenSource;
            }
          }
        }
        if (!lexer) {
          throw new Error("Parser can't discover a lexer to use");
        }
        const m2 = new ParseTreePatternMatcher(lexer, this);
        return m2.compile(pattern, patternRuleIndex);
      }
      /**
       * The ATN with bypass alternatives is expensive to create so we create it
       * lazily.
       *
       * @throws UnsupportedOperationException if the current parser does not
       * implement the {@link getSerializedATN()} method.
       */
      getATNWithBypassAlts() {
        const serializedAtn = this.serializedATN;
        if (serializedAtn === null) {
          throw new Error("The current parser does not support an ATN with bypass alternatives.");
        }
        if (this.bypassAltsAtnCache !== null) {
          return this.bypassAltsAtnCache;
        }
        const deserializationOptions = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: true };
        this.bypassAltsAtnCache = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);
        return this.bypassAltsAtnCache;
      }
      /**
       * Gets the number of syntax errors reported during parsing. This value is
       * incremented each time {@link notifyErrorListeners} is called.
       */
      get numberOfSyntaxErrors() {
        return this.syntaxErrors;
      }
      get inputStream() {
        return this.#inputStream;
      }
      set inputStream(input) {
        this.tokenStream = input;
      }
      get tokenStream() {
        return this.#inputStream;
      }
      /** Set the token stream and reset the parser. */
      set tokenStream(input) {
        this.reset(false);
        this.#inputStream = input;
      }
      /**
       * Match needs to return the current input symbol, which gets put
       * into the label for the associated token ref; e.g., x=ID.
       */
      getCurrentToken() {
        return this.inputStream.LT(1);
      }
      notifyErrorListeners(msg, offendingToken, err) {
        offendingToken = offendingToken ?? null;
        err = err ?? null;
        if (offendingToken === null) {
          offendingToken = this.getCurrentToken();
        }
        this.syntaxErrors += 1;
        const line = offendingToken.line;
        const column = offendingToken.column;
        this.errorListenerDispatch.syntaxError(this, offendingToken, line, column, msg, err);
      }
      /**
       * Consume and return the {@link getCurrentToken current symbol}.
       *
       * E.g., given the following input with `A` being the current
       * lookahead symbol, this function moves the cursor to `B` and returns
       * `A`.
       *
       * ```
       * A B
       * ^
       * ```
       *
       * If the parser is not in error recovery mode, the consumed symbol is added
       * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
       * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
       * If the parser *is* in error recovery mode, the consumed symbol is
       * added to the parse tree using
       * {@link ParserRuleContext//addErrorNode(Token)}, and
       * {@link ParseTreeListener//visitErrorNode} is called on any parse
       * listeners.
       */
      consume() {
        const o = this.getCurrentToken();
        if (o.type !== Token.EOF) {
          this.tokenStream.consume();
        }
        const hasListener = this.parseListeners !== null && this.parseListeners.length > 0;
        if (this.buildParseTrees || hasListener) {
          let node;
          if (this.errorHandler.inErrorRecoveryMode(this)) {
            node = this.context.addErrorNode(this.createErrorNode(this.context, o));
          } else {
            node = this.context.addTokenNode(o);
          }
          if (hasListener) {
            this.parseListeners.forEach((listener) => {
              if (node instanceof ErrorNode) {
                listener.visitErrorNode(node);
              } else {
                listener.visitTerminal(node);
              }
            });
          }
        }
        return o;
      }
      addContextToParseTree() {
        if (this.context?.parent) {
          this.context.parent.addChild(this.context);
        }
      }
      /**
       * Always called by generated parsers upon entry to a rule. Access field
       * {@link context} get the current context.
       */
      enterRule(localctx, state, _ruleIndex) {
        this.state = state;
        this.context = localctx;
        this.context.start = this.inputStream.LT(1);
        if (this.buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      exitRule() {
        if (this.matchedEOF) {
          this.context.stop = this.inputStream.LT(1);
        } else {
          this.context.stop = this.inputStream.LT(-1);
        }
        this.triggerExitRuleEvent();
        this.state = this.context.invokingState;
        this.context = this.context.parent;
      }
      enterOuterAlt(localctx, altNum) {
        localctx.setAltNumber(altNum);
        if (this.buildParseTrees && this.context !== localctx) {
          if (this.context?.parent) {
            this.context.parent.removeLastChild();
            this.context.parent.addChild(localctx);
          }
        }
        this.context = localctx;
      }
      /**
       * Get the precedence level for the top-most precedence rule.
       *
       * @returns The precedence level for the top-most precedence rule, or -1 if
       * the parser context is not nested within a precedence rule.
       */
      getPrecedence() {
        if (this.precedenceStack.length === 0) {
          return -1;
        }
        return this.precedenceStack[this.precedenceStack.length - 1];
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this.precedenceStack.push(precedence);
        this.context = localctx;
        this.context.start = this.inputStream.LT(1);
        this.triggerEnterRuleEvent();
      }
      /** Like {@link enterRule} but for recursive rules. */
      pushNewRecursionContext(localctx, state, _ruleIndex) {
        const previous = this.context;
        previous.parent = localctx;
        previous.invokingState = state;
        previous.stop = this.inputStream.LT(-1);
        this.context = localctx;
        this.context.start = previous.start;
        if (this.buildParseTrees) {
          this.context.addChild(previous);
        }
        this.triggerEnterRuleEvent();
      }
      unrollRecursionContexts(parent) {
        this.precedenceStack.pop();
        this.context.stop = this.inputStream.LT(-1);
        const retCtx = this.context;
        const parseListeners = this.getParseListeners();
        if (parseListeners !== null && parseListeners.length > 0) {
          while (this.context !== parent) {
            this.triggerExitRuleEvent();
            this.context = this.context.parent;
          }
        } else {
          this.context = parent;
        }
        retCtx.parent = parent;
        if (this.buildParseTrees && parent !== null) {
          parent.addChild(retCtx);
        }
      }
      getInvokingContext(ruleIndex) {
        let ctx = this.context;
        while (ctx !== null) {
          if (ctx.ruleIndex === ruleIndex) {
            return ctx;
          }
          ctx = ctx.parent;
        }
        return null;
      }
      precpred(_localctx, precedence) {
        return precedence >= this.precedenceStack[this.precedenceStack.length - 1];
      }
      /**
       * Checks whether or not `symbol` can follow the current state in the
       * ATN. The behavior of this method is equivalent to the following, but is
       * implemented such that the complete context-sensitive follow set does not
       * need to be explicitly constructed.
       *
       * ```
       * return getExpectedTokens().contains(symbol);
       * ```
       *
       * @param symbol the symbol type to check
       * @returns `true` if `symbol` can follow the current state in
       * the ATN, otherwise `false`.
       */
      isExpectedToken(symbol) {
        const atn = this.interpreter.atn;
        let ctx = this.context;
        const s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
          return true;
        }
        if (!following.contains(Token.EPSILON)) {
          return false;
        }
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
          const invokingState = atn.states[ctx.invokingState];
          const rt = invokingState.transitions[0];
          following = atn.nextTokens(rt.followState);
          if (following.contains(symbol)) {
            return true;
          }
          ctx = ctx.parent;
        }
        if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
          return true;
        } else {
          return false;
        }
      }
      /**
       * Computes the set of input symbols which could follow the current parser
       * state and context, as given by {@link getState} and {@link getContext},
       * respectively.
       *
       * {@link ATN.getExpectedTokens ATN.getExpectedTokens(int, RuleContext)}
       */
      getExpectedTokens() {
        return this.interpreter.atn.getExpectedTokens(this.state, this.context);
      }
      getExpectedTokensWithinCurrentRule() {
        const atn = this.interpreter.atn;
        const s = atn.states[this.state];
        return atn.nextTokens(s);
      }
      /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
      getRuleIndex(ruleName) {
        return this.getRuleIndexMap().get(ruleName) ?? -1;
      }
      /**
       * @returns an array of string of the rule names in your parser instance
       * leading up to a call to the current rule. You could override if
       * you want more details such as the file/line info of where
       * in the ATN a rule is invoked.
       *
       * this is very useful for error messages.
       */
      getRuleInvocationStack(p) {
        p = p ?? null;
        if (p === null) {
          p = this.context;
        }
        const stack = [];
        while (p !== null) {
          const ruleIndex = p.ruleIndex;
          if (ruleIndex < 0) {
            stack.push("n/a");
          } else {
            stack.push(this.ruleNames[ruleIndex]);
          }
          p = p.parent;
        }
        return stack;
      }
      /**
       * For debugging and other purposes.
       *
       * TODO: this differs from the Java version. Change it.
       */
      getDFAStrings() {
        return this.interpreter.decisionToDFA.toString();
      }
      /** For debugging and other purposes. */
      dumpDFA() {
        let seenOne = false;
        for (const dfa of this.interpreter.decisionToDFA) {
          if (dfa.length > 0) {
            if (seenOne) {
              console.log();
            }
            if (this.printer) {
              this.printer.println("Decision " + dfa.decision + ":");
              this.printer.print(dfa.toString(this.vocabulary));
            }
            seenOne = true;
          }
        }
      }
      getSourceName() {
        return this.inputStream.getSourceName();
      }
      getParseInfo() {
        const interp = this.interpreter;
        if (interp instanceof ProfilingATNSimulator) {
          return new ParseInfo(interp);
        }
        return void 0;
      }
      setProfile(profile) {
        const interp = this.interpreter;
        const saveMode = interp.predictionMode;
        if (profile) {
          if (!(interp instanceof ProfilingATNSimulator)) {
            this.interpreter = new ProfilingATNSimulator(this);
          }
        } else if (interp instanceof ProfilingATNSimulator) {
          const sharedContextCache = interp.sharedContextCache;
          if (sharedContextCache) {
            const sim = new ParserATNSimulator(this, this.atn, interp.decisionToDFA, sharedContextCache);
            this.interpreter = sim;
          }
        }
        this.interpreter.predictionMode = saveMode;
      }
      /**
       * During a parse is sometimes useful to listen in on the rule entry and exit
       * events as well as token matches. this is for quick and dirty debugging.
       */
      setTrace(trace) {
        if (!trace) {
          this.removeParseListener(this.tracer);
          this.tracer = null;
        } else {
          if (this.tracer !== null) {
            this.removeParseListener(this.tracer);
          }
          this.tracer = new TraceListener(this);
          this.addParseListener(this.tracer);
        }
      }
      createTerminalNode(parent, t) {
        return new TerminalNode(t);
      }
      createErrorNode(parent, t) {
        return new ErrorNode(t);
      }
    };
    var ParserInterpreter = class extends Parser {
      static {
        __name(this, "ParserInterpreter");
      }
      rootContext;
      overrideDecisionRoot = null;
      parentContextStack = [];
      overrideDecisionAlt = -1;
      overrideDecisionReached = false;
      decisionToDFA;
      sharedContextCache = new PredictionContextCache();
      pushRecursionContextStates;
      #overrideDecision = -1;
      #overrideDecisionInputIndex = -1;
      #grammarFileName;
      #atn;
      #ruleNames;
      #vocabulary;
      constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
        super(input);
        this.#grammarFileName = grammarFileName;
        this.#atn = atn;
        this.#ruleNames = ruleNames.slice(0);
        this.#vocabulary = vocabulary;
        this.pushRecursionContextStates = new BitSet();
        for (const state of atn.states) {
          if (state instanceof StarLoopEntryState && state.precedenceRuleDecision) {
            this.pushRecursionContextStates.set(state.stateNumber);
          }
        }
        this.decisionToDFA = atn.decisionToState.map((ds, i) => {
          return new DFA(ds, i);
        });
        this.interpreter = new ParserATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);
      }
      reset() {
        super.reset();
        this.overrideDecisionReached = false;
        this.overrideDecisionRoot = null;
      }
      get atn() {
        return this.#atn;
      }
      get vocabulary() {
        return this.#vocabulary;
      }
      get ruleNames() {
        return this.#ruleNames;
      }
      get grammarFileName() {
        return this.#grammarFileName;
      }
      get atnState() {
        return this.#atn.states[this.state];
      }
      parse(startRuleIndex) {
        const startRuleStartState = this.#atn.ruleToStartState[startRuleIndex];
        this.rootContext = this.createInterpreterRuleContext(null, ATNState.INVALID_STATE_NUMBER, startRuleIndex);
        if (startRuleStartState.isLeftRecursiveRule) {
          this.enterRecursionRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
        } else {
          this.enterRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex);
        }
        while (true) {
          const p = this.atnState;
          switch (p.constructor.stateType) {
            case ATNState.RULE_STOP: {
              if (this.context?.isEmpty()) {
                if (startRuleStartState.isLeftRecursiveRule) {
                  const result = this.context;
                  const parentContext = this.parentContextStack.pop();
                  this.unrollRecursionContexts(parentContext[0]);
                  return result;
                } else {
                  this.exitRule();
                  return this.rootContext;
                }
              }
              this.visitRuleStopState(p);
              break;
            }
            default: {
              try {
                this.visitState(p);
              } catch (e) {
                if (e instanceof RecognitionException) {
                  this.state = this.#atn.ruleToStopState[p.ruleIndex].stateNumber;
                  this.errorHandler.reportError(this, e);
                  this.recover(e);
                } else {
                  throw e;
                }
              }
              break;
            }
          }
        }
      }
      addDecisionOverride(decision, tokenIndex, forcedAlt) {
        this.#overrideDecision = decision;
        this.#overrideDecisionInputIndex = tokenIndex;
        this.overrideDecisionAlt = forcedAlt;
      }
      get overrideDecision() {
        return this.#overrideDecision;
      }
      get overrideDecisionInputIndex() {
        return this.#overrideDecisionInputIndex;
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.parentContextStack.push([this.context, localctx.invokingState]);
        super.enterRecursionRule(localctx, state, ruleIndex, precedence);
      }
      get serializedATN() {
        throw new Error("The ParserInterpreter does not support the serializedATN property.");
      }
      visitState(p) {
        let predictedAlt = 1;
        if (p instanceof DecisionState) {
          predictedAlt = this.visitDecisionState(p);
        }
        const transition = p.transitions[predictedAlt - 1];
        switch (transition.transitionType) {
          case Transition.EPSILON:
            if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target.constructor.stateType === ATNState.LOOP_END)) {
              const parentContext = this.parentContextStack[this.parentContextStack.length - 1];
              const localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this.context.ruleIndex);
              this.pushNewRecursionContext(
                localctx,
                this.#atn.ruleToStartState[p.ruleIndex].stateNumber,
                this.context.ruleIndex
              );
            }
            break;
          case Transition.ATOM:
            this.match(transition.label.minElement);
            break;
          case Transition.RANGE:
          case Transition.SET:
          case Transition.NOT_SET:
            if (!transition.matches(this.inputStream.LA(1), Token.MIN_USER_TOKEN_TYPE, 65535)) {
              this.recoverInline();
            }
            this.matchWildcard();
            break;
          case Transition.WILDCARD:
            this.matchWildcard();
            break;
          case Transition.RULE:
            const ruleStartState = transition.target;
            const ruleIndex = ruleStartState.ruleIndex;
            const newContext = this.createInterpreterRuleContext(this.context, p.stateNumber, ruleIndex);
            if (ruleStartState.isLeftRecursiveRule) {
              this.enterRecursionRule(
                newContext,
                ruleStartState.stateNumber,
                ruleIndex,
                transition.precedence
              );
            } else {
              this.enterRule(newContext, transition.target.stateNumber, ruleIndex);
            }
            break;
          case Transition.PREDICATE:
            const predicateTransition = transition;
            if (!this.sempred(this.context, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
              throw new FailedPredicateException(this);
            }
            break;
          case Transition.ACTION:
            const actionTransition = transition;
            this.action(this.context, actionTransition.ruleIndex, actionTransition.actionIndex);
            break;
          case Transition.PRECEDENCE:
            if (!this.precpred(this.context, transition.precedence)) {
              const precedence = transition.precedence;
              throw new FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
            }
            break;
          default:
            throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
        }
        this.state = transition.target.stateNumber;
      }
      visitDecisionState(p) {
        let predictedAlt = 1;
        if (p.transitions.length > 1) {
          this.errorHandler.sync(this);
          const decision = p.decision;
          if (decision === this.#overrideDecision && this.inputStream.index === this.#overrideDecisionInputIndex && !this.overrideDecisionReached) {
            predictedAlt = this.overrideDecisionAlt;
            this.overrideDecisionReached = true;
          } else {
            predictedAlt = this.interpreter.adaptivePredict(this.inputStream, decision, this.context);
          }
        }
        return predictedAlt;
      }
      createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
        return new InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
      }
      visitRuleStopState(p) {
        const ruleStartState = this.#atn.ruleToStartState[p.ruleIndex];
        if (ruleStartState.isLeftRecursiveRule) {
          const [parentContext, state] = this.parentContextStack.pop();
          this.unrollRecursionContexts(parentContext);
          this.state = state;
        } else {
          this.exitRule();
        }
        const ruleTransition = this.#atn.states[this.state].transitions[0];
        this.state = ruleTransition.followState.stateNumber;
      }
      recover(e) {
        const i = this.inputStream.index;
        this.errorHandler.recover(this, e);
        if (this.inputStream.index === i) {
          const tok = e.offendingToken;
          if (!tok) {
            throw new Error("Expected exception to have an offending token");
          }
          const source = tok.tokenSource;
          const stream = source?.inputStream ?? null;
          const sourcePair = [source, stream];
          if (e instanceof InputMismatchException) {
            const expectedTokens = e.getExpectedTokens();
            if (!expectedTokens) {
              throw new Error("Expected the exception to provide expected tokens");
            }
            let expectedTokenType = Token.INVALID_TYPE;
            if (expectedTokens.length !== 0) {
              expectedTokenType = expectedTokens.minElement;
            }
            const errToken = this.getTokenFactory().create(
              sourcePair,
              expectedTokenType,
              tok.text,
              Token.DEFAULT_CHANNEL,
              -1,
              -1,
              tok.line,
              tok.column
            );
            this.context.addErrorNode(this.createErrorNode(this.context, errToken));
          } else {
            const errToken = this.getTokenFactory().create(
              sourcePair,
              Token.INVALID_TYPE,
              tok.text,
              Token.DEFAULT_CHANNEL,
              -1,
              -1,
              tok.line,
              tok.column
            );
            this.context.addErrorNode(this.createErrorNode(this.context, errToken));
          }
        }
      }
      recoverInline() {
        return this.errorHandler.recoverInline(this);
      }
    };
    var MultiMap = class extends Map {
      static {
        __name(this, "MultiMap");
      }
      map(key, value) {
        let elementsForKey = this.get(key);
        if (!elementsForKey) {
          elementsForKey = new Array();
          this.set(key, elementsForKey);
        }
        elementsForKey.push(value);
      }
      getPairs() {
        const pairs = new Array();
        for (const key of this.keys()) {
          const keys = this.get(key) ?? [];
          for (const value of keys) {
            pairs.push([key, value]);
          }
        }
        return pairs;
      }
      toString() {
        const entries = [];
        this.forEach((value, key) => {
          entries.push(`${key}=[${value.join(", ")}]`);
        });
        return `{${entries.join(", ")}}`;
      }
    };
    var CannotInvokeStartRuleError = class extends Error {
      static {
        __name(this, "CannotInvokeStartRuleError");
      }
      constructor(e) {
        super();
        this.cause = e;
      }
    };
    var RuleTagToken = class {
      static {
        __name(this, "RuleTagToken");
      }
      /** The name of the label associated with the rule tag. */
      label;
      /** The name of the parser rule associated with this rule tag. */
      ruleName;
      /**
       * The token type for the current token. This is the token type assigned to
       * the bypass alternative for the rule during ATN deserialization.
       */
      bypassTokenType;
      constructor(ruleName, bypassTokenType, label) {
        this.ruleName = ruleName;
        this.bypassTokenType = bypassTokenType;
        this.label = label;
      }
      /**
       * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
       */
      get channel() {
        return Token.DEFAULT_CHANNEL;
      }
      /**
       * This method returns the rule tag formatted with `<` and `>`
       * delimiters.
       */
      get text() {
        if (this.label !== void 0) {
          return "<" + this.label + ":" + this.ruleName + ">";
        }
        return "<" + this.ruleName + ">";
      }
      /**
       * Rule tag tokens have types assigned according to the rule bypass
       * transitions created during ATN deserialization.
       */
      get type() {
        return this.bypassTokenType;
      }
      /**
       * The implementation for {@link RuleTagToken} always returns 0.
       */
      get line() {
        return 0;
      }
      /**
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get column() {
        return -1;
      }
      /**
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get tokenIndex() {
        return -1;
      }
      /**
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get start() {
        return -1;
      }
      /**
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get stop() {
        return -1;
      }
      /**
       * The implementation for {@link RuleTagToken} always returns `null`.
       */
      get tokenSource() {
        return null;
      }
      /**
       * The implementation for {@link RuleTagToken} always returns `null`.
       */
      get inputStream() {
        return null;
      }
      /**
       * The implementation for {@link RuleTagToken} returns a string of the form
       * `ruleName:bypassTokenType`.
       */
      toString() {
        return this.ruleName + ":" + this.bypassTokenType;
      }
    };
    var StartRuleDoesNotConsumeFullPatternError = class extends Error {
      static {
        __name(this, "StartRuleDoesNotConsumeFullPatternError");
      }
    };
    var TagChunk = class extends Chunk {
      static {
        __name(this, "TagChunk");
      }
      tag;
      label;
      constructor(...args) {
        let label;
        let tag;
        if (args.length === 1) {
          tag = args[0];
        } else {
          label = args[0];
          tag = args[1];
        }
        super();
        if (!tag) {
          throw new Error("tag cannot be null or empty");
        }
        this.label = label;
        this.tag = tag;
      }
      /**
       * @returns a text representation of the tag chunk. Labeled tags
       * are returned in the form `label:tag`, and unlabeled tags are
       * returned as just the tag name.
       */
      toString() {
        if (this.label !== void 0) {
          return this.label + ":" + this.tag;
        }
        return this.tag;
      }
    };
    var TextChunk = class extends Chunk {
      static {
        __name(this, "TextChunk");
      }
      text;
      /**
       * Constructs a new instance of {@link TextChunk} with the specified text.
       *
       * @param text The text of this chunk.
       */
      constructor(text) {
        super();
        this.text = text;
      }
      /**
       * @returns the result of {@link #getText()} in single quotes.
       */
      toString() {
        return "'" + this.text + "'";
      }
    };
    var TokenTagToken = class extends CommonToken {
      static {
        __name(this, "TokenTagToken");
      }
      tokenName;
      /**
       * The name of the label associated with the rule tag, or undefined if this is an unlabeled rule tag.
       */
      label;
      constructor(tokenName, type, label) {
        super({ type, source: CommonToken.EMPTY_SOURCE });
        this.tokenName = tokenName;
        this.label = label;
      }
      /**
       *
       * @returns the token tag formatted with `<` and `>` delimiters.
       */
      get text() {
        if (this.label !== void 0) {
          return "<" + this.label + ":" + this.tokenName + ">";
        }
        return "<" + this.tokenName + ">";
      }
      /**
       * @returns a string of the form `tokenName:type`.
       */
      toString() {
        return this.tokenName + ":" + this.type;
      }
    };
    var ParseTreePatternMatcher = class {
      static {
        __name(this, "ParseTreePatternMatcher");
      }
      start = "<";
      stop = ">";
      escape = "\\";
      // e.g., \< and \> must escape BOTH!
      /**
       * This is the backing field for {@link #getLexer()}.
       */
      lexer;
      /**
       * This is the backing field for {@link #getParser()}.
       */
      parser;
      /**
       * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
       * {@link Parser} object. The lexer input stream is altered for tokenizing
       * the tree patterns. The parser is used as a convenient mechanism to get
       * the grammar name, plus token, rule names.
       */
      constructor(lexer, parser) {
        this.lexer = lexer;
        this.parser = parser;
      }
      /**
       * Set the delimiters used for marking rule and token tags within concrete
       * syntax used by the tree pattern parser.
       *
       * @param start The start delimiter.
       * @param stop The stop delimiter.
       * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
       *
       * @throws Error if `start` is `null` or empty.
       * @throws Error if `stop` is `null` or empty.
       */
      setDelimiters(start, stop, escapeLeft) {
        if (start === null || start.length === 0) {
          throw new Error("start cannot be null or empty");
        }
        if (stop === null || stop.length === 0) {
          throw new Error("stop cannot be null or empty");
        }
        this.start = start;
        this.stop = stop;
        this.escape = escapeLeft;
      }
      matches(...args) {
        switch (args.length) {
          case 2: {
            const [tree, pattern] = args;
            const labels = new MultiMap();
            const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);
            return mismatchedNode === null;
          }
          case 3: {
            const [tree, pattern, patternRuleIndex] = args;
            const p = this.compile(pattern, patternRuleIndex);
            return this.matches(tree, p);
          }
          default: {
            throw new Error("Invalid number of arguments");
          }
        }
      }
      match(...args) {
        switch (args.length) {
          case 2: {
            const [tree, pattern] = args;
            const labels = new MultiMap();
            const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);
            return new ParseTreeMatch(tree, pattern, labels, mismatchedNode);
          }
          case 3: {
            const [tree, pattern, patternRuleIndex] = args;
            const p = this.compile(pattern, patternRuleIndex);
            return this.match(tree, p);
          }
          default: {
            throw new Error("Invalid number of arguments");
          }
        }
      }
      /**
       * For repeated use of a tree pattern, compile it to a
       * {@link ParseTreePattern} using this method.
       */
      compile(pattern, patternRuleIndex) {
        const tokenList = this.tokenize(pattern);
        const tokenSrc = new ListTokenSource(tokenList);
        const tokens = new CommonTokenStream(tokenSrc);
        const parserInterp = new ParserInterpreter(
          this.parser.grammarFileName,
          this.parser.vocabulary,
          this.parser.ruleNames,
          this.parser.getATNWithBypassAlts(),
          tokens
        );
        parserInterp.removeErrorListeners();
        let tree = null;
        try {
          parserInterp.errorHandler = new BailErrorStrategy();
          tree = parserInterp.parse(patternRuleIndex);
        } catch (error) {
          if (error instanceof ParseCancellationException) {
            throw error.cause;
          } else if (error instanceof RecognitionException) {
            throw error;
          } else if (error instanceof Error) {
            throw new CannotInvokeStartRuleError(error);
          } else {
            throw error;
          }
        }
        if (tokens.LA(1) !== Token.EOF) {
          throw new StartRuleDoesNotConsumeFullPatternError();
        }
        return new ParseTreePattern(this, pattern, patternRuleIndex, tree);
      }
      /**
       * Used to convert the tree pattern string into a series of tokens. The
       * input stream is reset.
       */
      getLexer() {
        return this.lexer;
      }
      /**
       * Used to collect to the grammar file name, token names, rule names for
       * used to parse the pattern into a parse tree.
       */
      getParser() {
        return this.parser;
      }
      // ---- SUPPORT CODE ----
      tokenize(pattern) {
        const chunks = this.split(pattern);
        const tokens = new Array();
        for (const chunk of chunks) {
          if (chunk instanceof TagChunk) {
            const tagChunk = chunk;
            const char = tagChunk.tag[0];
            if (char === char.toUpperCase()) {
              const ttype = this.parser.getTokenType(tagChunk.tag);
              if (ttype === Token.INVALID_TYPE) {
                throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
              }
              const t = new TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
              tokens.push(t);
            } else {
              if (char === char.toLowerCase()) {
                const ruleIndex = this.parser.getRuleIndex(tagChunk.tag);
                if (ruleIndex === -1) {
                  throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
                }
                const ruleImaginaryTokenType = this.parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
                tokens.push(new RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
              } else {
                throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
              }
            }
          } else {
            const textChunk = chunk;
            const input = CharStream.fromString(textChunk.text);
            this.lexer.inputStream = input;
            let t = this.lexer.nextToken();
            while (t.type !== Token.EOF) {
              tokens.push(t);
              t = this.lexer.nextToken();
            }
          }
        }
        return tokens;
      }
      /**
       * Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}.
       */
      split(pattern) {
        let p = 0;
        const n2 = pattern.length;
        const chunks = new Array();
        const starts = new Array();
        const stops = new Array();
        while (p < n2) {
          if (p === pattern.indexOf(this.escape + this.start, p)) {
            p += this.escape.length + this.start.length;
          } else {
            if (p === pattern.indexOf(this.escape + this.stop, p)) {
              p += this.escape.length + this.stop.length;
            } else {
              if (p === pattern.indexOf(this.start, p)) {
                starts.push(p);
                p += this.start.length;
              } else {
                if (p === pattern.indexOf(this.stop, p)) {
                  stops.push(p);
                  p += this.stop.length;
                } else {
                  p++;
                }
              }
            }
          }
        }
        if (starts.length > stops.length) {
          throw new Error("unterminated tag in pattern: " + pattern);
        }
        if (starts.length < stops.length) {
          throw new Error("missing start tag in pattern: " + pattern);
        }
        const tagCount = starts.length;
        for (let i = 0; i < tagCount; i++) {
          if (starts[i] >= stops[i]) {
            throw new Error("tag delimiters out of order in pattern: " + pattern);
          }
        }
        if (tagCount === 0) {
          const text = pattern.substring(0, n2);
          chunks.push(new TextChunk(text));
        }
        if (tagCount > 0 && starts[0] > 0) {
          const text = pattern.substring(0, starts[0]);
          chunks.push(new TextChunk(text));
        }
        for (let i = 0; i < tagCount; i++) {
          const tag = pattern.substring(starts[i] + this.start.length, stops[i]);
          let ruleOrToken = tag;
          let label;
          const colon = tag.indexOf(":");
          if (colon >= 0) {
            label = tag.substring(0, colon);
            ruleOrToken = tag.substring(colon + 1, tag.length);
          }
          chunks.push(new TagChunk(label, ruleOrToken));
          if (i + 1 < tagCount) {
            const text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
            chunks.push(new TextChunk(text));
          }
        }
        if (tagCount > 0) {
          const afterLastTag = stops[tagCount - 1] + this.stop.length;
          if (afterLastTag < n2) {
            const text = pattern.substring(afterLastTag, n2);
            chunks.push(new TextChunk(text));
          }
        }
        for (let i = 0; i < chunks.length; i++) {
          const c = chunks[i];
          if (c instanceof TextChunk) {
            const tc = c;
            const unescaped = tc.text.replaceAll(this.escape, "");
            if (unescaped.length < tc.text.length) {
              chunks[i] = new TextChunk(unescaped);
            }
          }
        }
        return chunks;
      }
      /**
       * Recursively walk `tree` against `patternTree`, filling
       * `match.`{@link ParseTreeMatch#labels labels}.
       *
       * @returns the first node encountered in `tree` which does not match
       * a corresponding node in `patternTree`, or `null` if the match
       * was successful. The specific node returned depends on the matching
       * algorithm used by the implementation, and may be overridden.
       */
      matchImpl(tree, patternTree, labels) {
        if (tree instanceof TerminalNode && patternTree instanceof TerminalNode) {
          const t1 = tree;
          const t2 = patternTree;
          let mismatchedNode;
          if (t1.getSymbol().type === t2.getSymbol().type) {
            if (t2.getSymbol() instanceof TokenTagToken) {
              const tokenTagToken = t2.getSymbol();
              labels.map(tokenTagToken.tokenName, tree);
              if (tokenTagToken.label !== void 0) {
                labels.map(tokenTagToken.label, tree);
              }
            } else {
              if (t1.getText() === t2.getText()) {
              } else {
                if (!mismatchedNode) {
                  mismatchedNode = t1;
                }
              }
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = t1;
            }
          }
          return mismatchedNode;
        }
        if (tree instanceof ParserRuleContext && patternTree instanceof ParserRuleContext) {
          let mismatchedNode;
          const ruleTagToken = this.getRuleTagToken(patternTree);
          if (ruleTagToken) {
            if (tree.ruleIndex === patternTree.ruleIndex) {
              labels.map(ruleTagToken.ruleName, tree);
              if (ruleTagToken.label) {
                labels.map(ruleTagToken.label, tree);
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree.getChildCount() !== patternTree.getChildCount()) {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
            return mismatchedNode;
          }
          const n2 = tree.getChildCount();
          for (let i = 0; i < n2; i++) {
            const childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
            if (childMatch) {
              return childMatch;
            }
          }
          return mismatchedNode;
        }
        return tree;
      }
      /**
       * Is `t` `(expr <expr>)` subtree?
       */
      getRuleTagToken(t) {
        if (t instanceof ParserRuleContext) {
          if (t.getChildCount() === 1 && t.getChild(0) instanceof TerminalNode) {
            const c = t.getChild(0);
            if (c.getSymbol() instanceof RuleTagToken) {
              return c.getSymbol();
            }
          }
        }
        return void 0;
      }
    };
    var DiagnosticErrorListener = class extends BaseErrorListener {
      static {
        __name(this, "DiagnosticErrorListener");
      }
      /**
       * When `true`, only exactly known ambiguities are reported.
       */
      exactOnly;
      constructor(exactOnly) {
        super();
        this.exactOnly = exactOnly ?? true;
      }
      reportAmbiguity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) => {
        if (this.exactOnly && !exact) {
          return;
        }
        const decision = this.getDecisionDescription(recognizer, dfa);
        const conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
        const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
        const message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;
        recognizer.notifyErrorListeners(message, null, null);
      }, "reportAmbiguity");
      reportAttemptingFullContext = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _conflictingAlts, _configs) => {
        const decision = this.getDecisionDescription(recognizer, dfa);
        const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
        const message = `reportAttemptingFullContext d=${decision}, input='${text}'`;
        recognizer.notifyErrorListeners(message, null, null);
      }, "reportAttemptingFullContext");
      reportContextSensitivity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _prediction, _configs) => {
        const decision = this.getDecisionDescription(recognizer, dfa);
        const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
        const message = `reportContextSensitivity d=${decision}, input='${text}'`;
        recognizer.notifyErrorListeners(message, null, null);
      }, "reportContextSensitivity");
      getDecisionDescription = /* @__PURE__ */ __name((recognizer, dfa) => {
        const decision = dfa.decision;
        const ruleIndex = dfa.atnStartState.ruleIndex;
        const ruleNames = recognizer.ruleNames;
        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
          return decision.toString();
        }
        const ruleName = ruleNames[ruleIndex];
        if (ruleName.length === 0) {
          return decision.toString();
        }
        return `${decision} (${ruleName})`;
      }, "getDecisionDescription");
      /**
       * Computes the set of conflicting or ambiguous alternatives from a
       * configuration set, if that information was not already provided by the
       * parser.
       *
       * @param reportedAlts The set of conflicting or ambiguous alternatives, as
       * reported by the parser.
       * @param configs The conflicting or ambiguous configuration set.
       * @returns Returns `reportedAlts` if it is not `null`, otherwise
       * returns the set of alternatives represented in `configs`.
       */
      getConflictingAlts = /* @__PURE__ */ __name((reportedAlts, configs) => {
        if (reportedAlts) {
          return reportedAlts;
        }
        const result = new BitSet();
        for (let i = 0; i < configs.configs.length; i++) {
          result.set(configs.configs[i].alt);
        }
        return result;
      }, "getConflictingAlts");
    };
    var LexerInterpreter = class extends Lexer {
      static {
        __name(this, "LexerInterpreter");
      }
      decisionToDFA;
      sharedContextCache = new PredictionContextCache();
      #grammarFileName;
      #atn;
      #ruleNames;
      #channelNames;
      #modeNames;
      #vocabulary;
      constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
        super(input);
        if (atn.grammarType !== ATN.LEXER) {
          throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
        }
        this.#grammarFileName = grammarFileName;
        this.#atn = atn;
        this.#ruleNames = ruleNames.slice(0);
        this.#channelNames = channelNames.slice(0);
        this.#modeNames = modeNames.slice(0);
        this.#vocabulary = vocabulary;
        this.decisionToDFA = atn.decisionToState.map((ds, i) => {
          return new DFA(ds, i);
        });
        this.interpreter = new LexerATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);
      }
      get atn() {
        return this.#atn;
      }
      get grammarFileName() {
        return this.#grammarFileName;
      }
      get ruleNames() {
        return this.#ruleNames;
      }
      get channelNames() {
        return this.#channelNames;
      }
      get modeNames() {
        return this.#modeNames;
      }
      get vocabulary() {
        return this.#vocabulary;
      }
      get serializedATN() {
        throw new Error("The LexerInterpreter does not support the serializedATN property.");
      }
    };
    var RuntimeMetaData = class _RuntimeMetaData {
      static {
        __name(this, "RuntimeMetaData");
      }
      /**
       * A compile-time constant containing the current version of the ANTLR 4
       * runtime library.
       *
       * This compile-time constant value allows generated parsers and other
       * libraries to include a literal reference to the version of the ANTLR 4
       * runtime library the code was compiled against. At each release, we
       * change this value.
       *
       * Version numbers are assumed to have the form
       *
       * major.minor.patch.revision-suffix,
       *
       * with the individual components defined as follows.
       *
       * - major is a required non-negative integer, and is equal to `4` for ANTLR 4.
       * - minor is a required non-negative integer.
       * - patch is an optional non-negative integer. When patch is omitted, the `.` (dot) appearing before it is
       *   also omitted.
       * - revision is an optional non-negative integer, and may only be included when patch is also included.
       *   When revision is omitted, the `.` (dot) appearing before it is also omitted.
       * - suffix is an optional string. When suffix is omitted, the `-` (hyphen-minus) appearing before it is also
       *   omitted.
       */
      static VERSION = "4.13.1";
      /**
       * Gets the currently executing version of the ANTLR 4 runtime library.
       *
       * This method provides runtime access to the {@link VERSION} field, as
       * opposed to directly referencing the field as a compile-time constant.
       *
       * @returns The currently executing version of the ANTLR 4 library
       */
      static getRuntimeVersion() {
        return _RuntimeMetaData.VERSION;
      }
      /**
       * This method provides the ability to detect mismatches between the version
       * of ANTLR 4 used to generate a parser, the version of the ANTLR runtime a
       * parser was compiled against, and the version of the ANTLR runtime which
       * is currently executing.
       *
       * The version check is designed to detect the following two specific
       * scenarios.
       *
       * - The ANTLR Tool version used for code generation does not match the
       * currently executing runtime version.
       * - The ANTLR Runtime version referenced at the time a parser was
       * compiled does not match the currently executing runtime version.
       *
       *
       * Starting with ANTLR 4.3, the code generator emits a call to this method
       * using two constants in each generated lexer and parser: a hard-coded
       * constant indicating the version of the tool used to generate the parser
       * and a reference to the compile-time constant {@link VERSION}. At
       * runtime, this method is called during the initialization of the generated
       * parser to detect mismatched versions, and notify the registered listeners
       * prior to creating instances of the parser.
       *
       *
       * This method does not perform any detection or filtering of semantic
       * changes between tool and runtime versions. It simply checks for a
       * version match and emits an error to stderr if a difference
       * is detected.
       *
       *
       * Note that some breaking changes between releases could result in other
       * types of runtime exceptions, such as a {@link LinkageError}, prior to
       * calling this method. In these cases, the underlying version mismatch will
       * not be reported here. This method is primarily intended to
       * notify users of potential semantic changes between releases that do not
       * result in binary compatibility problems which would be detected by the
       * class loader. As with semantic changes, changes that break binary
       * compatibility between releases are mentioned in the release notes
       * accompanying the affected release.
       *
       *
       * **Additional note for target developers:** The version check
       * implemented by this class is designed to address specific compatibility
       * concerns that may arise during the execution of Java applications. Other
       * targets should consider the implementation of this method in the context
       * of that target's known execution environment, which may or may not
       * resemble the design provided for the Java target.
       *
       * @param generatingToolVersion The version of the tool used to generate a parser.
       * This value may be null when called from user code that was not generated
       * by, and does not reference, the ANTLR 4 Tool itself.
       * @param compileTimeVersion The version of the runtime the parser was
       * compiled against. This should always be passed using a direct reference
       * to {@link VERSION}.
       */
      static checkVersion(generatingToolVersion, compileTimeVersion) {
        const runtimeVersion = _RuntimeMetaData.VERSION;
        let runtimeConflictsWithGeneratingTool = false;
        let runtimeConflictsWithCompileTimeTool = false;
        runtimeConflictsWithGeneratingTool = runtimeVersion !== generatingToolVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(generatingToolVersion);
        runtimeConflictsWithCompileTimeTool = runtimeVersion !== compileTimeVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(compileTimeVersion);
        if (runtimeConflictsWithGeneratingTool) {
          console.error(`ANTLR Tool version ${generatingToolVersion} used for code generation does not match the current runtime version ${runtimeVersion}`);
        }
        if (runtimeConflictsWithCompileTimeTool) {
          console.error(`ANTLR Runtime version ${compileTimeVersion} used for parser compilation does not match the current runtime version ${runtimeVersion}`);
        }
      }
      /**
       * Gets the major and minor version numbers from a version string. For
       * details about the syntax of the input `version`.
       * E.g., from x.y.z return x.y.
       *
       * @param version The complete version string.
       * @returns A string of the form *major*.*minor* containing
       * only the major and minor components of the version string.
       */
      static getMajorMinorVersion(version) {
        const firstDot = version.indexOf(".");
        const secondDot = firstDot >= 0 ? version.indexOf(".", firstDot + 1) : -1;
        const firstDash = version.indexOf("-");
        let referenceLength = version.length;
        if (secondDot >= 0) {
          referenceLength = Math.min(referenceLength, secondDot);
        }
        if (firstDash >= 0) {
          referenceLength = Math.min(referenceLength, firstDash);
        }
        return version.substring(0, referenceLength);
      }
    };
    var TokenStreamRewriter = class _TokenStreamRewriter {
      static {
        __name(this, "TokenStreamRewriter");
      }
      static DEFAULT_PROGRAM_NAME = "default";
      static PROGRAM_INIT_SIZE = 100;
      static MIN_TOKEN_INDEX = 0;
      /** Our source stream */
      tokens;
      /**
       * You may have multiple, named streams of rewrite operations.
       *  I'm calling these things "programs."
       *  Maps String (name) -> rewrite (List)
       */
      programs = /* @__PURE__ */ new Map();
      /** Map String (program name) -> Integer index */
      lastRewriteTokenIndexes;
      /**
       * @param tokens The token stream to modify
       */
      constructor(tokens) {
        this.tokens = tokens;
      }
      getTokenStream() {
        return this.tokens;
      }
      /**
       * Insert the supplied text after the specified token (or token index)
       */
      insertAfter(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index;
        if (typeof tokenOrIndex === "number") {
          index = tokenOrIndex;
        } else {
          index = tokenOrIndex.tokenIndex;
        }
        const rewrites = this.getProgram(programName);
        const op = new InsertAfterOp(this.tokens, index, rewrites.length, text);
        rewrites.push(op);
      }
      /**
       * Insert the supplied text before the specified token (or token index)
       */
      insertBefore(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index;
        if (typeof tokenOrIndex === "number") {
          index = tokenOrIndex;
        } else {
          index = tokenOrIndex.tokenIndex;
        }
        const rewrites = this.getProgram(programName);
        const op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);
        rewrites.push(op);
      }
      /**
       * Replace the specified token with the supplied text
       */
      replaceSingle(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        this.replace(tokenOrIndex, tokenOrIndex, text, programName);
      }
      /**
       * Replace the specified range of tokens with the supplied text.
       */
      replace(from, to, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (typeof from !== "number") {
          from = from.tokenIndex;
        }
        if (typeof to !== "number") {
          to = to.tokenIndex;
        }
        if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
          throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
        }
        const rewrites = this.getProgram(programName);
        const op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);
        rewrites.push(op);
      }
      /**
       * Delete the specified range of tokens
       */
      delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (to == null) {
          to = from;
        }
        this.replace(from, to, null, programName);
      }
      getProgram(name) {
        let is = this.programs.get(name);
        if (is == null) {
          is = this.initializeProgram(name);
        }
        return is;
      }
      initializeProgram(name) {
        const is = [];
        this.programs.set(name, is);
        return is;
      }
      /**
       * @returns the text from the original tokens altered per the instructions given to this rewriter
       */
      getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let interval;
        if (intervalOrProgram instanceof Interval) {
          interval = intervalOrProgram;
        } else {
          interval = new Interval(0, this.tokens.size - 1);
        }
        if (typeof intervalOrProgram === "string") {
          programName = intervalOrProgram;
        }
        const rewrites = this.programs.get(programName);
        let start = interval.start;
        let stop = interval.stop;
        if (stop > this.tokens.size - 1) {
          stop = this.tokens.size - 1;
        }
        if (start < 0) {
          start = 0;
        }
        if (rewrites == null || rewrites.length === 0) {
          return this.tokens.getTextFromInterval(new Interval(start, stop));
        }
        const buf = [];
        const indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
        let i = start;
        while (i <= stop && i < this.tokens.size) {
          const op = indexToOp.get(i);
          indexToOp.delete(i);
          const t = this.tokens.get(i);
          if (op == null) {
            if (t.type !== Token.EOF) {
              buf.push(String(t.text));
            }
            i++;
          } else {
            i = op.execute(buf);
          }
        }
        if (stop === this.tokens.size - 1) {
          for (const op of indexToOp.values()) {
            if (op && op.index >= this.tokens.size - 1) {
              buf.push(String(op.text));
            }
          }
        }
        return buf.join("");
      }
      /**
       * @returns a map from token index to operation
       */
      reduceToSingleOperationPerIndex(rewrites) {
        for (let i = 0; i < rewrites.length; i++) {
          const op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof ReplaceOp)) {
            continue;
          }
          const rop = op;
          const inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (const iop of inserts) {
            if (iop.index === rop.index) {
              rewrites[iop.instructionIndex] = null;
              rop.text = String(iop.text) + (rop.text != null ? rop.text.toString() : "");
            } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
              rewrites[iop.instructionIndex] = null;
            }
          }
          const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (const prevRop of prevReplaces) {
            if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
              rewrites[prevRop.instructionIndex] = null;
              continue;
            }
            const disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
            if (prevRop.text == null && rop.text == null && !disjoint) {
              rewrites[prevRop.instructionIndex] = null;
              rop.index = Math.min(prevRop.index, rop.index);
              rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
            } else if (!disjoint) {
              throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
            }
          }
        }
        for (let i = 0; i < rewrites.length; i++) {
          const op = rewrites[i];
          if (op == null) {
            continue;
          }
          if (!(op instanceof InsertBeforeOp)) {
            continue;
          }
          const iop = op;
          const prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
          for (const prevIop of prevInserts) {
            if (prevIop.index === iop.index) {
              if (prevIop instanceof InsertAfterOp) {
                iop.text = this.catOpText(prevIop.text, iop.text);
                rewrites[prevIop.instructionIndex] = null;
              } else if (prevIop instanceof InsertBeforeOp) {
                iop.text = this.catOpText(iop.text, prevIop.text);
                rewrites[prevIop.instructionIndex] = null;
              }
            }
          }
          const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
          for (const rop of prevReplaces) {
            if (iop.index === rop.index) {
              rop.text = this.catOpText(iop.text, rop.text);
              rewrites[i] = null;
              continue;
            }
            if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
              throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
            }
          }
        }
        const m2 = /* @__PURE__ */ new Map();
        for (const op of rewrites) {
          if (op == null) {
            continue;
          }
          if (m2.get(op.index) != null) {
            throw new Error("should only be one op per index");
          }
          m2.set(op.index, op);
        }
        return m2;
      }
      catOpText(a, b) {
        let x = "";
        let y = "";
        if (a != null) {
          x = a.toString();
        }
        if (b != null) {
          y = b.toString();
        }
        return x + y;
      }
      /**
       * Get all operations before an index of a particular kind
       */
      getKindOfOps(rewrites, kind, before) {
        return rewrites.slice(0, before).filter((op) => {
          return op && op instanceof kind;
        });
      }
    };
    var RewriteOperation = class {
      static {
        __name(this, "RewriteOperation");
      }
      /** What index into rewrites List are we? */
      instructionIndex;
      /** Token buffer index. */
      index;
      text;
      tokens;
      constructor(tokens, index, instructionIndex, text) {
        this.tokens = tokens;
        this.instructionIndex = instructionIndex;
        this.index = index;
        this.text = text === void 0 ? "" : text;
      }
      execute(_buf) {
        return this.index;
      }
      toString() {
        return "<RewriteOperation@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    };
    var InsertBeforeOp = class extends RewriteOperation {
      static {
        __name(this, "InsertBeforeOp");
      }
      constructor(tokens, index, instructionIndex, text) {
        super(tokens, index, instructionIndex, text);
      }
      /**
       * @returns the index of the next token to operate on
       */
      execute(buf) {
        if (this.text) {
          buf.push(this.text.toString());
        }
        if (this.tokens.get(this.index).type !== Token.EOF) {
          buf.push(String(this.tokens.get(this.index).text));
        }
        return this.index + 1;
      }
      toString() {
        return "<InsertBeforeOp@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    };
    var InsertAfterOp = class extends InsertBeforeOp {
      static {
        __name(this, "InsertAfterOp");
      }
      constructor(tokens, index, instructionIndex, text) {
        super(tokens, index + 1, instructionIndex, text);
      }
      toString() {
        return "<InsertAfterOp@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    };
    var ReplaceOp = class extends RewriteOperation {
      static {
        __name(this, "ReplaceOp");
      }
      lastIndex;
      constructor(tokens, from, to, instructionIndex, text) {
        super(tokens, from, instructionIndex, text);
        this.lastIndex = to;
      }
      /**
       * @returns the index of the next token to operate on
       */
      execute(buf) {
        if (this.text) {
          buf.push(this.text.toString());
        }
        return this.lastIndex + 1;
      }
      toString() {
        if (this.text == null) {
          return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
        }
        return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
      }
    };
    var UnbufferedTokenStream = class {
      static {
        __name(this, "UnbufferedTokenStream");
      }
      tokenSource;
      /**
       * A moving window buffer of the data being scanned. While there's a marker,
       * we keep adding to buffer. Otherwise, {@link #consume consume()} resets so
       * we start filling at index 0 again.
       */
      tokens;
      /**
       * The number of tokens currently in {@link #tokens tokens}.
       *
       * This is not the buffer capacity, that's `tokens.length`.
       */
      n;
      /**
       * 0..n-1 index into {@link #tokens tokens} of next token.
       *
       * The `LT(1)` token is `tokens[p]`. If `p == n`, we are
       * out of buffered tokens.
       */
      p = 0;
      /**
       * Count up with {@link #mark mark()} and down with
       * {@link #release release()}. When we `release()` the last mark,
       * `numMarkers` reaches 0 and we reset the buffer. Copy
       * `tokens[p]..tokens[n-1]` to `tokens[0]..tokens[(n-1)-p]`.
       */
      numMarkers = 0;
      /**
       * This is the `LT(-1)` token for the current position.
       */
      lastToken;
      /**
       * When `numMarkers > 0`, this is the `LT(-1)` token for the
       * first token in {@link #tokens}. Otherwise, this is `null`.
       */
      lastTokenBufferStart;
      /**
       * Absolute token index. It's the index of the token about to be read via
       * `LT(1)`. Goes from 0 to the number of tokens in the entire stream,
       * although the stream size is unknown before the end is reached.
       *
       * This value is used to set the token indexes if the stream provides tokens
       * that implement {@link WritableToken}.
       */
      currentTokenIndex = 0;
      constructor(tokenSource, bufferSize) {
        this.tokenSource = tokenSource;
        bufferSize = bufferSize ?? 256;
        this.tokens = new Array(bufferSize);
        this.n = 0;
        this.fill(1);
      }
      get(i) {
        const bufferStartIndex = this.getBufferStartIndex();
        if (i < bufferStartIndex || i >= bufferStartIndex + this.n) {
          throw new Error("get(" + i + ") outside buffer: " + bufferStartIndex + ".." + (bufferStartIndex + this.n));
        }
        return this.tokens[i - bufferStartIndex];
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      LT(i) {
        if (i === -1) {
          return this.lastToken;
        }
        this.sync(i);
        const index = this.p + i - 1;
        if (index < 0) {
          throw new Error("LT(" + i + ") gives negative index");
        }
        if (index >= this.n) {
          return this.tokens[this.n - 1];
        }
        return this.tokens[index];
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      LA(i) {
        return this.LT(i).type;
      }
      getText() {
        return "";
      }
      getTextFromContext(ctx) {
        return this.getTextFromInterval(ctx.getSourceInterval());
      }
      getTextFromInterval(interval) {
        const bufferStartIndex = this.getBufferStartIndex();
        const bufferStopIndex = bufferStartIndex + this.tokens.length - 1;
        const start = interval.start;
        const stop = interval.stop;
        if (start < bufferStartIndex || stop > bufferStopIndex) {
          throw new Error("interval " + interval + " not in token buffer window: " + bufferStartIndex + ".." + bufferStopIndex);
        }
        const a = start - bufferStartIndex;
        const b = stop - bufferStartIndex;
        let result = "";
        for (let i = a; i <= b; i++) {
          const t = this.tokens[i];
          result += t.text;
        }
        return result;
      }
      getTextFromRange(start, stop) {
        return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));
      }
      consume() {
        if (this.LA(1) === Token.EOF) {
          throw new Error("cannot consume EOF");
        }
        this.lastToken = this.tokens[this.p];
        if (this.p === this.n - 1 && this.numMarkers === 0) {
          this.n = 0;
          this.p = -1;
          this.lastTokenBufferStart = this.lastToken;
        }
        this.p++;
        this.currentTokenIndex++;
        this.sync(1);
      }
      /**
       * Return a marker that we can release later.
       *
       * The specific marker value used for this class allows for some level of
       * protection against misuse where `seek()` is called on a mark or
       * `release()` is called in the wrong order.
       */
      mark() {
        if (this.numMarkers === 0) {
          this.lastTokenBufferStart = this.lastToken;
        }
        const mark = -this.numMarkers - 1;
        this.numMarkers++;
        return mark;
      }
      release(marker) {
        const expectedMark = -this.numMarkers;
        if (marker !== expectedMark) {
          throw new Error("release() called with an invalid marker.");
        }
        this.numMarkers--;
        if (this.numMarkers === 0) {
          if (this.p > 0) {
            this.tokens.copyWithin(0, this.p, this.n);
            this.n = this.n - this.p;
            this.p = 0;
          }
          this.lastTokenBufferStart = this.lastToken;
        }
      }
      get index() {
        return this.currentTokenIndex;
      }
      seek(index) {
        if (index === this.currentTokenIndex) {
          return;
        }
        if (index > this.currentTokenIndex) {
          this.sync(index - this.currentTokenIndex);
          index = Math.min(index, this.getBufferStartIndex() + this.n - 1);
        }
        const bufferStartIndex = this.getBufferStartIndex();
        const i = index - bufferStartIndex;
        if (i < 0) {
          throw new Error("cannot seek to negative index " + index);
        } else {
          if (i >= this.n) {
            throw new Error("seek to index outside buffer: " + index + " not in " + bufferStartIndex + ".." + (bufferStartIndex + this.n));
          }
        }
        this.p = i;
        this.currentTokenIndex = index;
        if (this.p === 0) {
          this.lastToken = this.lastTokenBufferStart;
        } else {
          this.lastToken = this.tokens[this.p - 1];
        }
      }
      get size() {
        throw new Error("Unbuffered stream cannot know its size");
      }
      getSourceName() {
        return this.tokenSource.sourceName;
      }
      setLine(line) {
        this.tokenSource.line = line;
      }
      setColumn(column) {
        this.tokenSource.column = column;
      }
      /**
       * Make sure we have 'need' elements from current position {@link #p p}. Last valid
       * `p` index is `tokens.length-1`.  `p+need-1` is the tokens index 'need' elements
       * ahead.  If we need 1 element, `(p+1-1)==p` must be less than `tokens.length`.
       */
      sync(want) {
        const need = this.p + want - 1 - this.n + 1;
        if (need > 0) {
          this.fill(need);
        }
      }
      /**
       * Add `n` elements to the buffer. Returns the number of tokens
       * actually added to the buffer. If the return value is less than `n`,
       * then EOF was reached before `n` tokens could be added.
       */
      fill(n2) {
        for (let i = 0; i < n2; i++) {
          if (this.n > 0 && this.tokens[this.n - 1].type === Token.EOF) {
            return i;
          }
          const t = this.tokenSource.nextToken();
          this.add(t);
        }
        return n2;
      }
      add(t) {
        if (this.n >= this.tokens.length) {
          this.tokens.length = this.tokens.length * 2;
        }
        if (isWritableToken(t)) {
          t.setTokenIndex(this.getBufferStartIndex() + this.n);
        }
        this.tokens[this.n++] = t;
      }
      getBufferStartIndex() {
        return this.currentTokenIndex - this.p;
      }
    };
  }
});

// server/parser/gen/MangleLexer.js
var require_MangleLexer = __commonJS({
  "server/parser/gen/MangleLexer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MangleLexer = void 0;
    var antlr = __importStar(require_dist());
    var MangleLexer = class _MangleLexer extends antlr.Lexer {
      constructor(input) {
        super(input);
        this.interpreter = new antlr.LexerATNSimulator(this, _MangleLexer._ATN, _MangleLexer.decisionsToDFA, new antlr.PredictionContextCache());
      }
      get grammarFileName() {
        return "Mangle.g4";
      }
      get literalNames() {
        return _MangleLexer.literalNames;
      }
      get symbolicNames() {
        return _MangleLexer.symbolicNames;
      }
      get ruleNames() {
        return _MangleLexer.ruleNames;
      }
      get serializedATN() {
        return _MangleLexer._serializedATN;
      }
      get channelNames() {
        return _MangleLexer.channelNames;
      }
      get modeNames() {
        return _MangleLexer.modeNames;
      }
      static get _ATN() {
        if (!_MangleLexer.__ATN) {
          _MangleLexer.__ATN = new antlr.ATNDeserializer().deserialize(_MangleLexer._serializedATN);
        }
        return _MangleLexer.__ATN;
      }
      get vocabulary() {
        return _MangleLexer.vocabulary;
      }
    };
    exports2.MangleLexer = MangleLexer;
    MangleLexer.T__0 = 1;
    MangleLexer.T__1 = 2;
    MangleLexer.T__2 = 3;
    MangleLexer.T__3 = 4;
    MangleLexer.T__4 = 5;
    MangleLexer.T__5 = 6;
    MangleLexer.T__6 = 7;
    MangleLexer.WHITESPACE = 8;
    MangleLexer.COMMENT = 9;
    MangleLexer.LONGLEFTDOUBLEARROW = 10;
    MangleLexer.PACKAGE = 11;
    MangleLexer.USE = 12;
    MangleLexer.DECL = 13;
    MangleLexer.BOUND = 14;
    MangleLexer.LET = 15;
    MangleLexer.DO = 16;
    MangleLexer.LPAREN = 17;
    MangleLexer.RPAREN = 18;
    MangleLexer.LBRACKET = 19;
    MangleLexer.RBRACKET = 20;
    MangleLexer.LBRACE = 21;
    MangleLexer.RBRACE = 22;
    MangleLexer.EQ = 23;
    MangleLexer.BANGEQ = 24;
    MangleLexer.COMMA = 25;
    MangleLexer.BANG = 26;
    MangleLexer.LESSEQ = 27;
    MangleLexer.LESS = 28;
    MangleLexer.GREATEREQ = 29;
    MangleLexer.GREATER = 30;
    MangleLexer.COLONDASH = 31;
    MangleLexer.NEWLINE = 32;
    MangleLexer.PIPEGREATER = 33;
    MangleLexer.AT = 34;
    MangleLexer.DIAMONDMINUS = 35;
    MangleLexer.DIAMONDPLUS = 36;
    MangleLexer.BOXMINUS = 37;
    MangleLexer.BOXPLUS = 38;
    MangleLexer.TIMESTAMP = 39;
    MangleLexer.DURATION = 40;
    MangleLexer.NUMBER = 41;
    MangleLexer.FLOAT = 42;
    MangleLexer.VARIABLE = 43;
    MangleLexer.NAME = 44;
    MangleLexer.TYPENAME = 45;
    MangleLexer.DOT_TYPE = 46;
    MangleLexer.CONSTANT = 47;
    MangleLexer.STRING = 48;
    MangleLexer.BYTESTRING = 49;
    MangleLexer.channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    MangleLexer.literalNames = [
      null,
      "'temporal'",
      "'.'",
      "'descr'",
      "'inclusion'",
      "'now'",
      "':'",
      "'opt'",
      null,
      null,
      "'\\u27F8'",
      "'Package'",
      "'Use'",
      "'Decl'",
      "'bound'",
      "'let'",
      "'do'",
      "'('",
      "')'",
      "'['",
      "']'",
      "'{'",
      "'}'",
      "'='",
      "'!='",
      "','",
      "'!'",
      "'<='",
      "'<'",
      "'>='",
      "'>'",
      "':-'",
      "'\\n'",
      "'|>'",
      "'@'",
      "'<-'",
      "'<+'",
      "'[-'",
      "'[+'"
    ];
    MangleLexer.symbolicNames = [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      "WHITESPACE",
      "COMMENT",
      "LONGLEFTDOUBLEARROW",
      "PACKAGE",
      "USE",
      "DECL",
      "BOUND",
      "LET",
      "DO",
      "LPAREN",
      "RPAREN",
      "LBRACKET",
      "RBRACKET",
      "LBRACE",
      "RBRACE",
      "EQ",
      "BANGEQ",
      "COMMA",
      "BANG",
      "LESSEQ",
      "LESS",
      "GREATEREQ",
      "GREATER",
      "COLONDASH",
      "NEWLINE",
      "PIPEGREATER",
      "AT",
      "DIAMONDMINUS",
      "DIAMONDPLUS",
      "BOXMINUS",
      "BOXPLUS",
      "TIMESTAMP",
      "DURATION",
      "NUMBER",
      "FLOAT",
      "VARIABLE",
      "NAME",
      "TYPENAME",
      "DOT_TYPE",
      "CONSTANT",
      "STRING",
      "BYTESTRING"
    ];
    MangleLexer.modeNames = [
      "DEFAULT_MODE"
    ];
    MangleLexer.ruleNames = [
      "T__0",
      "T__1",
      "T__2",
      "T__3",
      "T__4",
      "T__5",
      "T__6",
      "WHITESPACE",
      "COMMENT",
      "LONGLEFTDOUBLEARROW",
      "PACKAGE",
      "USE",
      "DECL",
      "BOUND",
      "LET",
      "DO",
      "LPAREN",
      "RPAREN",
      "LBRACKET",
      "RBRACKET",
      "LBRACE",
      "RBRACE",
      "EQ",
      "BANGEQ",
      "COMMA",
      "BANG",
      "LESSEQ",
      "LESS",
      "GREATEREQ",
      "GREATER",
      "COLONDASH",
      "NEWLINE",
      "PIPEGREATER",
      "AT",
      "DIAMONDMINUS",
      "DIAMONDPLUS",
      "BOXMINUS",
      "BOXPLUS",
      "LETTER",
      "DIGIT",
      "TIMESTAMP",
      "DURATION",
      "NUMBER",
      "FLOAT",
      "EXPONENT",
      "VARIABLE_START",
      "VARIABLE_CHAR",
      "VARIABLE",
      "NAME_CHAR",
      "NAME",
      "TYPENAME",
      "DOT_TYPE",
      "CONSTANT_CHAR",
      "CONSTANT",
      "STRING",
      "BYTESTRING",
      "SHORT_STRING",
      "LONG_STRING",
      "LONG_STRING_ITEM",
      "LONG_STRING_CHAR",
      "STRING_ESCAPE_SEQ",
      "HEXDIGIT"
    ];
    MangleLexer._serializedATN = [
      4,
      0,
      49,
      504,
      6,
      -1,
      2,
      0,
      7,
      0,
      2,
      1,
      7,
      1,
      2,
      2,
      7,
      2,
      2,
      3,
      7,
      3,
      2,
      4,
      7,
      4,
      2,
      5,
      7,
      5,
      2,
      6,
      7,
      6,
      2,
      7,
      7,
      7,
      2,
      8,
      7,
      8,
      2,
      9,
      7,
      9,
      2,
      10,
      7,
      10,
      2,
      11,
      7,
      11,
      2,
      12,
      7,
      12,
      2,
      13,
      7,
      13,
      2,
      14,
      7,
      14,
      2,
      15,
      7,
      15,
      2,
      16,
      7,
      16,
      2,
      17,
      7,
      17,
      2,
      18,
      7,
      18,
      2,
      19,
      7,
      19,
      2,
      20,
      7,
      20,
      2,
      21,
      7,
      21,
      2,
      22,
      7,
      22,
      2,
      23,
      7,
      23,
      2,
      24,
      7,
      24,
      2,
      25,
      7,
      25,
      2,
      26,
      7,
      26,
      2,
      27,
      7,
      27,
      2,
      28,
      7,
      28,
      2,
      29,
      7,
      29,
      2,
      30,
      7,
      30,
      2,
      31,
      7,
      31,
      2,
      32,
      7,
      32,
      2,
      33,
      7,
      33,
      2,
      34,
      7,
      34,
      2,
      35,
      7,
      35,
      2,
      36,
      7,
      36,
      2,
      37,
      7,
      37,
      2,
      38,
      7,
      38,
      2,
      39,
      7,
      39,
      2,
      40,
      7,
      40,
      2,
      41,
      7,
      41,
      2,
      42,
      7,
      42,
      2,
      43,
      7,
      43,
      2,
      44,
      7,
      44,
      2,
      45,
      7,
      45,
      2,
      46,
      7,
      46,
      2,
      47,
      7,
      47,
      2,
      48,
      7,
      48,
      2,
      49,
      7,
      49,
      2,
      50,
      7,
      50,
      2,
      51,
      7,
      51,
      2,
      52,
      7,
      52,
      2,
      53,
      7,
      53,
      2,
      54,
      7,
      54,
      2,
      55,
      7,
      55,
      2,
      56,
      7,
      56,
      2,
      57,
      7,
      57,
      2,
      58,
      7,
      58,
      2,
      59,
      7,
      59,
      2,
      60,
      7,
      60,
      2,
      61,
      7,
      61,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      2,
      1,
      2,
      1,
      2,
      1,
      2,
      1,
      2,
      1,
      2,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      3,
      1,
      4,
      1,
      4,
      1,
      4,
      1,
      4,
      1,
      5,
      1,
      5,
      1,
      6,
      1,
      6,
      1,
      6,
      1,
      6,
      1,
      7,
      4,
      7,
      164,
      8,
      7,
      11,
      7,
      12,
      7,
      165,
      1,
      7,
      1,
      7,
      1,
      8,
      1,
      8,
      5,
      8,
      172,
      8,
      8,
      10,
      8,
      12,
      8,
      175,
      9,
      8,
      1,
      8,
      1,
      8,
      1,
      9,
      1,
      9,
      1,
      10,
      1,
      10,
      1,
      10,
      1,
      10,
      1,
      10,
      1,
      10,
      1,
      10,
      1,
      10,
      1,
      11,
      1,
      11,
      1,
      11,
      1,
      11,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      14,
      1,
      14,
      1,
      14,
      1,
      14,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      16,
      1,
      16,
      1,
      17,
      1,
      17,
      1,
      18,
      1,
      18,
      1,
      19,
      1,
      19,
      1,
      20,
      1,
      20,
      1,
      21,
      1,
      21,
      1,
      22,
      1,
      22,
      1,
      23,
      1,
      23,
      1,
      23,
      1,
      24,
      1,
      24,
      1,
      25,
      1,
      25,
      1,
      26,
      1,
      26,
      1,
      26,
      1,
      27,
      1,
      27,
      1,
      28,
      1,
      28,
      1,
      28,
      1,
      29,
      1,
      29,
      1,
      30,
      1,
      30,
      1,
      30,
      1,
      31,
      1,
      31,
      1,
      32,
      1,
      32,
      1,
      32,
      1,
      33,
      1,
      33,
      1,
      34,
      1,
      34,
      1,
      34,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      37,
      1,
      37,
      1,
      37,
      1,
      38,
      1,
      38,
      1,
      39,
      1,
      39,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      4,
      40,
      289,
      8,
      40,
      11,
      40,
      12,
      40,
      290,
      3,
      40,
      293,
      8,
      40,
      1,
      40,
      3,
      40,
      296,
      8,
      40,
      3,
      40,
      298,
      8,
      40,
      1,
      41,
      4,
      41,
      301,
      8,
      41,
      11,
      41,
      12,
      41,
      302,
      1,
      41,
      1,
      41,
      1,
      41,
      3,
      41,
      308,
      8,
      41,
      1,
      42,
      3,
      42,
      311,
      8,
      42,
      1,
      42,
      1,
      42,
      5,
      42,
      315,
      8,
      42,
      10,
      42,
      12,
      42,
      318,
      9,
      42,
      1,
      43,
      3,
      43,
      321,
      8,
      43,
      1,
      43,
      4,
      43,
      324,
      8,
      43,
      11,
      43,
      12,
      43,
      325,
      1,
      43,
      1,
      43,
      4,
      43,
      330,
      8,
      43,
      11,
      43,
      12,
      43,
      331,
      1,
      43,
      3,
      43,
      335,
      8,
      43,
      1,
      43,
      3,
      43,
      338,
      8,
      43,
      1,
      43,
      1,
      43,
      4,
      43,
      342,
      8,
      43,
      11,
      43,
      12,
      43,
      343,
      1,
      43,
      3,
      43,
      347,
      8,
      43,
      3,
      43,
      349,
      8,
      43,
      1,
      44,
      1,
      44,
      3,
      44,
      353,
      8,
      44,
      1,
      44,
      4,
      44,
      356,
      8,
      44,
      11,
      44,
      12,
      44,
      357,
      1,
      45,
      1,
      45,
      1,
      46,
      1,
      46,
      3,
      46,
      364,
      8,
      46,
      1,
      47,
      1,
      47,
      1,
      47,
      5,
      47,
      369,
      8,
      47,
      10,
      47,
      12,
      47,
      372,
      9,
      47,
      3,
      47,
      374,
      8,
      47,
      1,
      48,
      1,
      48,
      1,
      48,
      3,
      48,
      379,
      8,
      48,
      1,
      49,
      3,
      49,
      382,
      8,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      5,
      49,
      388,
      8,
      49,
      10,
      49,
      12,
      49,
      391,
      9,
      49,
      1,
      50,
      1,
      50,
      1,
      50,
      1,
      50,
      5,
      50,
      397,
      8,
      50,
      10,
      50,
      12,
      50,
      400,
      9,
      50,
      1,
      51,
      1,
      51,
      1,
      51,
      1,
      52,
      1,
      52,
      1,
      52,
      3,
      52,
      408,
      8,
      52,
      1,
      53,
      1,
      53,
      4,
      53,
      412,
      8,
      53,
      11,
      53,
      12,
      53,
      413,
      1,
      53,
      1,
      53,
      4,
      53,
      418,
      8,
      53,
      11,
      53,
      12,
      53,
      419,
      5,
      53,
      422,
      8,
      53,
      10,
      53,
      12,
      53,
      425,
      9,
      53,
      1,
      54,
      1,
      54,
      3,
      54,
      429,
      8,
      54,
      1,
      55,
      1,
      55,
      1,
      55,
      1,
      56,
      1,
      56,
      1,
      56,
      5,
      56,
      437,
      8,
      56,
      10,
      56,
      12,
      56,
      440,
      9,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      5,
      56,
      446,
      8,
      56,
      10,
      56,
      12,
      56,
      449,
      9,
      56,
      1,
      56,
      3,
      56,
      452,
      8,
      56,
      1,
      57,
      1,
      57,
      5,
      57,
      456,
      8,
      57,
      10,
      57,
      12,
      57,
      459,
      9,
      57,
      1,
      57,
      1,
      57,
      1,
      58,
      1,
      58,
      3,
      58,
      465,
      8,
      58,
      1,
      59,
      1,
      59,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      3,
      60,
      492,
      8,
      60,
      1,
      60,
      3,
      60,
      495,
      8,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      3,
      60,
      501,
      8,
      60,
      1,
      61,
      1,
      61,
      1,
      457,
      0,
      62,
      1,
      1,
      3,
      2,
      5,
      3,
      7,
      4,
      9,
      5,
      11,
      6,
      13,
      7,
      15,
      8,
      17,
      9,
      19,
      10,
      21,
      11,
      23,
      12,
      25,
      13,
      27,
      14,
      29,
      15,
      31,
      16,
      33,
      17,
      35,
      18,
      37,
      19,
      39,
      20,
      41,
      21,
      43,
      22,
      45,
      23,
      47,
      24,
      49,
      25,
      51,
      26,
      53,
      27,
      55,
      28,
      57,
      29,
      59,
      30,
      61,
      31,
      63,
      32,
      65,
      33,
      67,
      34,
      69,
      35,
      71,
      36,
      73,
      37,
      75,
      38,
      77,
      0,
      79,
      0,
      81,
      39,
      83,
      40,
      85,
      41,
      87,
      42,
      89,
      0,
      91,
      0,
      93,
      0,
      95,
      43,
      97,
      0,
      99,
      44,
      101,
      45,
      103,
      46,
      105,
      0,
      107,
      47,
      109,
      48,
      111,
      49,
      113,
      0,
      115,
      0,
      117,
      0,
      119,
      0,
      121,
      0,
      123,
      0,
      1,
      0,
      12,
      3,
      0,
      9,
      10,
      12,
      13,
      32,
      32,
      1,
      0,
      10,
      10,
      2,
      0,
      65,
      90,
      97,
      122,
      4,
      0,
      100,
      100,
      104,
      104,
      109,
      109,
      115,
      115,
      2,
      0,
      69,
      69,
      101,
      101,
      2,
      0,
      43,
      43,
      45,
      45,
      2,
      0,
      58,
      58,
      95,
      95,
      4,
      0,
      37,
      37,
      45,
      46,
      95,
      95,
      126,
      126,
      2,
      0,
      39,
      39,
      92,
      92,
      2,
      0,
      34,
      34,
      92,
      92,
      1,
      0,
      92,
      92,
      2,
      0,
      48,
      57,
      97,
      102,
      542,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      3,
      1,
      0,
      0,
      0,
      0,
      5,
      1,
      0,
      0,
      0,
      0,
      7,
      1,
      0,
      0,
      0,
      0,
      9,
      1,
      0,
      0,
      0,
      0,
      11,
      1,
      0,
      0,
      0,
      0,
      13,
      1,
      0,
      0,
      0,
      0,
      15,
      1,
      0,
      0,
      0,
      0,
      17,
      1,
      0,
      0,
      0,
      0,
      19,
      1,
      0,
      0,
      0,
      0,
      21,
      1,
      0,
      0,
      0,
      0,
      23,
      1,
      0,
      0,
      0,
      0,
      25,
      1,
      0,
      0,
      0,
      0,
      27,
      1,
      0,
      0,
      0,
      0,
      29,
      1,
      0,
      0,
      0,
      0,
      31,
      1,
      0,
      0,
      0,
      0,
      33,
      1,
      0,
      0,
      0,
      0,
      35,
      1,
      0,
      0,
      0,
      0,
      37,
      1,
      0,
      0,
      0,
      0,
      39,
      1,
      0,
      0,
      0,
      0,
      41,
      1,
      0,
      0,
      0,
      0,
      43,
      1,
      0,
      0,
      0,
      0,
      45,
      1,
      0,
      0,
      0,
      0,
      47,
      1,
      0,
      0,
      0,
      0,
      49,
      1,
      0,
      0,
      0,
      0,
      51,
      1,
      0,
      0,
      0,
      0,
      53,
      1,
      0,
      0,
      0,
      0,
      55,
      1,
      0,
      0,
      0,
      0,
      57,
      1,
      0,
      0,
      0,
      0,
      59,
      1,
      0,
      0,
      0,
      0,
      61,
      1,
      0,
      0,
      0,
      0,
      63,
      1,
      0,
      0,
      0,
      0,
      65,
      1,
      0,
      0,
      0,
      0,
      67,
      1,
      0,
      0,
      0,
      0,
      69,
      1,
      0,
      0,
      0,
      0,
      71,
      1,
      0,
      0,
      0,
      0,
      73,
      1,
      0,
      0,
      0,
      0,
      75,
      1,
      0,
      0,
      0,
      0,
      81,
      1,
      0,
      0,
      0,
      0,
      83,
      1,
      0,
      0,
      0,
      0,
      85,
      1,
      0,
      0,
      0,
      0,
      87,
      1,
      0,
      0,
      0,
      0,
      95,
      1,
      0,
      0,
      0,
      0,
      99,
      1,
      0,
      0,
      0,
      0,
      101,
      1,
      0,
      0,
      0,
      0,
      103,
      1,
      0,
      0,
      0,
      0,
      107,
      1,
      0,
      0,
      0,
      0,
      109,
      1,
      0,
      0,
      0,
      0,
      111,
      1,
      0,
      0,
      0,
      1,
      125,
      1,
      0,
      0,
      0,
      3,
      134,
      1,
      0,
      0,
      0,
      5,
      136,
      1,
      0,
      0,
      0,
      7,
      142,
      1,
      0,
      0,
      0,
      9,
      152,
      1,
      0,
      0,
      0,
      11,
      156,
      1,
      0,
      0,
      0,
      13,
      158,
      1,
      0,
      0,
      0,
      15,
      163,
      1,
      0,
      0,
      0,
      17,
      169,
      1,
      0,
      0,
      0,
      19,
      178,
      1,
      0,
      0,
      0,
      21,
      180,
      1,
      0,
      0,
      0,
      23,
      188,
      1,
      0,
      0,
      0,
      25,
      192,
      1,
      0,
      0,
      0,
      27,
      197,
      1,
      0,
      0,
      0,
      29,
      203,
      1,
      0,
      0,
      0,
      31,
      207,
      1,
      0,
      0,
      0,
      33,
      210,
      1,
      0,
      0,
      0,
      35,
      212,
      1,
      0,
      0,
      0,
      37,
      214,
      1,
      0,
      0,
      0,
      39,
      216,
      1,
      0,
      0,
      0,
      41,
      218,
      1,
      0,
      0,
      0,
      43,
      220,
      1,
      0,
      0,
      0,
      45,
      222,
      1,
      0,
      0,
      0,
      47,
      224,
      1,
      0,
      0,
      0,
      49,
      227,
      1,
      0,
      0,
      0,
      51,
      229,
      1,
      0,
      0,
      0,
      53,
      231,
      1,
      0,
      0,
      0,
      55,
      234,
      1,
      0,
      0,
      0,
      57,
      236,
      1,
      0,
      0,
      0,
      59,
      239,
      1,
      0,
      0,
      0,
      61,
      241,
      1,
      0,
      0,
      0,
      63,
      244,
      1,
      0,
      0,
      0,
      65,
      246,
      1,
      0,
      0,
      0,
      67,
      249,
      1,
      0,
      0,
      0,
      69,
      251,
      1,
      0,
      0,
      0,
      71,
      254,
      1,
      0,
      0,
      0,
      73,
      257,
      1,
      0,
      0,
      0,
      75,
      260,
      1,
      0,
      0,
      0,
      77,
      263,
      1,
      0,
      0,
      0,
      79,
      265,
      1,
      0,
      0,
      0,
      81,
      267,
      1,
      0,
      0,
      0,
      83,
      300,
      1,
      0,
      0,
      0,
      85,
      310,
      1,
      0,
      0,
      0,
      87,
      348,
      1,
      0,
      0,
      0,
      89,
      350,
      1,
      0,
      0,
      0,
      91,
      359,
      1,
      0,
      0,
      0,
      93,
      363,
      1,
      0,
      0,
      0,
      95,
      373,
      1,
      0,
      0,
      0,
      97,
      378,
      1,
      0,
      0,
      0,
      99,
      381,
      1,
      0,
      0,
      0,
      101,
      392,
      1,
      0,
      0,
      0,
      103,
      401,
      1,
      0,
      0,
      0,
      105,
      407,
      1,
      0,
      0,
      0,
      107,
      409,
      1,
      0,
      0,
      0,
      109,
      428,
      1,
      0,
      0,
      0,
      111,
      430,
      1,
      0,
      0,
      0,
      113,
      451,
      1,
      0,
      0,
      0,
      115,
      453,
      1,
      0,
      0,
      0,
      117,
      464,
      1,
      0,
      0,
      0,
      119,
      466,
      1,
      0,
      0,
      0,
      121,
      500,
      1,
      0,
      0,
      0,
      123,
      502,
      1,
      0,
      0,
      0,
      125,
      126,
      5,
      116,
      0,
      0,
      126,
      127,
      5,
      101,
      0,
      0,
      127,
      128,
      5,
      109,
      0,
      0,
      128,
      129,
      5,
      112,
      0,
      0,
      129,
      130,
      5,
      111,
      0,
      0,
      130,
      131,
      5,
      114,
      0,
      0,
      131,
      132,
      5,
      97,
      0,
      0,
      132,
      133,
      5,
      108,
      0,
      0,
      133,
      2,
      1,
      0,
      0,
      0,
      134,
      135,
      5,
      46,
      0,
      0,
      135,
      4,
      1,
      0,
      0,
      0,
      136,
      137,
      5,
      100,
      0,
      0,
      137,
      138,
      5,
      101,
      0,
      0,
      138,
      139,
      5,
      115,
      0,
      0,
      139,
      140,
      5,
      99,
      0,
      0,
      140,
      141,
      5,
      114,
      0,
      0,
      141,
      6,
      1,
      0,
      0,
      0,
      142,
      143,
      5,
      105,
      0,
      0,
      143,
      144,
      5,
      110,
      0,
      0,
      144,
      145,
      5,
      99,
      0,
      0,
      145,
      146,
      5,
      108,
      0,
      0,
      146,
      147,
      5,
      117,
      0,
      0,
      147,
      148,
      5,
      115,
      0,
      0,
      148,
      149,
      5,
      105,
      0,
      0,
      149,
      150,
      5,
      111,
      0,
      0,
      150,
      151,
      5,
      110,
      0,
      0,
      151,
      8,
      1,
      0,
      0,
      0,
      152,
      153,
      5,
      110,
      0,
      0,
      153,
      154,
      5,
      111,
      0,
      0,
      154,
      155,
      5,
      119,
      0,
      0,
      155,
      10,
      1,
      0,
      0,
      0,
      156,
      157,
      5,
      58,
      0,
      0,
      157,
      12,
      1,
      0,
      0,
      0,
      158,
      159,
      5,
      111,
      0,
      0,
      159,
      160,
      5,
      112,
      0,
      0,
      160,
      161,
      5,
      116,
      0,
      0,
      161,
      14,
      1,
      0,
      0,
      0,
      162,
      164,
      7,
      0,
      0,
      0,
      163,
      162,
      1,
      0,
      0,
      0,
      164,
      165,
      1,
      0,
      0,
      0,
      165,
      163,
      1,
      0,
      0,
      0,
      165,
      166,
      1,
      0,
      0,
      0,
      166,
      167,
      1,
      0,
      0,
      0,
      167,
      168,
      6,
      7,
      0,
      0,
      168,
      16,
      1,
      0,
      0,
      0,
      169,
      173,
      5,
      35,
      0,
      0,
      170,
      172,
      8,
      1,
      0,
      0,
      171,
      170,
      1,
      0,
      0,
      0,
      172,
      175,
      1,
      0,
      0,
      0,
      173,
      171,
      1,
      0,
      0,
      0,
      173,
      174,
      1,
      0,
      0,
      0,
      174,
      176,
      1,
      0,
      0,
      0,
      175,
      173,
      1,
      0,
      0,
      0,
      176,
      177,
      6,
      8,
      0,
      0,
      177,
      18,
      1,
      0,
      0,
      0,
      178,
      179,
      5,
      10232,
      0,
      0,
      179,
      20,
      1,
      0,
      0,
      0,
      180,
      181,
      5,
      80,
      0,
      0,
      181,
      182,
      5,
      97,
      0,
      0,
      182,
      183,
      5,
      99,
      0,
      0,
      183,
      184,
      5,
      107,
      0,
      0,
      184,
      185,
      5,
      97,
      0,
      0,
      185,
      186,
      5,
      103,
      0,
      0,
      186,
      187,
      5,
      101,
      0,
      0,
      187,
      22,
      1,
      0,
      0,
      0,
      188,
      189,
      5,
      85,
      0,
      0,
      189,
      190,
      5,
      115,
      0,
      0,
      190,
      191,
      5,
      101,
      0,
      0,
      191,
      24,
      1,
      0,
      0,
      0,
      192,
      193,
      5,
      68,
      0,
      0,
      193,
      194,
      5,
      101,
      0,
      0,
      194,
      195,
      5,
      99,
      0,
      0,
      195,
      196,
      5,
      108,
      0,
      0,
      196,
      26,
      1,
      0,
      0,
      0,
      197,
      198,
      5,
      98,
      0,
      0,
      198,
      199,
      5,
      111,
      0,
      0,
      199,
      200,
      5,
      117,
      0,
      0,
      200,
      201,
      5,
      110,
      0,
      0,
      201,
      202,
      5,
      100,
      0,
      0,
      202,
      28,
      1,
      0,
      0,
      0,
      203,
      204,
      5,
      108,
      0,
      0,
      204,
      205,
      5,
      101,
      0,
      0,
      205,
      206,
      5,
      116,
      0,
      0,
      206,
      30,
      1,
      0,
      0,
      0,
      207,
      208,
      5,
      100,
      0,
      0,
      208,
      209,
      5,
      111,
      0,
      0,
      209,
      32,
      1,
      0,
      0,
      0,
      210,
      211,
      5,
      40,
      0,
      0,
      211,
      34,
      1,
      0,
      0,
      0,
      212,
      213,
      5,
      41,
      0,
      0,
      213,
      36,
      1,
      0,
      0,
      0,
      214,
      215,
      5,
      91,
      0,
      0,
      215,
      38,
      1,
      0,
      0,
      0,
      216,
      217,
      5,
      93,
      0,
      0,
      217,
      40,
      1,
      0,
      0,
      0,
      218,
      219,
      5,
      123,
      0,
      0,
      219,
      42,
      1,
      0,
      0,
      0,
      220,
      221,
      5,
      125,
      0,
      0,
      221,
      44,
      1,
      0,
      0,
      0,
      222,
      223,
      5,
      61,
      0,
      0,
      223,
      46,
      1,
      0,
      0,
      0,
      224,
      225,
      5,
      33,
      0,
      0,
      225,
      226,
      5,
      61,
      0,
      0,
      226,
      48,
      1,
      0,
      0,
      0,
      227,
      228,
      5,
      44,
      0,
      0,
      228,
      50,
      1,
      0,
      0,
      0,
      229,
      230,
      5,
      33,
      0,
      0,
      230,
      52,
      1,
      0,
      0,
      0,
      231,
      232,
      5,
      60,
      0,
      0,
      232,
      233,
      5,
      61,
      0,
      0,
      233,
      54,
      1,
      0,
      0,
      0,
      234,
      235,
      5,
      60,
      0,
      0,
      235,
      56,
      1,
      0,
      0,
      0,
      236,
      237,
      5,
      62,
      0,
      0,
      237,
      238,
      5,
      61,
      0,
      0,
      238,
      58,
      1,
      0,
      0,
      0,
      239,
      240,
      5,
      62,
      0,
      0,
      240,
      60,
      1,
      0,
      0,
      0,
      241,
      242,
      5,
      58,
      0,
      0,
      242,
      243,
      5,
      45,
      0,
      0,
      243,
      62,
      1,
      0,
      0,
      0,
      244,
      245,
      5,
      10,
      0,
      0,
      245,
      64,
      1,
      0,
      0,
      0,
      246,
      247,
      5,
      124,
      0,
      0,
      247,
      248,
      5,
      62,
      0,
      0,
      248,
      66,
      1,
      0,
      0,
      0,
      249,
      250,
      5,
      64,
      0,
      0,
      250,
      68,
      1,
      0,
      0,
      0,
      251,
      252,
      5,
      60,
      0,
      0,
      252,
      253,
      5,
      45,
      0,
      0,
      253,
      70,
      1,
      0,
      0,
      0,
      254,
      255,
      5,
      60,
      0,
      0,
      255,
      256,
      5,
      43,
      0,
      0,
      256,
      72,
      1,
      0,
      0,
      0,
      257,
      258,
      5,
      91,
      0,
      0,
      258,
      259,
      5,
      45,
      0,
      0,
      259,
      74,
      1,
      0,
      0,
      0,
      260,
      261,
      5,
      91,
      0,
      0,
      261,
      262,
      5,
      43,
      0,
      0,
      262,
      76,
      1,
      0,
      0,
      0,
      263,
      264,
      7,
      2,
      0,
      0,
      264,
      78,
      1,
      0,
      0,
      0,
      265,
      266,
      2,
      48,
      57,
      0,
      266,
      80,
      1,
      0,
      0,
      0,
      267,
      268,
      3,
      79,
      39,
      0,
      268,
      269,
      3,
      79,
      39,
      0,
      269,
      270,
      3,
      79,
      39,
      0,
      270,
      271,
      3,
      79,
      39,
      0,
      271,
      272,
      5,
      45,
      0,
      0,
      272,
      273,
      3,
      79,
      39,
      0,
      273,
      274,
      3,
      79,
      39,
      0,
      274,
      275,
      5,
      45,
      0,
      0,
      275,
      276,
      3,
      79,
      39,
      0,
      276,
      297,
      3,
      79,
      39,
      0,
      277,
      278,
      5,
      84,
      0,
      0,
      278,
      279,
      3,
      79,
      39,
      0,
      279,
      280,
      3,
      79,
      39,
      0,
      280,
      281,
      5,
      58,
      0,
      0,
      281,
      282,
      3,
      79,
      39,
      0,
      282,
      283,
      3,
      79,
      39,
      0,
      283,
      284,
      5,
      58,
      0,
      0,
      284,
      285,
      3,
      79,
      39,
      0,
      285,
      292,
      3,
      79,
      39,
      0,
      286,
      288,
      5,
      46,
      0,
      0,
      287,
      289,
      3,
      79,
      39,
      0,
      288,
      287,
      1,
      0,
      0,
      0,
      289,
      290,
      1,
      0,
      0,
      0,
      290,
      288,
      1,
      0,
      0,
      0,
      290,
      291,
      1,
      0,
      0,
      0,
      291,
      293,
      1,
      0,
      0,
      0,
      292,
      286,
      1,
      0,
      0,
      0,
      292,
      293,
      1,
      0,
      0,
      0,
      293,
      295,
      1,
      0,
      0,
      0,
      294,
      296,
      5,
      90,
      0,
      0,
      295,
      294,
      1,
      0,
      0,
      0,
      295,
      296,
      1,
      0,
      0,
      0,
      296,
      298,
      1,
      0,
      0,
      0,
      297,
      277,
      1,
      0,
      0,
      0,
      297,
      298,
      1,
      0,
      0,
      0,
      298,
      82,
      1,
      0,
      0,
      0,
      299,
      301,
      3,
      79,
      39,
      0,
      300,
      299,
      1,
      0,
      0,
      0,
      301,
      302,
      1,
      0,
      0,
      0,
      302,
      300,
      1,
      0,
      0,
      0,
      302,
      303,
      1,
      0,
      0,
      0,
      303,
      307,
      1,
      0,
      0,
      0,
      304,
      308,
      7,
      3,
      0,
      0,
      305,
      306,
      5,
      109,
      0,
      0,
      306,
      308,
      5,
      115,
      0,
      0,
      307,
      304,
      1,
      0,
      0,
      0,
      307,
      305,
      1,
      0,
      0,
      0,
      308,
      84,
      1,
      0,
      0,
      0,
      309,
      311,
      5,
      45,
      0,
      0,
      310,
      309,
      1,
      0,
      0,
      0,
      310,
      311,
      1,
      0,
      0,
      0,
      311,
      312,
      1,
      0,
      0,
      0,
      312,
      316,
      3,
      79,
      39,
      0,
      313,
      315,
      3,
      79,
      39,
      0,
      314,
      313,
      1,
      0,
      0,
      0,
      315,
      318,
      1,
      0,
      0,
      0,
      316,
      314,
      1,
      0,
      0,
      0,
      316,
      317,
      1,
      0,
      0,
      0,
      317,
      86,
      1,
      0,
      0,
      0,
      318,
      316,
      1,
      0,
      0,
      0,
      319,
      321,
      5,
      45,
      0,
      0,
      320,
      319,
      1,
      0,
      0,
      0,
      320,
      321,
      1,
      0,
      0,
      0,
      321,
      323,
      1,
      0,
      0,
      0,
      322,
      324,
      3,
      79,
      39,
      0,
      323,
      322,
      1,
      0,
      0,
      0,
      324,
      325,
      1,
      0,
      0,
      0,
      325,
      323,
      1,
      0,
      0,
      0,
      325,
      326,
      1,
      0,
      0,
      0,
      326,
      327,
      1,
      0,
      0,
      0,
      327,
      329,
      5,
      46,
      0,
      0,
      328,
      330,
      3,
      79,
      39,
      0,
      329,
      328,
      1,
      0,
      0,
      0,
      330,
      331,
      1,
      0,
      0,
      0,
      331,
      329,
      1,
      0,
      0,
      0,
      331,
      332,
      1,
      0,
      0,
      0,
      332,
      334,
      1,
      0,
      0,
      0,
      333,
      335,
      3,
      89,
      44,
      0,
      334,
      333,
      1,
      0,
      0,
      0,
      334,
      335,
      1,
      0,
      0,
      0,
      335,
      349,
      1,
      0,
      0,
      0,
      336,
      338,
      5,
      45,
      0,
      0,
      337,
      336,
      1,
      0,
      0,
      0,
      337,
      338,
      1,
      0,
      0,
      0,
      338,
      339,
      1,
      0,
      0,
      0,
      339,
      341,
      5,
      46,
      0,
      0,
      340,
      342,
      3,
      79,
      39,
      0,
      341,
      340,
      1,
      0,
      0,
      0,
      342,
      343,
      1,
      0,
      0,
      0,
      343,
      341,
      1,
      0,
      0,
      0,
      343,
      344,
      1,
      0,
      0,
      0,
      344,
      346,
      1,
      0,
      0,
      0,
      345,
      347,
      3,
      89,
      44,
      0,
      346,
      345,
      1,
      0,
      0,
      0,
      346,
      347,
      1,
      0,
      0,
      0,
      347,
      349,
      1,
      0,
      0,
      0,
      348,
      320,
      1,
      0,
      0,
      0,
      348,
      337,
      1,
      0,
      0,
      0,
      349,
      88,
      1,
      0,
      0,
      0,
      350,
      352,
      7,
      4,
      0,
      0,
      351,
      353,
      7,
      5,
      0,
      0,
      352,
      351,
      1,
      0,
      0,
      0,
      352,
      353,
      1,
      0,
      0,
      0,
      353,
      355,
      1,
      0,
      0,
      0,
      354,
      356,
      3,
      79,
      39,
      0,
      355,
      354,
      1,
      0,
      0,
      0,
      356,
      357,
      1,
      0,
      0,
      0,
      357,
      355,
      1,
      0,
      0,
      0,
      357,
      358,
      1,
      0,
      0,
      0,
      358,
      90,
      1,
      0,
      0,
      0,
      359,
      360,
      2,
      65,
      90,
      0,
      360,
      92,
      1,
      0,
      0,
      0,
      361,
      364,
      3,
      77,
      38,
      0,
      362,
      364,
      3,
      79,
      39,
      0,
      363,
      361,
      1,
      0,
      0,
      0,
      363,
      362,
      1,
      0,
      0,
      0,
      364,
      94,
      1,
      0,
      0,
      0,
      365,
      374,
      5,
      95,
      0,
      0,
      366,
      370,
      3,
      91,
      45,
      0,
      367,
      369,
      3,
      93,
      46,
      0,
      368,
      367,
      1,
      0,
      0,
      0,
      369,
      372,
      1,
      0,
      0,
      0,
      370,
      368,
      1,
      0,
      0,
      0,
      370,
      371,
      1,
      0,
      0,
      0,
      371,
      374,
      1,
      0,
      0,
      0,
      372,
      370,
      1,
      0,
      0,
      0,
      373,
      365,
      1,
      0,
      0,
      0,
      373,
      366,
      1,
      0,
      0,
      0,
      374,
      96,
      1,
      0,
      0,
      0,
      375,
      379,
      3,
      77,
      38,
      0,
      376,
      379,
      3,
      79,
      39,
      0,
      377,
      379,
      7,
      6,
      0,
      0,
      378,
      375,
      1,
      0,
      0,
      0,
      378,
      376,
      1,
      0,
      0,
      0,
      378,
      377,
      1,
      0,
      0,
      0,
      379,
      98,
      1,
      0,
      0,
      0,
      380,
      382,
      5,
      58,
      0,
      0,
      381,
      380,
      1,
      0,
      0,
      0,
      381,
      382,
      1,
      0,
      0,
      0,
      382,
      383,
      1,
      0,
      0,
      0,
      383,
      389,
      2,
      97,
      122,
      0,
      384,
      388,
      3,
      97,
      48,
      0,
      385,
      386,
      5,
      46,
      0,
      0,
      386,
      388,
      3,
      97,
      48,
      0,
      387,
      384,
      1,
      0,
      0,
      0,
      387,
      385,
      1,
      0,
      0,
      0,
      388,
      391,
      1,
      0,
      0,
      0,
      389,
      387,
      1,
      0,
      0,
      0,
      389,
      390,
      1,
      0,
      0,
      0,
      390,
      100,
      1,
      0,
      0,
      0,
      391,
      389,
      1,
      0,
      0,
      0,
      392,
      398,
      2,
      65,
      90,
      0,
      393,
      397,
      3,
      97,
      48,
      0,
      394,
      395,
      5,
      46,
      0,
      0,
      395,
      397,
      3,
      97,
      48,
      0,
      396,
      393,
      1,
      0,
      0,
      0,
      396,
      394,
      1,
      0,
      0,
      0,
      397,
      400,
      1,
      0,
      0,
      0,
      398,
      396,
      1,
      0,
      0,
      0,
      398,
      399,
      1,
      0,
      0,
      0,
      399,
      102,
      1,
      0,
      0,
      0,
      400,
      398,
      1,
      0,
      0,
      0,
      401,
      402,
      5,
      46,
      0,
      0,
      402,
      403,
      3,
      101,
      50,
      0,
      403,
      104,
      1,
      0,
      0,
      0,
      404,
      408,
      3,
      77,
      38,
      0,
      405,
      408,
      3,
      79,
      39,
      0,
      406,
      408,
      7,
      7,
      0,
      0,
      407,
      404,
      1,
      0,
      0,
      0,
      407,
      405,
      1,
      0,
      0,
      0,
      407,
      406,
      1,
      0,
      0,
      0,
      408,
      106,
      1,
      0,
      0,
      0,
      409,
      411,
      5,
      47,
      0,
      0,
      410,
      412,
      3,
      105,
      52,
      0,
      411,
      410,
      1,
      0,
      0,
      0,
      412,
      413,
      1,
      0,
      0,
      0,
      413,
      411,
      1,
      0,
      0,
      0,
      413,
      414,
      1,
      0,
      0,
      0,
      414,
      423,
      1,
      0,
      0,
      0,
      415,
      417,
      5,
      47,
      0,
      0,
      416,
      418,
      3,
      105,
      52,
      0,
      417,
      416,
      1,
      0,
      0,
      0,
      418,
      419,
      1,
      0,
      0,
      0,
      419,
      417,
      1,
      0,
      0,
      0,
      419,
      420,
      1,
      0,
      0,
      0,
      420,
      422,
      1,
      0,
      0,
      0,
      421,
      415,
      1,
      0,
      0,
      0,
      422,
      425,
      1,
      0,
      0,
      0,
      423,
      421,
      1,
      0,
      0,
      0,
      423,
      424,
      1,
      0,
      0,
      0,
      424,
      108,
      1,
      0,
      0,
      0,
      425,
      423,
      1,
      0,
      0,
      0,
      426,
      429,
      3,
      113,
      56,
      0,
      427,
      429,
      3,
      115,
      57,
      0,
      428,
      426,
      1,
      0,
      0,
      0,
      428,
      427,
      1,
      0,
      0,
      0,
      429,
      110,
      1,
      0,
      0,
      0,
      430,
      431,
      5,
      98,
      0,
      0,
      431,
      432,
      3,
      109,
      54,
      0,
      432,
      112,
      1,
      0,
      0,
      0,
      433,
      438,
      5,
      39,
      0,
      0,
      434,
      437,
      3,
      121,
      60,
      0,
      435,
      437,
      8,
      8,
      0,
      0,
      436,
      434,
      1,
      0,
      0,
      0,
      436,
      435,
      1,
      0,
      0,
      0,
      437,
      440,
      1,
      0,
      0,
      0,
      438,
      436,
      1,
      0,
      0,
      0,
      438,
      439,
      1,
      0,
      0,
      0,
      439,
      441,
      1,
      0,
      0,
      0,
      440,
      438,
      1,
      0,
      0,
      0,
      441,
      452,
      5,
      39,
      0,
      0,
      442,
      447,
      5,
      34,
      0,
      0,
      443,
      446,
      3,
      121,
      60,
      0,
      444,
      446,
      8,
      9,
      0,
      0,
      445,
      443,
      1,
      0,
      0,
      0,
      445,
      444,
      1,
      0,
      0,
      0,
      446,
      449,
      1,
      0,
      0,
      0,
      447,
      445,
      1,
      0,
      0,
      0,
      447,
      448,
      1,
      0,
      0,
      0,
      448,
      450,
      1,
      0,
      0,
      0,
      449,
      447,
      1,
      0,
      0,
      0,
      450,
      452,
      5,
      34,
      0,
      0,
      451,
      433,
      1,
      0,
      0,
      0,
      451,
      442,
      1,
      0,
      0,
      0,
      452,
      114,
      1,
      0,
      0,
      0,
      453,
      457,
      5,
      96,
      0,
      0,
      454,
      456,
      3,
      117,
      58,
      0,
      455,
      454,
      1,
      0,
      0,
      0,
      456,
      459,
      1,
      0,
      0,
      0,
      457,
      458,
      1,
      0,
      0,
      0,
      457,
      455,
      1,
      0,
      0,
      0,
      458,
      460,
      1,
      0,
      0,
      0,
      459,
      457,
      1,
      0,
      0,
      0,
      460,
      461,
      5,
      96,
      0,
      0,
      461,
      116,
      1,
      0,
      0,
      0,
      462,
      465,
      3,
      119,
      59,
      0,
      463,
      465,
      3,
      121,
      60,
      0,
      464,
      462,
      1,
      0,
      0,
      0,
      464,
      463,
      1,
      0,
      0,
      0,
      465,
      118,
      1,
      0,
      0,
      0,
      466,
      467,
      8,
      10,
      0,
      0,
      467,
      120,
      1,
      0,
      0,
      0,
      468,
      469,
      5,
      92,
      0,
      0,
      469,
      501,
      5,
      110,
      0,
      0,
      470,
      471,
      5,
      92,
      0,
      0,
      471,
      501,
      5,
      116,
      0,
      0,
      472,
      473,
      5,
      92,
      0,
      0,
      473,
      501,
      5,
      34,
      0,
      0,
      474,
      475,
      5,
      92,
      0,
      0,
      475,
      501,
      5,
      39,
      0,
      0,
      476,
      477,
      5,
      92,
      0,
      0,
      477,
      501,
      5,
      92,
      0,
      0,
      478,
      479,
      5,
      92,
      0,
      0,
      479,
      480,
      5,
      120,
      0,
      0,
      480,
      481,
      3,
      123,
      61,
      0,
      481,
      482,
      3,
      123,
      61,
      0,
      482,
      501,
      1,
      0,
      0,
      0,
      483,
      484,
      5,
      92,
      0,
      0,
      484,
      485,
      5,
      117,
      0,
      0,
      485,
      486,
      5,
      123,
      0,
      0,
      486,
      487,
      3,
      123,
      61,
      0,
      487,
      488,
      3,
      123,
      61,
      0,
      488,
      489,
      3,
      123,
      61,
      0,
      489,
      491,
      3,
      123,
      61,
      0,
      490,
      492,
      3,
      123,
      61,
      0,
      491,
      490,
      1,
      0,
      0,
      0,
      491,
      492,
      1,
      0,
      0,
      0,
      492,
      494,
      1,
      0,
      0,
      0,
      493,
      495,
      3,
      123,
      61,
      0,
      494,
      493,
      1,
      0,
      0,
      0,
      494,
      495,
      1,
      0,
      0,
      0,
      495,
      496,
      1,
      0,
      0,
      0,
      496,
      497,
      5,
      125,
      0,
      0,
      497,
      501,
      1,
      0,
      0,
      0,
      498,
      499,
      5,
      92,
      0,
      0,
      499,
      501,
      3,
      63,
      31,
      0,
      500,
      468,
      1,
      0,
      0,
      0,
      500,
      470,
      1,
      0,
      0,
      0,
      500,
      472,
      1,
      0,
      0,
      0,
      500,
      474,
      1,
      0,
      0,
      0,
      500,
      476,
      1,
      0,
      0,
      0,
      500,
      478,
      1,
      0,
      0,
      0,
      500,
      483,
      1,
      0,
      0,
      0,
      500,
      498,
      1,
      0,
      0,
      0,
      501,
      122,
      1,
      0,
      0,
      0,
      502,
      503,
      7,
      11,
      0,
      0,
      503,
      124,
      1,
      0,
      0,
      0,
      45,
      0,
      165,
      173,
      290,
      292,
      295,
      297,
      302,
      307,
      310,
      316,
      320,
      325,
      331,
      334,
      337,
      343,
      346,
      348,
      352,
      357,
      363,
      370,
      373,
      378,
      381,
      387,
      389,
      396,
      398,
      407,
      413,
      419,
      423,
      428,
      436,
      438,
      445,
      447,
      451,
      457,
      464,
      491,
      494,
      500,
      1,
      0,
      1,
      0
    ];
    MangleLexer.vocabulary = new antlr.Vocabulary(MangleLexer.literalNames, MangleLexer.symbolicNames, []);
    MangleLexer.decisionsToDFA = MangleLexer._ATN.decisionToState.map((ds, index) => new antlr.DFA(ds, index));
  }
});

// server/parser/gen/MangleParser.js
var require_MangleParser = __commonJS({
  "server/parser/gen/MangleParser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AtomsContext = exports2.AtomContext = exports2.MemberContext = exports2.DotTypeContext = exports2.StructContext = exports2.MapContext = exports2.ListContext = exports2.NumContext = exports2.ConstContext = exports2.VarContext = exports2.ApplContext = exports2.FloatContext = exports2.BStrContext = exports2.StrContext = exports2.TermContext = exports2.TemporalOperatorContext = exports2.LiteralOrFmlContext = exports2.LetStmtContext = exports2.TransformContext = exports2.ClauseBodyContext = exports2.TemporalBoundContext = exports2.TemporalAnnotationContext = exports2.ClauseContext = exports2.ConstraintsBlockContext = exports2.BoundsBlockContext = exports2.DescrBlockContext = exports2.DeclContext = exports2.UseDeclContext = exports2.PackageDeclContext = exports2.ProgramContext = exports2.StartContext = exports2.MangleParser = void 0;
    var antlr = __importStar(require_dist());
    var MangleParser = class _MangleParser extends antlr.Parser {
      get grammarFileName() {
        return "Mangle.g4";
      }
      get literalNames() {
        return _MangleParser.literalNames;
      }
      get symbolicNames() {
        return _MangleParser.symbolicNames;
      }
      get ruleNames() {
        return _MangleParser.ruleNames;
      }
      get serializedATN() {
        return _MangleParser._serializedATN;
      }
      createFailedPredicateException(predicate, message) {
        return new antlr.FailedPredicateException(this, predicate, message);
      }
      constructor(input) {
        super(input);
        this.interpreter = new antlr.ParserATNSimulator(this, _MangleParser._ATN, _MangleParser.decisionsToDFA, new antlr.PredictionContextCache());
      }
      start() {
        let localContext = new StartContext(this.context, this.state);
        this.enterRule(localContext, 0, _MangleParser.RULE_start);
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 40;
            this.program();
            this.state = 41;
            this.match(_MangleParser.EOF);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      program() {
        let localContext = new ProgramContext(this.context, this.state);
        this.enterRule(localContext, 2, _MangleParser.RULE_program);
        let _la;
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 44;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 11) {
              {
                this.state = 43;
                this.packageDecl();
              }
            }
            this.state = 49;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            while (_la === 12) {
              {
                {
                  this.state = 46;
                  this.useDecl();
                }
              }
              this.state = 51;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
            }
            this.state = 56;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & 2629632) !== 0 || (_la - 41 & ~31) === 0 && (1 << _la - 41 & 495) !== 0) {
              {
                this.state = 54;
                this.errorHandler.sync(this);
                switch (this.tokenStream.LA(1)) {
                  case _MangleParser.DECL:
                    {
                      this.state = 52;
                      this.decl();
                    }
                    break;
                  case _MangleParser.LBRACKET:
                  case _MangleParser.LBRACE:
                  case _MangleParser.NUMBER:
                  case _MangleParser.FLOAT:
                  case _MangleParser.VARIABLE:
                  case _MangleParser.NAME:
                  case _MangleParser.DOT_TYPE:
                  case _MangleParser.CONSTANT:
                  case _MangleParser.STRING:
                  case _MangleParser.BYTESTRING:
                    {
                      this.state = 53;
                      this.clause();
                    }
                    break;
                  default:
                    throw new antlr.NoViableAltException(this);
                }
              }
              this.state = 58;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      packageDecl() {
        let localContext = new PackageDeclContext(this.context, this.state);
        this.enterRule(localContext, 4, _MangleParser.RULE_packageDecl);
        let _la;
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 59;
            this.match(_MangleParser.PACKAGE);
            this.state = 60;
            this.match(_MangleParser.NAME);
            this.state = 62;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 19) {
              {
                this.state = 61;
                this.atoms();
              }
            }
            this.state = 64;
            this.match(_MangleParser.BANG);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      useDecl() {
        let localContext = new UseDeclContext(this.context, this.state);
        this.enterRule(localContext, 6, _MangleParser.RULE_useDecl);
        let _la;
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 66;
            this.match(_MangleParser.USE);
            this.state = 67;
            this.match(_MangleParser.NAME);
            this.state = 69;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 19) {
              {
                this.state = 68;
                this.atoms();
              }
            }
            this.state = 71;
            this.match(_MangleParser.BANG);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      decl() {
        let localContext = new DeclContext(this.context, this.state);
        this.enterRule(localContext, 8, _MangleParser.RULE_decl);
        let _la;
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 73;
            this.match(_MangleParser.DECL);
            this.state = 74;
            this.atom();
            this.state = 76;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 1) {
              {
                this.state = 75;
                this.match(_MangleParser.T__0);
              }
            }
            this.state = 79;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 3) {
              {
                this.state = 78;
                this.descrBlock();
              }
            }
            this.state = 84;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            while (_la === 14) {
              {
                {
                  this.state = 81;
                  this.boundsBlock();
                }
              }
              this.state = 86;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
            }
            this.state = 88;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 4) {
              {
                this.state = 87;
                this.constraintsBlock();
              }
            }
            this.state = 90;
            this.match(_MangleParser.T__1);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      descrBlock() {
        let localContext = new DescrBlockContext(this.context, this.state);
        this.enterRule(localContext, 10, _MangleParser.RULE_descrBlock);
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 92;
            this.match(_MangleParser.T__2);
            this.state = 93;
            this.atoms();
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      boundsBlock() {
        let localContext = new BoundsBlockContext(this.context, this.state);
        this.enterRule(localContext, 12, _MangleParser.RULE_boundsBlock);
        let _la;
        try {
          let alternative;
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 95;
            this.match(_MangleParser.BOUND);
            this.state = 96;
            this.match(_MangleParser.LBRACKET);
            this.state = 102;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 10, this.context);
            while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
              if (alternative === 1) {
                {
                  {
                    this.state = 97;
                    this.term();
                    this.state = 98;
                    this.match(_MangleParser.COMMA);
                  }
                }
              }
              this.state = 104;
              this.errorHandler.sync(this);
              alternative = this.interpreter.adaptivePredict(this.tokenStream, 10, this.context);
            }
            this.state = 106;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if ((_la - 19 & ~31) === 0 && (1 << _la - 19 & 2076180485) !== 0) {
              {
                this.state = 105;
                this.term();
              }
            }
            this.state = 108;
            this.match(_MangleParser.RBRACKET);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      constraintsBlock() {
        let localContext = new ConstraintsBlockContext(this.context, this.state);
        this.enterRule(localContext, 14, _MangleParser.RULE_constraintsBlock);
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 110;
            this.match(_MangleParser.T__3);
            this.state = 111;
            this.atoms();
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      clause() {
        let localContext = new ClauseContext(this.context, this.state);
        this.enterRule(localContext, 16, _MangleParser.RULE_clause);
        let _la;
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 113;
            this.atom();
            this.state = 115;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 34) {
              {
                this.state = 114;
                this.temporalAnnotation();
              }
            }
            this.state = 119;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 10 || _la === 31) {
              {
                this.state = 117;
                _la = this.tokenStream.LA(1);
                if (!(_la === 10 || _la === 31)) {
                  this.errorHandler.recoverInline(this);
                } else {
                  this.errorHandler.reportMatch(this);
                  this.consume();
                }
                this.state = 118;
                this.clauseBody();
              }
            }
            this.state = 121;
            this.match(_MangleParser.T__1);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      temporalAnnotation() {
        let localContext = new TemporalAnnotationContext(this.context, this.state);
        this.enterRule(localContext, 18, _MangleParser.RULE_temporalAnnotation);
        let _la;
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 123;
            this.match(_MangleParser.AT);
            this.state = 124;
            this.match(_MangleParser.LBRACKET);
            this.state = 125;
            this.temporalBound();
            this.state = 128;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 25) {
              {
                this.state = 126;
                this.match(_MangleParser.COMMA);
                this.state = 127;
                this.temporalBound();
              }
            }
            this.state = 130;
            this.match(_MangleParser.RBRACKET);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      temporalBound() {
        let localContext = new TemporalBoundContext(this.context, this.state);
        this.enterRule(localContext, 20, _MangleParser.RULE_temporalBound);
        let _la;
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 132;
            _la = this.tokenStream.LA(1);
            if (!(_la === 5 || (_la - 39 & ~31) === 0 && (1 << _la - 39 & 19) !== 0)) {
              this.errorHandler.recoverInline(this);
            } else {
              this.errorHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      clauseBody() {
        let localContext = new ClauseBodyContext(this.context, this.state);
        this.enterRule(localContext, 22, _MangleParser.RULE_clauseBody);
        let _la;
        try {
          let alternative;
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 134;
            this.literalOrFml();
            this.state = 139;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 15, this.context);
            while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
              if (alternative === 1) {
                {
                  {
                    this.state = 135;
                    this.match(_MangleParser.COMMA);
                    this.state = 136;
                    this.literalOrFml();
                  }
                }
              }
              this.state = 141;
              this.errorHandler.sync(this);
              alternative = this.interpreter.adaptivePredict(this.tokenStream, 15, this.context);
            }
            this.state = 143;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 25) {
              {
                this.state = 142;
                this.match(_MangleParser.COMMA);
              }
            }
            this.state = 149;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            while (_la === 33) {
              {
                {
                  this.state = 145;
                  this.match(_MangleParser.PIPEGREATER);
                  this.state = 146;
                  this.transform();
                }
              }
              this.state = 151;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      transform() {
        let localContext = new TransformContext(this.context, this.state);
        this.enterRule(localContext, 24, _MangleParser.RULE_transform);
        let _la;
        try {
          this.state = 173;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _MangleParser.DO:
              this.enterOuterAlt(localContext, 1);
              {
                this.state = 152;
                this.match(_MangleParser.DO);
                this.state = 153;
                this.term();
                this.state = 163;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 25) {
                  {
                    this.state = 154;
                    this.match(_MangleParser.COMMA);
                    this.state = 155;
                    this.letStmt();
                    this.state = 160;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                    while (_la === 25) {
                      {
                        {
                          this.state = 156;
                          this.match(_MangleParser.COMMA);
                          this.state = 157;
                          this.letStmt();
                        }
                      }
                      this.state = 162;
                      this.errorHandler.sync(this);
                      _la = this.tokenStream.LA(1);
                    }
                  }
                }
              }
              break;
            case _MangleParser.LET:
              this.enterOuterAlt(localContext, 2);
              {
                this.state = 165;
                this.letStmt();
                this.state = 170;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while (_la === 25) {
                  {
                    {
                      this.state = 166;
                      this.match(_MangleParser.COMMA);
                      this.state = 167;
                      this.letStmt();
                    }
                  }
                  this.state = 172;
                  this.errorHandler.sync(this);
                  _la = this.tokenStream.LA(1);
                }
              }
              break;
            default:
              throw new antlr.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      letStmt() {
        let localContext = new LetStmtContext(this.context, this.state);
        this.enterRule(localContext, 26, _MangleParser.RULE_letStmt);
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 175;
            this.match(_MangleParser.LET);
            this.state = 176;
            this.match(_MangleParser.VARIABLE);
            this.state = 177;
            this.match(_MangleParser.EQ);
            this.state = 178;
            this.term();
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      literalOrFml() {
        let localContext = new LiteralOrFmlContext(this.context, this.state);
        this.enterRule(localContext, 28, _MangleParser.RULE_literalOrFml);
        let _la;
        try {
          this.state = 193;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _MangleParser.LBRACKET:
            case _MangleParser.LBRACE:
            case _MangleParser.DIAMONDMINUS:
            case _MangleParser.DIAMONDPLUS:
            case _MangleParser.BOXMINUS:
            case _MangleParser.BOXPLUS:
            case _MangleParser.NUMBER:
            case _MangleParser.FLOAT:
            case _MangleParser.VARIABLE:
            case _MangleParser.NAME:
            case _MangleParser.DOT_TYPE:
            case _MangleParser.CONSTANT:
            case _MangleParser.STRING:
            case _MangleParser.BYTESTRING:
              this.enterOuterAlt(localContext, 1);
              {
                this.state = 181;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la - 35 & ~31) === 0 && (1 << _la - 35 & 15) !== 0) {
                  {
                    this.state = 180;
                    this.temporalOperator();
                  }
                }
                this.state = 183;
                this.term();
                this.state = 185;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 34) {
                  {
                    this.state = 184;
                    this.temporalAnnotation();
                  }
                }
                this.state = 189;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 2038431744) !== 0) {
                  {
                    this.state = 187;
                    _la = this.tokenStream.LA(1);
                    if (!((_la & ~31) === 0 && (1 << _la & 2038431744) !== 0)) {
                      this.errorHandler.recoverInline(this);
                    } else {
                      this.errorHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 188;
                    this.term();
                  }
                }
              }
              break;
            case _MangleParser.BANG:
              this.enterOuterAlt(localContext, 2);
              {
                this.state = 191;
                this.match(_MangleParser.BANG);
                this.state = 192;
                this.term();
              }
              break;
            default:
              throw new antlr.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      temporalOperator() {
        let localContext = new TemporalOperatorContext(this.context, this.state);
        this.enterRule(localContext, 30, _MangleParser.RULE_temporalOperator);
        try {
          this.state = 223;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _MangleParser.DIAMONDMINUS:
              this.enterOuterAlt(localContext, 1);
              {
                this.state = 195;
                this.match(_MangleParser.DIAMONDMINUS);
                this.state = 196;
                this.match(_MangleParser.LBRACKET);
                this.state = 197;
                this.temporalBound();
                this.state = 198;
                this.match(_MangleParser.COMMA);
                this.state = 199;
                this.temporalBound();
                this.state = 200;
                this.match(_MangleParser.RBRACKET);
              }
              break;
            case _MangleParser.BOXMINUS:
              this.enterOuterAlt(localContext, 2);
              {
                this.state = 202;
                this.match(_MangleParser.BOXMINUS);
                this.state = 203;
                this.match(_MangleParser.LBRACKET);
                this.state = 204;
                this.temporalBound();
                this.state = 205;
                this.match(_MangleParser.COMMA);
                this.state = 206;
                this.temporalBound();
                this.state = 207;
                this.match(_MangleParser.RBRACKET);
              }
              break;
            case _MangleParser.DIAMONDPLUS:
              this.enterOuterAlt(localContext, 3);
              {
                this.state = 209;
                this.match(_MangleParser.DIAMONDPLUS);
                this.state = 210;
                this.match(_MangleParser.LBRACKET);
                this.state = 211;
                this.temporalBound();
                this.state = 212;
                this.match(_MangleParser.COMMA);
                this.state = 213;
                this.temporalBound();
                this.state = 214;
                this.match(_MangleParser.RBRACKET);
              }
              break;
            case _MangleParser.BOXPLUS:
              this.enterOuterAlt(localContext, 4);
              {
                this.state = 216;
                this.match(_MangleParser.BOXPLUS);
                this.state = 217;
                this.match(_MangleParser.LBRACKET);
                this.state = 218;
                this.temporalBound();
                this.state = 219;
                this.match(_MangleParser.COMMA);
                this.state = 220;
                this.temporalBound();
                this.state = 221;
                this.match(_MangleParser.RBRACKET);
              }
              break;
            default:
              throw new antlr.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      term() {
        let localContext = new TermContext(this.context, this.state);
        this.enterRule(localContext, 32, _MangleParser.RULE_term);
        let _la;
        try {
          let alternative;
          this.state = 311;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 38, this.context)) {
            case 1:
              localContext = new VarContext(localContext);
              this.enterOuterAlt(localContext, 1);
              {
                this.state = 225;
                this.match(_MangleParser.VARIABLE);
              }
              break;
            case 2:
              localContext = new ConstContext(localContext);
              this.enterOuterAlt(localContext, 2);
              {
                this.state = 226;
                this.match(_MangleParser.CONSTANT);
              }
              break;
            case 3:
              localContext = new NumContext(localContext);
              this.enterOuterAlt(localContext, 3);
              {
                this.state = 227;
                this.match(_MangleParser.NUMBER);
              }
              break;
            case 4:
              localContext = new FloatContext(localContext);
              this.enterOuterAlt(localContext, 4);
              {
                this.state = 228;
                this.match(_MangleParser.FLOAT);
              }
              break;
            case 5:
              localContext = new StrContext(localContext);
              this.enterOuterAlt(localContext, 5);
              {
                this.state = 229;
                this.match(_MangleParser.STRING);
              }
              break;
            case 6:
              localContext = new BStrContext(localContext);
              this.enterOuterAlt(localContext, 6);
              {
                this.state = 230;
                this.match(_MangleParser.BYTESTRING);
              }
              break;
            case 7:
              localContext = new ListContext(localContext);
              this.enterOuterAlt(localContext, 7);
              {
                this.state = 231;
                this.match(_MangleParser.LBRACKET);
                this.state = 237;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 27, this.context);
                while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
                  if (alternative === 1) {
                    {
                      {
                        this.state = 232;
                        this.term();
                        this.state = 233;
                        this.match(_MangleParser.COMMA);
                      }
                    }
                  }
                  this.state = 239;
                  this.errorHandler.sync(this);
                  alternative = this.interpreter.adaptivePredict(this.tokenStream, 27, this.context);
                }
                this.state = 241;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la - 19 & ~31) === 0 && (1 << _la - 19 & 2076180485) !== 0) {
                  {
                    this.state = 240;
                    this.term();
                  }
                }
                this.state = 243;
                this.match(_MangleParser.RBRACKET);
              }
              break;
            case 8:
              localContext = new MapContext(localContext);
              this.enterOuterAlt(localContext, 8);
              {
                this.state = 244;
                this.match(_MangleParser.LBRACKET);
                this.state = 252;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 29, this.context);
                while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
                  if (alternative === 1) {
                    {
                      {
                        this.state = 245;
                        this.term();
                        this.state = 246;
                        this.match(_MangleParser.T__5);
                        this.state = 247;
                        this.term();
                        this.state = 248;
                        this.match(_MangleParser.COMMA);
                      }
                    }
                  }
                  this.state = 254;
                  this.errorHandler.sync(this);
                  alternative = this.interpreter.adaptivePredict(this.tokenStream, 29, this.context);
                }
                this.state = 259;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la - 19 & ~31) === 0 && (1 << _la - 19 & 2076180485) !== 0) {
                  {
                    this.state = 255;
                    this.term();
                    this.state = 256;
                    this.match(_MangleParser.T__5);
                    this.state = 257;
                    this.term();
                  }
                }
                this.state = 261;
                this.match(_MangleParser.RBRACKET);
              }
              break;
            case 9:
              localContext = new StructContext(localContext);
              this.enterOuterAlt(localContext, 9);
              {
                this.state = 262;
                this.match(_MangleParser.LBRACE);
                this.state = 270;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 31, this.context);
                while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
                  if (alternative === 1) {
                    {
                      {
                        this.state = 263;
                        this.term();
                        this.state = 264;
                        this.match(_MangleParser.T__5);
                        this.state = 265;
                        this.term();
                        this.state = 266;
                        this.match(_MangleParser.COMMA);
                      }
                    }
                  }
                  this.state = 272;
                  this.errorHandler.sync(this);
                  alternative = this.interpreter.adaptivePredict(this.tokenStream, 31, this.context);
                }
                this.state = 277;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la - 19 & ~31) === 0 && (1 << _la - 19 & 2076180485) !== 0) {
                  {
                    this.state = 273;
                    this.term();
                    this.state = 274;
                    this.match(_MangleParser.T__5);
                    this.state = 275;
                    this.term();
                  }
                }
                this.state = 279;
                this.match(_MangleParser.RBRACE);
              }
              break;
            case 10:
              localContext = new DotTypeContext(localContext);
              this.enterOuterAlt(localContext, 10);
              {
                this.state = 280;
                this.match(_MangleParser.DOT_TYPE);
                this.state = 281;
                this.match(_MangleParser.LESS);
                this.state = 287;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 33, this.context);
                while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
                  if (alternative === 1) {
                    {
                      {
                        this.state = 282;
                        this.member();
                        this.state = 283;
                        this.match(_MangleParser.COMMA);
                      }
                    }
                  }
                  this.state = 289;
                  this.errorHandler.sync(this);
                  alternative = this.interpreter.adaptivePredict(this.tokenStream, 33, this.context);
                }
                this.state = 294;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 2621568) !== 0 || (_la - 41 & ~31) === 0 && (1 << _la - 41 & 495) !== 0) {
                  {
                    this.state = 290;
                    this.member();
                    this.state = 292;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                    if (_la === 25) {
                      {
                        this.state = 291;
                        this.match(_MangleParser.COMMA);
                      }
                    }
                  }
                }
                this.state = 296;
                this.match(_MangleParser.GREATER);
              }
              break;
            case 11:
              localContext = new ApplContext(localContext);
              this.enterOuterAlt(localContext, 11);
              {
                this.state = 297;
                this.match(_MangleParser.NAME);
                this.state = 298;
                this.match(_MangleParser.LPAREN);
                this.state = 304;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 36, this.context);
                while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
                  if (alternative === 1) {
                    {
                      {
                        this.state = 299;
                        this.term();
                        this.state = 300;
                        this.match(_MangleParser.COMMA);
                      }
                    }
                  }
                  this.state = 306;
                  this.errorHandler.sync(this);
                  alternative = this.interpreter.adaptivePredict(this.tokenStream, 36, this.context);
                }
                this.state = 308;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la - 19 & ~31) === 0 && (1 << _la - 19 & 2076180485) !== 0) {
                  {
                    this.state = 307;
                    this.term();
                  }
                }
                this.state = 310;
                this.match(_MangleParser.RPAREN);
              }
              break;
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      member() {
        let localContext = new MemberContext(this.context, this.state);
        this.enterRule(localContext, 34, _MangleParser.RULE_member);
        let _la;
        try {
          this.state = 323;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _MangleParser.LBRACKET:
            case _MangleParser.LBRACE:
            case _MangleParser.NUMBER:
            case _MangleParser.FLOAT:
            case _MangleParser.VARIABLE:
            case _MangleParser.NAME:
            case _MangleParser.DOT_TYPE:
            case _MangleParser.CONSTANT:
            case _MangleParser.STRING:
            case _MangleParser.BYTESTRING:
              this.enterOuterAlt(localContext, 1);
              {
                this.state = 313;
                this.term();
                this.state = 316;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 6) {
                  {
                    this.state = 314;
                    this.match(_MangleParser.T__5);
                    this.state = 315;
                    this.term();
                  }
                }
              }
              break;
            case _MangleParser.T__6:
              this.enterOuterAlt(localContext, 2);
              {
                this.state = 318;
                this.match(_MangleParser.T__6);
                this.state = 319;
                this.term();
                this.state = 320;
                this.match(_MangleParser.T__5);
                this.state = 321;
                this.term();
              }
              break;
            default:
              throw new antlr.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      atom() {
        let localContext = new AtomContext(this.context, this.state);
        this.enterRule(localContext, 36, _MangleParser.RULE_atom);
        try {
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 325;
            this.term();
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      atoms() {
        let localContext = new AtomsContext(this.context, this.state);
        this.enterRule(localContext, 38, _MangleParser.RULE_atoms);
        let _la;
        try {
          let alternative;
          this.enterOuterAlt(localContext, 1);
          {
            this.state = 327;
            this.match(_MangleParser.LBRACKET);
            this.state = 333;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 41, this.context);
            while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
              if (alternative === 1) {
                {
                  {
                    this.state = 328;
                    this.atom();
                    this.state = 329;
                    this.match(_MangleParser.COMMA);
                  }
                }
              }
              this.state = 335;
              this.errorHandler.sync(this);
              alternative = this.interpreter.adaptivePredict(this.tokenStream, 41, this.context);
            }
            this.state = 337;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if ((_la - 19 & ~31) === 0 && (1 << _la - 19 & 2076180485) !== 0) {
              {
                this.state = 336;
                this.atom();
              }
            }
            this.state = 339;
            this.match(_MangleParser.RBRACKET);
          }
        } catch (re) {
          if (re instanceof antlr.RecognitionException) {
            this.errorHandler.reportError(this, re);
            this.errorHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return localContext;
      }
      static get _ATN() {
        if (!_MangleParser.__ATN) {
          _MangleParser.__ATN = new antlr.ATNDeserializer().deserialize(_MangleParser._serializedATN);
        }
        return _MangleParser.__ATN;
      }
      get vocabulary() {
        return _MangleParser.vocabulary;
      }
    };
    exports2.MangleParser = MangleParser;
    MangleParser.T__0 = 1;
    MangleParser.T__1 = 2;
    MangleParser.T__2 = 3;
    MangleParser.T__3 = 4;
    MangleParser.T__4 = 5;
    MangleParser.T__5 = 6;
    MangleParser.T__6 = 7;
    MangleParser.WHITESPACE = 8;
    MangleParser.COMMENT = 9;
    MangleParser.LONGLEFTDOUBLEARROW = 10;
    MangleParser.PACKAGE = 11;
    MangleParser.USE = 12;
    MangleParser.DECL = 13;
    MangleParser.BOUND = 14;
    MangleParser.LET = 15;
    MangleParser.DO = 16;
    MangleParser.LPAREN = 17;
    MangleParser.RPAREN = 18;
    MangleParser.LBRACKET = 19;
    MangleParser.RBRACKET = 20;
    MangleParser.LBRACE = 21;
    MangleParser.RBRACE = 22;
    MangleParser.EQ = 23;
    MangleParser.BANGEQ = 24;
    MangleParser.COMMA = 25;
    MangleParser.BANG = 26;
    MangleParser.LESSEQ = 27;
    MangleParser.LESS = 28;
    MangleParser.GREATEREQ = 29;
    MangleParser.GREATER = 30;
    MangleParser.COLONDASH = 31;
    MangleParser.NEWLINE = 32;
    MangleParser.PIPEGREATER = 33;
    MangleParser.AT = 34;
    MangleParser.DIAMONDMINUS = 35;
    MangleParser.DIAMONDPLUS = 36;
    MangleParser.BOXMINUS = 37;
    MangleParser.BOXPLUS = 38;
    MangleParser.TIMESTAMP = 39;
    MangleParser.DURATION = 40;
    MangleParser.NUMBER = 41;
    MangleParser.FLOAT = 42;
    MangleParser.VARIABLE = 43;
    MangleParser.NAME = 44;
    MangleParser.TYPENAME = 45;
    MangleParser.DOT_TYPE = 46;
    MangleParser.CONSTANT = 47;
    MangleParser.STRING = 48;
    MangleParser.BYTESTRING = 49;
    MangleParser.RULE_start = 0;
    MangleParser.RULE_program = 1;
    MangleParser.RULE_packageDecl = 2;
    MangleParser.RULE_useDecl = 3;
    MangleParser.RULE_decl = 4;
    MangleParser.RULE_descrBlock = 5;
    MangleParser.RULE_boundsBlock = 6;
    MangleParser.RULE_constraintsBlock = 7;
    MangleParser.RULE_clause = 8;
    MangleParser.RULE_temporalAnnotation = 9;
    MangleParser.RULE_temporalBound = 10;
    MangleParser.RULE_clauseBody = 11;
    MangleParser.RULE_transform = 12;
    MangleParser.RULE_letStmt = 13;
    MangleParser.RULE_literalOrFml = 14;
    MangleParser.RULE_temporalOperator = 15;
    MangleParser.RULE_term = 16;
    MangleParser.RULE_member = 17;
    MangleParser.RULE_atom = 18;
    MangleParser.RULE_atoms = 19;
    MangleParser.literalNames = [
      null,
      "'temporal'",
      "'.'",
      "'descr'",
      "'inclusion'",
      "'now'",
      "':'",
      "'opt'",
      null,
      null,
      "'\\u27F8'",
      "'Package'",
      "'Use'",
      "'Decl'",
      "'bound'",
      "'let'",
      "'do'",
      "'('",
      "')'",
      "'['",
      "']'",
      "'{'",
      "'}'",
      "'='",
      "'!='",
      "','",
      "'!'",
      "'<='",
      "'<'",
      "'>='",
      "'>'",
      "':-'",
      "'\\n'",
      "'|>'",
      "'@'",
      "'<-'",
      "'<+'",
      "'[-'",
      "'[+'"
    ];
    MangleParser.symbolicNames = [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      "WHITESPACE",
      "COMMENT",
      "LONGLEFTDOUBLEARROW",
      "PACKAGE",
      "USE",
      "DECL",
      "BOUND",
      "LET",
      "DO",
      "LPAREN",
      "RPAREN",
      "LBRACKET",
      "RBRACKET",
      "LBRACE",
      "RBRACE",
      "EQ",
      "BANGEQ",
      "COMMA",
      "BANG",
      "LESSEQ",
      "LESS",
      "GREATEREQ",
      "GREATER",
      "COLONDASH",
      "NEWLINE",
      "PIPEGREATER",
      "AT",
      "DIAMONDMINUS",
      "DIAMONDPLUS",
      "BOXMINUS",
      "BOXPLUS",
      "TIMESTAMP",
      "DURATION",
      "NUMBER",
      "FLOAT",
      "VARIABLE",
      "NAME",
      "TYPENAME",
      "DOT_TYPE",
      "CONSTANT",
      "STRING",
      "BYTESTRING"
    ];
    MangleParser.ruleNames = [
      "start",
      "program",
      "packageDecl",
      "useDecl",
      "decl",
      "descrBlock",
      "boundsBlock",
      "constraintsBlock",
      "clause",
      "temporalAnnotation",
      "temporalBound",
      "clauseBody",
      "transform",
      "letStmt",
      "literalOrFml",
      "temporalOperator",
      "term",
      "member",
      "atom",
      "atoms"
    ];
    MangleParser._serializedATN = [
      4,
      1,
      49,
      342,
      2,
      0,
      7,
      0,
      2,
      1,
      7,
      1,
      2,
      2,
      7,
      2,
      2,
      3,
      7,
      3,
      2,
      4,
      7,
      4,
      2,
      5,
      7,
      5,
      2,
      6,
      7,
      6,
      2,
      7,
      7,
      7,
      2,
      8,
      7,
      8,
      2,
      9,
      7,
      9,
      2,
      10,
      7,
      10,
      2,
      11,
      7,
      11,
      2,
      12,
      7,
      12,
      2,
      13,
      7,
      13,
      2,
      14,
      7,
      14,
      2,
      15,
      7,
      15,
      2,
      16,
      7,
      16,
      2,
      17,
      7,
      17,
      2,
      18,
      7,
      18,
      2,
      19,
      7,
      19,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      1,
      3,
      1,
      45,
      8,
      1,
      1,
      1,
      5,
      1,
      48,
      8,
      1,
      10,
      1,
      12,
      1,
      51,
      9,
      1,
      1,
      1,
      1,
      1,
      5,
      1,
      55,
      8,
      1,
      10,
      1,
      12,
      1,
      58,
      9,
      1,
      1,
      2,
      1,
      2,
      1,
      2,
      3,
      2,
      63,
      8,
      2,
      1,
      2,
      1,
      2,
      1,
      3,
      1,
      3,
      1,
      3,
      3,
      3,
      70,
      8,
      3,
      1,
      3,
      1,
      3,
      1,
      4,
      1,
      4,
      1,
      4,
      3,
      4,
      77,
      8,
      4,
      1,
      4,
      3,
      4,
      80,
      8,
      4,
      1,
      4,
      5,
      4,
      83,
      8,
      4,
      10,
      4,
      12,
      4,
      86,
      9,
      4,
      1,
      4,
      3,
      4,
      89,
      8,
      4,
      1,
      4,
      1,
      4,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      6,
      1,
      6,
      1,
      6,
      1,
      6,
      1,
      6,
      5,
      6,
      101,
      8,
      6,
      10,
      6,
      12,
      6,
      104,
      9,
      6,
      1,
      6,
      3,
      6,
      107,
      8,
      6,
      1,
      6,
      1,
      6,
      1,
      7,
      1,
      7,
      1,
      7,
      1,
      8,
      1,
      8,
      3,
      8,
      116,
      8,
      8,
      1,
      8,
      1,
      8,
      3,
      8,
      120,
      8,
      8,
      1,
      8,
      1,
      8,
      1,
      9,
      1,
      9,
      1,
      9,
      1,
      9,
      1,
      9,
      3,
      9,
      129,
      8,
      9,
      1,
      9,
      1,
      9,
      1,
      10,
      1,
      10,
      1,
      11,
      1,
      11,
      1,
      11,
      5,
      11,
      138,
      8,
      11,
      10,
      11,
      12,
      11,
      141,
      9,
      11,
      1,
      11,
      3,
      11,
      144,
      8,
      11,
      1,
      11,
      1,
      11,
      5,
      11,
      148,
      8,
      11,
      10,
      11,
      12,
      11,
      151,
      9,
      11,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      5,
      12,
      159,
      8,
      12,
      10,
      12,
      12,
      12,
      162,
      9,
      12,
      3,
      12,
      164,
      8,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      5,
      12,
      169,
      8,
      12,
      10,
      12,
      12,
      12,
      172,
      9,
      12,
      3,
      12,
      174,
      8,
      12,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      14,
      3,
      14,
      182,
      8,
      14,
      1,
      14,
      1,
      14,
      3,
      14,
      186,
      8,
      14,
      1,
      14,
      1,
      14,
      3,
      14,
      190,
      8,
      14,
      1,
      14,
      1,
      14,
      3,
      14,
      194,
      8,
      14,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      1,
      15,
      3,
      15,
      224,
      8,
      15,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      5,
      16,
      236,
      8,
      16,
      10,
      16,
      12,
      16,
      239,
      9,
      16,
      1,
      16,
      3,
      16,
      242,
      8,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      5,
      16,
      251,
      8,
      16,
      10,
      16,
      12,
      16,
      254,
      9,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      3,
      16,
      260,
      8,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      5,
      16,
      269,
      8,
      16,
      10,
      16,
      12,
      16,
      272,
      9,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      3,
      16,
      278,
      8,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      5,
      16,
      286,
      8,
      16,
      10,
      16,
      12,
      16,
      289,
      9,
      16,
      1,
      16,
      1,
      16,
      3,
      16,
      293,
      8,
      16,
      3,
      16,
      295,
      8,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      5,
      16,
      303,
      8,
      16,
      10,
      16,
      12,
      16,
      306,
      9,
      16,
      1,
      16,
      3,
      16,
      309,
      8,
      16,
      1,
      16,
      3,
      16,
      312,
      8,
      16,
      1,
      17,
      1,
      17,
      1,
      17,
      3,
      17,
      317,
      8,
      17,
      1,
      17,
      1,
      17,
      1,
      17,
      1,
      17,
      1,
      17,
      3,
      17,
      324,
      8,
      17,
      1,
      18,
      1,
      18,
      1,
      19,
      1,
      19,
      1,
      19,
      1,
      19,
      5,
      19,
      332,
      8,
      19,
      10,
      19,
      12,
      19,
      335,
      9,
      19,
      1,
      19,
      3,
      19,
      338,
      8,
      19,
      1,
      19,
      1,
      19,
      1,
      19,
      0,
      0,
      20,
      0,
      2,
      4,
      6,
      8,
      10,
      12,
      14,
      16,
      18,
      20,
      22,
      24,
      26,
      28,
      30,
      32,
      34,
      36,
      38,
      0,
      3,
      2,
      0,
      10,
      10,
      31,
      31,
      3,
      0,
      5,
      5,
      39,
      40,
      43,
      43,
      2,
      0,
      23,
      24,
      27,
      30,
      375,
      0,
      40,
      1,
      0,
      0,
      0,
      2,
      44,
      1,
      0,
      0,
      0,
      4,
      59,
      1,
      0,
      0,
      0,
      6,
      66,
      1,
      0,
      0,
      0,
      8,
      73,
      1,
      0,
      0,
      0,
      10,
      92,
      1,
      0,
      0,
      0,
      12,
      95,
      1,
      0,
      0,
      0,
      14,
      110,
      1,
      0,
      0,
      0,
      16,
      113,
      1,
      0,
      0,
      0,
      18,
      123,
      1,
      0,
      0,
      0,
      20,
      132,
      1,
      0,
      0,
      0,
      22,
      134,
      1,
      0,
      0,
      0,
      24,
      173,
      1,
      0,
      0,
      0,
      26,
      175,
      1,
      0,
      0,
      0,
      28,
      193,
      1,
      0,
      0,
      0,
      30,
      223,
      1,
      0,
      0,
      0,
      32,
      311,
      1,
      0,
      0,
      0,
      34,
      323,
      1,
      0,
      0,
      0,
      36,
      325,
      1,
      0,
      0,
      0,
      38,
      327,
      1,
      0,
      0,
      0,
      40,
      41,
      3,
      2,
      1,
      0,
      41,
      42,
      5,
      0,
      0,
      1,
      42,
      1,
      1,
      0,
      0,
      0,
      43,
      45,
      3,
      4,
      2,
      0,
      44,
      43,
      1,
      0,
      0,
      0,
      44,
      45,
      1,
      0,
      0,
      0,
      45,
      49,
      1,
      0,
      0,
      0,
      46,
      48,
      3,
      6,
      3,
      0,
      47,
      46,
      1,
      0,
      0,
      0,
      48,
      51,
      1,
      0,
      0,
      0,
      49,
      47,
      1,
      0,
      0,
      0,
      49,
      50,
      1,
      0,
      0,
      0,
      50,
      56,
      1,
      0,
      0,
      0,
      51,
      49,
      1,
      0,
      0,
      0,
      52,
      55,
      3,
      8,
      4,
      0,
      53,
      55,
      3,
      16,
      8,
      0,
      54,
      52,
      1,
      0,
      0,
      0,
      54,
      53,
      1,
      0,
      0,
      0,
      55,
      58,
      1,
      0,
      0,
      0,
      56,
      54,
      1,
      0,
      0,
      0,
      56,
      57,
      1,
      0,
      0,
      0,
      57,
      3,
      1,
      0,
      0,
      0,
      58,
      56,
      1,
      0,
      0,
      0,
      59,
      60,
      5,
      11,
      0,
      0,
      60,
      62,
      5,
      44,
      0,
      0,
      61,
      63,
      3,
      38,
      19,
      0,
      62,
      61,
      1,
      0,
      0,
      0,
      62,
      63,
      1,
      0,
      0,
      0,
      63,
      64,
      1,
      0,
      0,
      0,
      64,
      65,
      5,
      26,
      0,
      0,
      65,
      5,
      1,
      0,
      0,
      0,
      66,
      67,
      5,
      12,
      0,
      0,
      67,
      69,
      5,
      44,
      0,
      0,
      68,
      70,
      3,
      38,
      19,
      0,
      69,
      68,
      1,
      0,
      0,
      0,
      69,
      70,
      1,
      0,
      0,
      0,
      70,
      71,
      1,
      0,
      0,
      0,
      71,
      72,
      5,
      26,
      0,
      0,
      72,
      7,
      1,
      0,
      0,
      0,
      73,
      74,
      5,
      13,
      0,
      0,
      74,
      76,
      3,
      36,
      18,
      0,
      75,
      77,
      5,
      1,
      0,
      0,
      76,
      75,
      1,
      0,
      0,
      0,
      76,
      77,
      1,
      0,
      0,
      0,
      77,
      79,
      1,
      0,
      0,
      0,
      78,
      80,
      3,
      10,
      5,
      0,
      79,
      78,
      1,
      0,
      0,
      0,
      79,
      80,
      1,
      0,
      0,
      0,
      80,
      84,
      1,
      0,
      0,
      0,
      81,
      83,
      3,
      12,
      6,
      0,
      82,
      81,
      1,
      0,
      0,
      0,
      83,
      86,
      1,
      0,
      0,
      0,
      84,
      82,
      1,
      0,
      0,
      0,
      84,
      85,
      1,
      0,
      0,
      0,
      85,
      88,
      1,
      0,
      0,
      0,
      86,
      84,
      1,
      0,
      0,
      0,
      87,
      89,
      3,
      14,
      7,
      0,
      88,
      87,
      1,
      0,
      0,
      0,
      88,
      89,
      1,
      0,
      0,
      0,
      89,
      90,
      1,
      0,
      0,
      0,
      90,
      91,
      5,
      2,
      0,
      0,
      91,
      9,
      1,
      0,
      0,
      0,
      92,
      93,
      5,
      3,
      0,
      0,
      93,
      94,
      3,
      38,
      19,
      0,
      94,
      11,
      1,
      0,
      0,
      0,
      95,
      96,
      5,
      14,
      0,
      0,
      96,
      102,
      5,
      19,
      0,
      0,
      97,
      98,
      3,
      32,
      16,
      0,
      98,
      99,
      5,
      25,
      0,
      0,
      99,
      101,
      1,
      0,
      0,
      0,
      100,
      97,
      1,
      0,
      0,
      0,
      101,
      104,
      1,
      0,
      0,
      0,
      102,
      100,
      1,
      0,
      0,
      0,
      102,
      103,
      1,
      0,
      0,
      0,
      103,
      106,
      1,
      0,
      0,
      0,
      104,
      102,
      1,
      0,
      0,
      0,
      105,
      107,
      3,
      32,
      16,
      0,
      106,
      105,
      1,
      0,
      0,
      0,
      106,
      107,
      1,
      0,
      0,
      0,
      107,
      108,
      1,
      0,
      0,
      0,
      108,
      109,
      5,
      20,
      0,
      0,
      109,
      13,
      1,
      0,
      0,
      0,
      110,
      111,
      5,
      4,
      0,
      0,
      111,
      112,
      3,
      38,
      19,
      0,
      112,
      15,
      1,
      0,
      0,
      0,
      113,
      115,
      3,
      36,
      18,
      0,
      114,
      116,
      3,
      18,
      9,
      0,
      115,
      114,
      1,
      0,
      0,
      0,
      115,
      116,
      1,
      0,
      0,
      0,
      116,
      119,
      1,
      0,
      0,
      0,
      117,
      118,
      7,
      0,
      0,
      0,
      118,
      120,
      3,
      22,
      11,
      0,
      119,
      117,
      1,
      0,
      0,
      0,
      119,
      120,
      1,
      0,
      0,
      0,
      120,
      121,
      1,
      0,
      0,
      0,
      121,
      122,
      5,
      2,
      0,
      0,
      122,
      17,
      1,
      0,
      0,
      0,
      123,
      124,
      5,
      34,
      0,
      0,
      124,
      125,
      5,
      19,
      0,
      0,
      125,
      128,
      3,
      20,
      10,
      0,
      126,
      127,
      5,
      25,
      0,
      0,
      127,
      129,
      3,
      20,
      10,
      0,
      128,
      126,
      1,
      0,
      0,
      0,
      128,
      129,
      1,
      0,
      0,
      0,
      129,
      130,
      1,
      0,
      0,
      0,
      130,
      131,
      5,
      20,
      0,
      0,
      131,
      19,
      1,
      0,
      0,
      0,
      132,
      133,
      7,
      1,
      0,
      0,
      133,
      21,
      1,
      0,
      0,
      0,
      134,
      139,
      3,
      28,
      14,
      0,
      135,
      136,
      5,
      25,
      0,
      0,
      136,
      138,
      3,
      28,
      14,
      0,
      137,
      135,
      1,
      0,
      0,
      0,
      138,
      141,
      1,
      0,
      0,
      0,
      139,
      137,
      1,
      0,
      0,
      0,
      139,
      140,
      1,
      0,
      0,
      0,
      140,
      143,
      1,
      0,
      0,
      0,
      141,
      139,
      1,
      0,
      0,
      0,
      142,
      144,
      5,
      25,
      0,
      0,
      143,
      142,
      1,
      0,
      0,
      0,
      143,
      144,
      1,
      0,
      0,
      0,
      144,
      149,
      1,
      0,
      0,
      0,
      145,
      146,
      5,
      33,
      0,
      0,
      146,
      148,
      3,
      24,
      12,
      0,
      147,
      145,
      1,
      0,
      0,
      0,
      148,
      151,
      1,
      0,
      0,
      0,
      149,
      147,
      1,
      0,
      0,
      0,
      149,
      150,
      1,
      0,
      0,
      0,
      150,
      23,
      1,
      0,
      0,
      0,
      151,
      149,
      1,
      0,
      0,
      0,
      152,
      153,
      5,
      16,
      0,
      0,
      153,
      163,
      3,
      32,
      16,
      0,
      154,
      155,
      5,
      25,
      0,
      0,
      155,
      160,
      3,
      26,
      13,
      0,
      156,
      157,
      5,
      25,
      0,
      0,
      157,
      159,
      3,
      26,
      13,
      0,
      158,
      156,
      1,
      0,
      0,
      0,
      159,
      162,
      1,
      0,
      0,
      0,
      160,
      158,
      1,
      0,
      0,
      0,
      160,
      161,
      1,
      0,
      0,
      0,
      161,
      164,
      1,
      0,
      0,
      0,
      162,
      160,
      1,
      0,
      0,
      0,
      163,
      154,
      1,
      0,
      0,
      0,
      163,
      164,
      1,
      0,
      0,
      0,
      164,
      174,
      1,
      0,
      0,
      0,
      165,
      170,
      3,
      26,
      13,
      0,
      166,
      167,
      5,
      25,
      0,
      0,
      167,
      169,
      3,
      26,
      13,
      0,
      168,
      166,
      1,
      0,
      0,
      0,
      169,
      172,
      1,
      0,
      0,
      0,
      170,
      168,
      1,
      0,
      0,
      0,
      170,
      171,
      1,
      0,
      0,
      0,
      171,
      174,
      1,
      0,
      0,
      0,
      172,
      170,
      1,
      0,
      0,
      0,
      173,
      152,
      1,
      0,
      0,
      0,
      173,
      165,
      1,
      0,
      0,
      0,
      174,
      25,
      1,
      0,
      0,
      0,
      175,
      176,
      5,
      15,
      0,
      0,
      176,
      177,
      5,
      43,
      0,
      0,
      177,
      178,
      5,
      23,
      0,
      0,
      178,
      179,
      3,
      32,
      16,
      0,
      179,
      27,
      1,
      0,
      0,
      0,
      180,
      182,
      3,
      30,
      15,
      0,
      181,
      180,
      1,
      0,
      0,
      0,
      181,
      182,
      1,
      0,
      0,
      0,
      182,
      183,
      1,
      0,
      0,
      0,
      183,
      185,
      3,
      32,
      16,
      0,
      184,
      186,
      3,
      18,
      9,
      0,
      185,
      184,
      1,
      0,
      0,
      0,
      185,
      186,
      1,
      0,
      0,
      0,
      186,
      189,
      1,
      0,
      0,
      0,
      187,
      188,
      7,
      2,
      0,
      0,
      188,
      190,
      3,
      32,
      16,
      0,
      189,
      187,
      1,
      0,
      0,
      0,
      189,
      190,
      1,
      0,
      0,
      0,
      190,
      194,
      1,
      0,
      0,
      0,
      191,
      192,
      5,
      26,
      0,
      0,
      192,
      194,
      3,
      32,
      16,
      0,
      193,
      181,
      1,
      0,
      0,
      0,
      193,
      191,
      1,
      0,
      0,
      0,
      194,
      29,
      1,
      0,
      0,
      0,
      195,
      196,
      5,
      35,
      0,
      0,
      196,
      197,
      5,
      19,
      0,
      0,
      197,
      198,
      3,
      20,
      10,
      0,
      198,
      199,
      5,
      25,
      0,
      0,
      199,
      200,
      3,
      20,
      10,
      0,
      200,
      201,
      5,
      20,
      0,
      0,
      201,
      224,
      1,
      0,
      0,
      0,
      202,
      203,
      5,
      37,
      0,
      0,
      203,
      204,
      5,
      19,
      0,
      0,
      204,
      205,
      3,
      20,
      10,
      0,
      205,
      206,
      5,
      25,
      0,
      0,
      206,
      207,
      3,
      20,
      10,
      0,
      207,
      208,
      5,
      20,
      0,
      0,
      208,
      224,
      1,
      0,
      0,
      0,
      209,
      210,
      5,
      36,
      0,
      0,
      210,
      211,
      5,
      19,
      0,
      0,
      211,
      212,
      3,
      20,
      10,
      0,
      212,
      213,
      5,
      25,
      0,
      0,
      213,
      214,
      3,
      20,
      10,
      0,
      214,
      215,
      5,
      20,
      0,
      0,
      215,
      224,
      1,
      0,
      0,
      0,
      216,
      217,
      5,
      38,
      0,
      0,
      217,
      218,
      5,
      19,
      0,
      0,
      218,
      219,
      3,
      20,
      10,
      0,
      219,
      220,
      5,
      25,
      0,
      0,
      220,
      221,
      3,
      20,
      10,
      0,
      221,
      222,
      5,
      20,
      0,
      0,
      222,
      224,
      1,
      0,
      0,
      0,
      223,
      195,
      1,
      0,
      0,
      0,
      223,
      202,
      1,
      0,
      0,
      0,
      223,
      209,
      1,
      0,
      0,
      0,
      223,
      216,
      1,
      0,
      0,
      0,
      224,
      31,
      1,
      0,
      0,
      0,
      225,
      312,
      5,
      43,
      0,
      0,
      226,
      312,
      5,
      47,
      0,
      0,
      227,
      312,
      5,
      41,
      0,
      0,
      228,
      312,
      5,
      42,
      0,
      0,
      229,
      312,
      5,
      48,
      0,
      0,
      230,
      312,
      5,
      49,
      0,
      0,
      231,
      237,
      5,
      19,
      0,
      0,
      232,
      233,
      3,
      32,
      16,
      0,
      233,
      234,
      5,
      25,
      0,
      0,
      234,
      236,
      1,
      0,
      0,
      0,
      235,
      232,
      1,
      0,
      0,
      0,
      236,
      239,
      1,
      0,
      0,
      0,
      237,
      235,
      1,
      0,
      0,
      0,
      237,
      238,
      1,
      0,
      0,
      0,
      238,
      241,
      1,
      0,
      0,
      0,
      239,
      237,
      1,
      0,
      0,
      0,
      240,
      242,
      3,
      32,
      16,
      0,
      241,
      240,
      1,
      0,
      0,
      0,
      241,
      242,
      1,
      0,
      0,
      0,
      242,
      243,
      1,
      0,
      0,
      0,
      243,
      312,
      5,
      20,
      0,
      0,
      244,
      252,
      5,
      19,
      0,
      0,
      245,
      246,
      3,
      32,
      16,
      0,
      246,
      247,
      5,
      6,
      0,
      0,
      247,
      248,
      3,
      32,
      16,
      0,
      248,
      249,
      5,
      25,
      0,
      0,
      249,
      251,
      1,
      0,
      0,
      0,
      250,
      245,
      1,
      0,
      0,
      0,
      251,
      254,
      1,
      0,
      0,
      0,
      252,
      250,
      1,
      0,
      0,
      0,
      252,
      253,
      1,
      0,
      0,
      0,
      253,
      259,
      1,
      0,
      0,
      0,
      254,
      252,
      1,
      0,
      0,
      0,
      255,
      256,
      3,
      32,
      16,
      0,
      256,
      257,
      5,
      6,
      0,
      0,
      257,
      258,
      3,
      32,
      16,
      0,
      258,
      260,
      1,
      0,
      0,
      0,
      259,
      255,
      1,
      0,
      0,
      0,
      259,
      260,
      1,
      0,
      0,
      0,
      260,
      261,
      1,
      0,
      0,
      0,
      261,
      312,
      5,
      20,
      0,
      0,
      262,
      270,
      5,
      21,
      0,
      0,
      263,
      264,
      3,
      32,
      16,
      0,
      264,
      265,
      5,
      6,
      0,
      0,
      265,
      266,
      3,
      32,
      16,
      0,
      266,
      267,
      5,
      25,
      0,
      0,
      267,
      269,
      1,
      0,
      0,
      0,
      268,
      263,
      1,
      0,
      0,
      0,
      269,
      272,
      1,
      0,
      0,
      0,
      270,
      268,
      1,
      0,
      0,
      0,
      270,
      271,
      1,
      0,
      0,
      0,
      271,
      277,
      1,
      0,
      0,
      0,
      272,
      270,
      1,
      0,
      0,
      0,
      273,
      274,
      3,
      32,
      16,
      0,
      274,
      275,
      5,
      6,
      0,
      0,
      275,
      276,
      3,
      32,
      16,
      0,
      276,
      278,
      1,
      0,
      0,
      0,
      277,
      273,
      1,
      0,
      0,
      0,
      277,
      278,
      1,
      0,
      0,
      0,
      278,
      279,
      1,
      0,
      0,
      0,
      279,
      312,
      5,
      22,
      0,
      0,
      280,
      281,
      5,
      46,
      0,
      0,
      281,
      287,
      5,
      28,
      0,
      0,
      282,
      283,
      3,
      34,
      17,
      0,
      283,
      284,
      5,
      25,
      0,
      0,
      284,
      286,
      1,
      0,
      0,
      0,
      285,
      282,
      1,
      0,
      0,
      0,
      286,
      289,
      1,
      0,
      0,
      0,
      287,
      285,
      1,
      0,
      0,
      0,
      287,
      288,
      1,
      0,
      0,
      0,
      288,
      294,
      1,
      0,
      0,
      0,
      289,
      287,
      1,
      0,
      0,
      0,
      290,
      292,
      3,
      34,
      17,
      0,
      291,
      293,
      5,
      25,
      0,
      0,
      292,
      291,
      1,
      0,
      0,
      0,
      292,
      293,
      1,
      0,
      0,
      0,
      293,
      295,
      1,
      0,
      0,
      0,
      294,
      290,
      1,
      0,
      0,
      0,
      294,
      295,
      1,
      0,
      0,
      0,
      295,
      296,
      1,
      0,
      0,
      0,
      296,
      312,
      5,
      30,
      0,
      0,
      297,
      298,
      5,
      44,
      0,
      0,
      298,
      304,
      5,
      17,
      0,
      0,
      299,
      300,
      3,
      32,
      16,
      0,
      300,
      301,
      5,
      25,
      0,
      0,
      301,
      303,
      1,
      0,
      0,
      0,
      302,
      299,
      1,
      0,
      0,
      0,
      303,
      306,
      1,
      0,
      0,
      0,
      304,
      302,
      1,
      0,
      0,
      0,
      304,
      305,
      1,
      0,
      0,
      0,
      305,
      308,
      1,
      0,
      0,
      0,
      306,
      304,
      1,
      0,
      0,
      0,
      307,
      309,
      3,
      32,
      16,
      0,
      308,
      307,
      1,
      0,
      0,
      0,
      308,
      309,
      1,
      0,
      0,
      0,
      309,
      310,
      1,
      0,
      0,
      0,
      310,
      312,
      5,
      18,
      0,
      0,
      311,
      225,
      1,
      0,
      0,
      0,
      311,
      226,
      1,
      0,
      0,
      0,
      311,
      227,
      1,
      0,
      0,
      0,
      311,
      228,
      1,
      0,
      0,
      0,
      311,
      229,
      1,
      0,
      0,
      0,
      311,
      230,
      1,
      0,
      0,
      0,
      311,
      231,
      1,
      0,
      0,
      0,
      311,
      244,
      1,
      0,
      0,
      0,
      311,
      262,
      1,
      0,
      0,
      0,
      311,
      280,
      1,
      0,
      0,
      0,
      311,
      297,
      1,
      0,
      0,
      0,
      312,
      33,
      1,
      0,
      0,
      0,
      313,
      316,
      3,
      32,
      16,
      0,
      314,
      315,
      5,
      6,
      0,
      0,
      315,
      317,
      3,
      32,
      16,
      0,
      316,
      314,
      1,
      0,
      0,
      0,
      316,
      317,
      1,
      0,
      0,
      0,
      317,
      324,
      1,
      0,
      0,
      0,
      318,
      319,
      5,
      7,
      0,
      0,
      319,
      320,
      3,
      32,
      16,
      0,
      320,
      321,
      5,
      6,
      0,
      0,
      321,
      322,
      3,
      32,
      16,
      0,
      322,
      324,
      1,
      0,
      0,
      0,
      323,
      313,
      1,
      0,
      0,
      0,
      323,
      318,
      1,
      0,
      0,
      0,
      324,
      35,
      1,
      0,
      0,
      0,
      325,
      326,
      3,
      32,
      16,
      0,
      326,
      37,
      1,
      0,
      0,
      0,
      327,
      333,
      5,
      19,
      0,
      0,
      328,
      329,
      3,
      36,
      18,
      0,
      329,
      330,
      5,
      25,
      0,
      0,
      330,
      332,
      1,
      0,
      0,
      0,
      331,
      328,
      1,
      0,
      0,
      0,
      332,
      335,
      1,
      0,
      0,
      0,
      333,
      331,
      1,
      0,
      0,
      0,
      333,
      334,
      1,
      0,
      0,
      0,
      334,
      337,
      1,
      0,
      0,
      0,
      335,
      333,
      1,
      0,
      0,
      0,
      336,
      338,
      3,
      36,
      18,
      0,
      337,
      336,
      1,
      0,
      0,
      0,
      337,
      338,
      1,
      0,
      0,
      0,
      338,
      339,
      1,
      0,
      0,
      0,
      339,
      340,
      5,
      20,
      0,
      0,
      340,
      39,
      1,
      0,
      0,
      0,
      43,
      44,
      49,
      54,
      56,
      62,
      69,
      76,
      79,
      84,
      88,
      102,
      106,
      115,
      119,
      128,
      139,
      143,
      149,
      160,
      163,
      170,
      173,
      181,
      185,
      189,
      193,
      223,
      237,
      241,
      252,
      259,
      270,
      277,
      287,
      292,
      294,
      304,
      308,
      311,
      316,
      323,
      333,
      337
    ];
    MangleParser.vocabulary = new antlr.Vocabulary(MangleParser.literalNames, MangleParser.symbolicNames, []);
    MangleParser.decisionsToDFA = MangleParser._ATN.decisionToState.map((ds, index) => new antlr.DFA(ds, index));
    var StartContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      program() {
        return this.getRuleContext(0, ProgramContext);
      }
      EOF() {
        return this.getToken(MangleParser.EOF, 0);
      }
      get ruleIndex() {
        return MangleParser.RULE_start;
      }
      enterRule(listener) {
        if (listener.enterStart) {
          listener.enterStart(this);
        }
      }
      exitRule(listener) {
        if (listener.exitStart) {
          listener.exitStart(this);
        }
      }
      accept(visitor) {
        if (visitor.visitStart) {
          return visitor.visitStart(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.StartContext = StartContext;
    var ProgramContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      packageDecl() {
        return this.getRuleContext(0, PackageDeclContext);
      }
      useDecl(i) {
        if (i === void 0) {
          return this.getRuleContexts(UseDeclContext);
        }
        return this.getRuleContext(i, UseDeclContext);
      }
      decl(i) {
        if (i === void 0) {
          return this.getRuleContexts(DeclContext);
        }
        return this.getRuleContext(i, DeclContext);
      }
      clause(i) {
        if (i === void 0) {
          return this.getRuleContexts(ClauseContext);
        }
        return this.getRuleContext(i, ClauseContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_program;
      }
      enterRule(listener) {
        if (listener.enterProgram) {
          listener.enterProgram(this);
        }
      }
      exitRule(listener) {
        if (listener.exitProgram) {
          listener.exitProgram(this);
        }
      }
      accept(visitor) {
        if (visitor.visitProgram) {
          return visitor.visitProgram(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ProgramContext = ProgramContext;
    var PackageDeclContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      PACKAGE() {
        return this.getToken(MangleParser.PACKAGE, 0);
      }
      NAME() {
        return this.getToken(MangleParser.NAME, 0);
      }
      BANG() {
        return this.getToken(MangleParser.BANG, 0);
      }
      atoms() {
        return this.getRuleContext(0, AtomsContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_packageDecl;
      }
      enterRule(listener) {
        if (listener.enterPackageDecl) {
          listener.enterPackageDecl(this);
        }
      }
      exitRule(listener) {
        if (listener.exitPackageDecl) {
          listener.exitPackageDecl(this);
        }
      }
      accept(visitor) {
        if (visitor.visitPackageDecl) {
          return visitor.visitPackageDecl(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.PackageDeclContext = PackageDeclContext;
    var UseDeclContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      USE() {
        return this.getToken(MangleParser.USE, 0);
      }
      NAME() {
        return this.getToken(MangleParser.NAME, 0);
      }
      BANG() {
        return this.getToken(MangleParser.BANG, 0);
      }
      atoms() {
        return this.getRuleContext(0, AtomsContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_useDecl;
      }
      enterRule(listener) {
        if (listener.enterUseDecl) {
          listener.enterUseDecl(this);
        }
      }
      exitRule(listener) {
        if (listener.exitUseDecl) {
          listener.exitUseDecl(this);
        }
      }
      accept(visitor) {
        if (visitor.visitUseDecl) {
          return visitor.visitUseDecl(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.UseDeclContext = UseDeclContext;
    var DeclContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      DECL() {
        return this.getToken(MangleParser.DECL, 0);
      }
      atom() {
        return this.getRuleContext(0, AtomContext);
      }
      descrBlock() {
        return this.getRuleContext(0, DescrBlockContext);
      }
      boundsBlock(i) {
        if (i === void 0) {
          return this.getRuleContexts(BoundsBlockContext);
        }
        return this.getRuleContext(i, BoundsBlockContext);
      }
      constraintsBlock() {
        return this.getRuleContext(0, ConstraintsBlockContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_decl;
      }
      enterRule(listener) {
        if (listener.enterDecl) {
          listener.enterDecl(this);
        }
      }
      exitRule(listener) {
        if (listener.exitDecl) {
          listener.exitDecl(this);
        }
      }
      accept(visitor) {
        if (visitor.visitDecl) {
          return visitor.visitDecl(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DeclContext = DeclContext;
    var DescrBlockContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      atoms() {
        return this.getRuleContext(0, AtomsContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_descrBlock;
      }
      enterRule(listener) {
        if (listener.enterDescrBlock) {
          listener.enterDescrBlock(this);
        }
      }
      exitRule(listener) {
        if (listener.exitDescrBlock) {
          listener.exitDescrBlock(this);
        }
      }
      accept(visitor) {
        if (visitor.visitDescrBlock) {
          return visitor.visitDescrBlock(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DescrBlockContext = DescrBlockContext;
    var BoundsBlockContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      BOUND() {
        return this.getToken(MangleParser.BOUND, 0);
      }
      LBRACKET() {
        return this.getToken(MangleParser.LBRACKET, 0);
      }
      RBRACKET() {
        return this.getToken(MangleParser.RBRACKET, 0);
      }
      term(i) {
        if (i === void 0) {
          return this.getRuleContexts(TermContext);
        }
        return this.getRuleContext(i, TermContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      get ruleIndex() {
        return MangleParser.RULE_boundsBlock;
      }
      enterRule(listener) {
        if (listener.enterBoundsBlock) {
          listener.enterBoundsBlock(this);
        }
      }
      exitRule(listener) {
        if (listener.exitBoundsBlock) {
          listener.exitBoundsBlock(this);
        }
      }
      accept(visitor) {
        if (visitor.visitBoundsBlock) {
          return visitor.visitBoundsBlock(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BoundsBlockContext = BoundsBlockContext;
    var ConstraintsBlockContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      atoms() {
        return this.getRuleContext(0, AtomsContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_constraintsBlock;
      }
      enterRule(listener) {
        if (listener.enterConstraintsBlock) {
          listener.enterConstraintsBlock(this);
        }
      }
      exitRule(listener) {
        if (listener.exitConstraintsBlock) {
          listener.exitConstraintsBlock(this);
        }
      }
      accept(visitor) {
        if (visitor.visitConstraintsBlock) {
          return visitor.visitConstraintsBlock(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ConstraintsBlockContext = ConstraintsBlockContext;
    var ClauseContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      atom() {
        return this.getRuleContext(0, AtomContext);
      }
      temporalAnnotation() {
        return this.getRuleContext(0, TemporalAnnotationContext);
      }
      clauseBody() {
        return this.getRuleContext(0, ClauseBodyContext);
      }
      COLONDASH() {
        return this.getToken(MangleParser.COLONDASH, 0);
      }
      LONGLEFTDOUBLEARROW() {
        return this.getToken(MangleParser.LONGLEFTDOUBLEARROW, 0);
      }
      get ruleIndex() {
        return MangleParser.RULE_clause;
      }
      enterRule(listener) {
        if (listener.enterClause) {
          listener.enterClause(this);
        }
      }
      exitRule(listener) {
        if (listener.exitClause) {
          listener.exitClause(this);
        }
      }
      accept(visitor) {
        if (visitor.visitClause) {
          return visitor.visitClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ClauseContext = ClauseContext;
    var TemporalAnnotationContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      AT() {
        return this.getToken(MangleParser.AT, 0);
      }
      LBRACKET() {
        return this.getToken(MangleParser.LBRACKET, 0);
      }
      temporalBound(i) {
        if (i === void 0) {
          return this.getRuleContexts(TemporalBoundContext);
        }
        return this.getRuleContext(i, TemporalBoundContext);
      }
      RBRACKET() {
        return this.getToken(MangleParser.RBRACKET, 0);
      }
      COMMA() {
        return this.getToken(MangleParser.COMMA, 0);
      }
      get ruleIndex() {
        return MangleParser.RULE_temporalAnnotation;
      }
      enterRule(listener) {
        if (listener.enterTemporalAnnotation) {
          listener.enterTemporalAnnotation(this);
        }
      }
      exitRule(listener) {
        if (listener.exitTemporalAnnotation) {
          listener.exitTemporalAnnotation(this);
        }
      }
      accept(visitor) {
        if (visitor.visitTemporalAnnotation) {
          return visitor.visitTemporalAnnotation(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TemporalAnnotationContext = TemporalAnnotationContext;
    var TemporalBoundContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      TIMESTAMP() {
        return this.getToken(MangleParser.TIMESTAMP, 0);
      }
      DURATION() {
        return this.getToken(MangleParser.DURATION, 0);
      }
      VARIABLE() {
        return this.getToken(MangleParser.VARIABLE, 0);
      }
      get ruleIndex() {
        return MangleParser.RULE_temporalBound;
      }
      enterRule(listener) {
        if (listener.enterTemporalBound) {
          listener.enterTemporalBound(this);
        }
      }
      exitRule(listener) {
        if (listener.exitTemporalBound) {
          listener.exitTemporalBound(this);
        }
      }
      accept(visitor) {
        if (visitor.visitTemporalBound) {
          return visitor.visitTemporalBound(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TemporalBoundContext = TemporalBoundContext;
    var ClauseBodyContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      literalOrFml(i) {
        if (i === void 0) {
          return this.getRuleContexts(LiteralOrFmlContext);
        }
        return this.getRuleContext(i, LiteralOrFmlContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      PIPEGREATER(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.PIPEGREATER);
        } else {
          return this.getToken(MangleParser.PIPEGREATER, i);
        }
      }
      transform(i) {
        if (i === void 0) {
          return this.getRuleContexts(TransformContext);
        }
        return this.getRuleContext(i, TransformContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_clauseBody;
      }
      enterRule(listener) {
        if (listener.enterClauseBody) {
          listener.enterClauseBody(this);
        }
      }
      exitRule(listener) {
        if (listener.exitClauseBody) {
          listener.exitClauseBody(this);
        }
      }
      accept(visitor) {
        if (visitor.visitClauseBody) {
          return visitor.visitClauseBody(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ClauseBodyContext = ClauseBodyContext;
    var TransformContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      DO() {
        return this.getToken(MangleParser.DO, 0);
      }
      term() {
        return this.getRuleContext(0, TermContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      letStmt(i) {
        if (i === void 0) {
          return this.getRuleContexts(LetStmtContext);
        }
        return this.getRuleContext(i, LetStmtContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_transform;
      }
      enterRule(listener) {
        if (listener.enterTransform) {
          listener.enterTransform(this);
        }
      }
      exitRule(listener) {
        if (listener.exitTransform) {
          listener.exitTransform(this);
        }
      }
      accept(visitor) {
        if (visitor.visitTransform) {
          return visitor.visitTransform(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TransformContext = TransformContext;
    var LetStmtContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      LET() {
        return this.getToken(MangleParser.LET, 0);
      }
      VARIABLE() {
        return this.getToken(MangleParser.VARIABLE, 0);
      }
      EQ() {
        return this.getToken(MangleParser.EQ, 0);
      }
      term() {
        return this.getRuleContext(0, TermContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_letStmt;
      }
      enterRule(listener) {
        if (listener.enterLetStmt) {
          listener.enterLetStmt(this);
        }
      }
      exitRule(listener) {
        if (listener.exitLetStmt) {
          listener.exitLetStmt(this);
        }
      }
      accept(visitor) {
        if (visitor.visitLetStmt) {
          return visitor.visitLetStmt(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LetStmtContext = LetStmtContext;
    var LiteralOrFmlContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      term(i) {
        if (i === void 0) {
          return this.getRuleContexts(TermContext);
        }
        return this.getRuleContext(i, TermContext);
      }
      temporalOperator() {
        return this.getRuleContext(0, TemporalOperatorContext);
      }
      temporalAnnotation() {
        return this.getRuleContext(0, TemporalAnnotationContext);
      }
      EQ() {
        return this.getToken(MangleParser.EQ, 0);
      }
      BANGEQ() {
        return this.getToken(MangleParser.BANGEQ, 0);
      }
      LESS() {
        return this.getToken(MangleParser.LESS, 0);
      }
      LESSEQ() {
        return this.getToken(MangleParser.LESSEQ, 0);
      }
      GREATER() {
        return this.getToken(MangleParser.GREATER, 0);
      }
      GREATEREQ() {
        return this.getToken(MangleParser.GREATEREQ, 0);
      }
      BANG() {
        return this.getToken(MangleParser.BANG, 0);
      }
      get ruleIndex() {
        return MangleParser.RULE_literalOrFml;
      }
      enterRule(listener) {
        if (listener.enterLiteralOrFml) {
          listener.enterLiteralOrFml(this);
        }
      }
      exitRule(listener) {
        if (listener.exitLiteralOrFml) {
          listener.exitLiteralOrFml(this);
        }
      }
      accept(visitor) {
        if (visitor.visitLiteralOrFml) {
          return visitor.visitLiteralOrFml(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LiteralOrFmlContext = LiteralOrFmlContext;
    var TemporalOperatorContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      DIAMONDMINUS() {
        return this.getToken(MangleParser.DIAMONDMINUS, 0);
      }
      LBRACKET() {
        return this.getToken(MangleParser.LBRACKET, 0);
      }
      temporalBound(i) {
        if (i === void 0) {
          return this.getRuleContexts(TemporalBoundContext);
        }
        return this.getRuleContext(i, TemporalBoundContext);
      }
      COMMA() {
        return this.getToken(MangleParser.COMMA, 0);
      }
      RBRACKET() {
        return this.getToken(MangleParser.RBRACKET, 0);
      }
      BOXMINUS() {
        return this.getToken(MangleParser.BOXMINUS, 0);
      }
      DIAMONDPLUS() {
        return this.getToken(MangleParser.DIAMONDPLUS, 0);
      }
      BOXPLUS() {
        return this.getToken(MangleParser.BOXPLUS, 0);
      }
      get ruleIndex() {
        return MangleParser.RULE_temporalOperator;
      }
      enterRule(listener) {
        if (listener.enterTemporalOperator) {
          listener.enterTemporalOperator(this);
        }
      }
      exitRule(listener) {
        if (listener.exitTemporalOperator) {
          listener.exitTemporalOperator(this);
        }
      }
      accept(visitor) {
        if (visitor.visitTemporalOperator) {
          return visitor.visitTemporalOperator(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TemporalOperatorContext = TemporalOperatorContext;
    var TermContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      get ruleIndex() {
        return MangleParser.RULE_term;
      }
      copyFrom(ctx) {
        super.copyFrom(ctx);
      }
    };
    exports2.TermContext = TermContext;
    var StrContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      STRING() {
        return this.getToken(MangleParser.STRING, 0);
      }
      enterRule(listener) {
        if (listener.enterStr) {
          listener.enterStr(this);
        }
      }
      exitRule(listener) {
        if (listener.exitStr) {
          listener.exitStr(this);
        }
      }
      accept(visitor) {
        if (visitor.visitStr) {
          return visitor.visitStr(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.StrContext = StrContext;
    var BStrContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      BYTESTRING() {
        return this.getToken(MangleParser.BYTESTRING, 0);
      }
      enterRule(listener) {
        if (listener.enterBStr) {
          listener.enterBStr(this);
        }
      }
      exitRule(listener) {
        if (listener.exitBStr) {
          listener.exitBStr(this);
        }
      }
      accept(visitor) {
        if (visitor.visitBStr) {
          return visitor.visitBStr(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BStrContext = BStrContext;
    var FloatContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      FLOAT() {
        return this.getToken(MangleParser.FLOAT, 0);
      }
      enterRule(listener) {
        if (listener.enterFloat) {
          listener.enterFloat(this);
        }
      }
      exitRule(listener) {
        if (listener.exitFloat) {
          listener.exitFloat(this);
        }
      }
      accept(visitor) {
        if (visitor.visitFloat) {
          return visitor.visitFloat(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FloatContext = FloatContext;
    var ApplContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      NAME() {
        return this.getToken(MangleParser.NAME, 0);
      }
      LPAREN() {
        return this.getToken(MangleParser.LPAREN, 0);
      }
      RPAREN() {
        return this.getToken(MangleParser.RPAREN, 0);
      }
      term(i) {
        if (i === void 0) {
          return this.getRuleContexts(TermContext);
        }
        return this.getRuleContext(i, TermContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      enterRule(listener) {
        if (listener.enterAppl) {
          listener.enterAppl(this);
        }
      }
      exitRule(listener) {
        if (listener.exitAppl) {
          listener.exitAppl(this);
        }
      }
      accept(visitor) {
        if (visitor.visitAppl) {
          return visitor.visitAppl(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ApplContext = ApplContext;
    var VarContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      VARIABLE() {
        return this.getToken(MangleParser.VARIABLE, 0);
      }
      enterRule(listener) {
        if (listener.enterVar) {
          listener.enterVar(this);
        }
      }
      exitRule(listener) {
        if (listener.exitVar) {
          listener.exitVar(this);
        }
      }
      accept(visitor) {
        if (visitor.visitVar) {
          return visitor.visitVar(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.VarContext = VarContext;
    var ConstContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      CONSTANT() {
        return this.getToken(MangleParser.CONSTANT, 0);
      }
      enterRule(listener) {
        if (listener.enterConst) {
          listener.enterConst(this);
        }
      }
      exitRule(listener) {
        if (listener.exitConst) {
          listener.exitConst(this);
        }
      }
      accept(visitor) {
        if (visitor.visitConst) {
          return visitor.visitConst(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ConstContext = ConstContext;
    var NumContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      NUMBER() {
        return this.getToken(MangleParser.NUMBER, 0);
      }
      enterRule(listener) {
        if (listener.enterNum) {
          listener.enterNum(this);
        }
      }
      exitRule(listener) {
        if (listener.exitNum) {
          listener.exitNum(this);
        }
      }
      accept(visitor) {
        if (visitor.visitNum) {
          return visitor.visitNum(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.NumContext = NumContext;
    var ListContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      LBRACKET() {
        return this.getToken(MangleParser.LBRACKET, 0);
      }
      RBRACKET() {
        return this.getToken(MangleParser.RBRACKET, 0);
      }
      term(i) {
        if (i === void 0) {
          return this.getRuleContexts(TermContext);
        }
        return this.getRuleContext(i, TermContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      enterRule(listener) {
        if (listener.enterList) {
          listener.enterList(this);
        }
      }
      exitRule(listener) {
        if (listener.exitList) {
          listener.exitList(this);
        }
      }
      accept(visitor) {
        if (visitor.visitList) {
          return visitor.visitList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ListContext = ListContext;
    var MapContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      LBRACKET() {
        return this.getToken(MangleParser.LBRACKET, 0);
      }
      RBRACKET() {
        return this.getToken(MangleParser.RBRACKET, 0);
      }
      term(i) {
        if (i === void 0) {
          return this.getRuleContexts(TermContext);
        }
        return this.getRuleContext(i, TermContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      enterRule(listener) {
        if (listener.enterMap) {
          listener.enterMap(this);
        }
      }
      exitRule(listener) {
        if (listener.exitMap) {
          listener.exitMap(this);
        }
      }
      accept(visitor) {
        if (visitor.visitMap) {
          return visitor.visitMap(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MapContext = MapContext;
    var StructContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      LBRACE() {
        return this.getToken(MangleParser.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(MangleParser.RBRACE, 0);
      }
      term(i) {
        if (i === void 0) {
          return this.getRuleContexts(TermContext);
        }
        return this.getRuleContext(i, TermContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      enterRule(listener) {
        if (listener.enterStruct) {
          listener.enterStruct(this);
        }
      }
      exitRule(listener) {
        if (listener.exitStruct) {
          listener.exitStruct(this);
        }
      }
      accept(visitor) {
        if (visitor.visitStruct) {
          return visitor.visitStruct(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.StructContext = StructContext;
    var DotTypeContext = class extends TermContext {
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
      }
      DOT_TYPE() {
        return this.getToken(MangleParser.DOT_TYPE, 0);
      }
      LESS() {
        return this.getToken(MangleParser.LESS, 0);
      }
      GREATER() {
        return this.getToken(MangleParser.GREATER, 0);
      }
      member(i) {
        if (i === void 0) {
          return this.getRuleContexts(MemberContext);
        }
        return this.getRuleContext(i, MemberContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      enterRule(listener) {
        if (listener.enterDotType) {
          listener.enterDotType(this);
        }
      }
      exitRule(listener) {
        if (listener.exitDotType) {
          listener.exitDotType(this);
        }
      }
      accept(visitor) {
        if (visitor.visitDotType) {
          return visitor.visitDotType(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DotTypeContext = DotTypeContext;
    var MemberContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      term(i) {
        if (i === void 0) {
          return this.getRuleContexts(TermContext);
        }
        return this.getRuleContext(i, TermContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_member;
      }
      enterRule(listener) {
        if (listener.enterMember) {
          listener.enterMember(this);
        }
      }
      exitRule(listener) {
        if (listener.exitMember) {
          listener.exitMember(this);
        }
      }
      accept(visitor) {
        if (visitor.visitMember) {
          return visitor.visitMember(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MemberContext = MemberContext;
    var AtomContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      term() {
        return this.getRuleContext(0, TermContext);
      }
      get ruleIndex() {
        return MangleParser.RULE_atom;
      }
      enterRule(listener) {
        if (listener.enterAtom) {
          listener.enterAtom(this);
        }
      }
      exitRule(listener) {
        if (listener.exitAtom) {
          listener.exitAtom(this);
        }
      }
      accept(visitor) {
        if (visitor.visitAtom) {
          return visitor.visitAtom(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.AtomContext = AtomContext;
    var AtomsContext = class extends antlr.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      LBRACKET() {
        return this.getToken(MangleParser.LBRACKET, 0);
      }
      RBRACKET() {
        return this.getToken(MangleParser.RBRACKET, 0);
      }
      atom(i) {
        if (i === void 0) {
          return this.getRuleContexts(AtomContext);
        }
        return this.getRuleContext(i, AtomContext);
      }
      COMMA(i) {
        if (i === void 0) {
          return this.getTokens(MangleParser.COMMA);
        } else {
          return this.getToken(MangleParser.COMMA, i);
        }
      }
      get ruleIndex() {
        return MangleParser.RULE_atoms;
      }
      enterRule(listener) {
        if (listener.enterAtoms) {
          listener.enterAtoms(this);
        }
      }
      exitRule(listener) {
        if (listener.exitAtoms) {
          listener.exitAtoms(this);
        }
      }
      accept(visitor) {
        if (visitor.visitAtoms) {
          return visitor.visitAtoms(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.AtomsContext = AtomsContext;
  }
});

// server/parser/visitor.js
var require_visitor = __commonJS({
  "server/parser/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MangleASTVisitor = exports2.ERROR_SYMBOL = void 0;
    var antlr4ng_1 = require_dist();
    var ast_1 = require_ast();
    exports2.ERROR_SYMBOL = "$$error$$";
    var MangleParser_1 = require_MangleParser();
    function getRangeFromContext(ctx) {
      const startToken = ctx.start;
      const stopToken = ctx.stop ?? startToken;
      const stopText = stopToken?.text ?? "";
      const stopLines = stopText.split("\n");
      const stopNumNewlines = stopLines.length - 1;
      let endLine = (stopToken?.line ?? 1) + stopNumNewlines;
      let endColumn;
      if (stopNumNewlines > 0) {
        const lastLine = stopLines[stopLines.length - 1];
        endColumn = lastLine?.length ?? 0;
      } else {
        endColumn = (stopToken?.column ?? 0) + stopText.length;
      }
      return {
        start: {
          line: startToken?.line ?? 1,
          column: startToken?.column ?? 0,
          offset: startToken?.start ?? 0
        },
        end: {
          line: endLine,
          column: endColumn,
          offset: (stopToken?.stop ?? 0) + 1
        }
      };
    }
    function getRangeFromToken(token) {
      const text = token.text ?? "";
      const lines = text.split("\n");
      const numNewlines = lines.length - 1;
      let endLine = token.line + numNewlines;
      let endColumn;
      if (numNewlines > 0) {
        const lastLine = lines[lines.length - 1];
        endColumn = lastLine?.length ?? 0;
      } else {
        endColumn = token.column + text.length;
      }
      return {
        start: {
          line: token.line,
          column: token.column,
          offset: token.start
        },
        end: {
          line: endLine,
          column: endColumn,
          offset: token.stop + 1
        }
      };
    }
    function unescapeString(s) {
      let inner;
      if (s.startsWith("`")) {
        inner = s.slice(1, -1);
      } else if (s.startsWith('"') || s.startsWith("'")) {
        inner = s.slice(1, -1);
      } else {
        inner = s;
      }
      let result = "";
      let i = 0;
      while (i < inner.length) {
        if (inner[i] === "\\" && i + 1 < inner.length) {
          const next = inner[i + 1];
          switch (next) {
            case "n":
              result += "\n";
              i += 2;
              break;
            case "t":
              result += "	";
              i += 2;
              break;
            case '"':
              result += '"';
              i += 2;
              break;
            case "'":
              result += "'";
              i += 2;
              break;
            case "\\":
              result += "\\";
              i += 2;
              break;
            case "x":
              if (i + 3 < inner.length) {
                const hex = inner.slice(i + 2, i + 4);
                const code = parseInt(hex, 16);
                if (!isNaN(code)) {
                  result += String.fromCharCode(code);
                  i += 4;
                  break;
                }
              }
              result += inner[i];
              i++;
              break;
            case "u":
              if (i + 4 < inner.length && inner[i + 2] === "{") {
                const endBrace = inner.indexOf("}", i + 3);
                if (endBrace !== -1) {
                  const hex = inner.slice(i + 3, endBrace);
                  const code = parseInt(hex, 16);
                  if (!isNaN(code)) {
                    result += String.fromCodePoint(code);
                    i = endBrace + 1;
                    break;
                  }
                }
              }
              result += inner[i];
              i++;
              break;
            case "\n":
              i += 2;
              break;
            default:
              result += inner[i];
              i++;
          }
        } else {
          result += inner[i];
          i++;
        }
      }
      return result;
    }
    function unescapeByteString(s) {
      return unescapeString(s.slice(1));
    }
    var MangleASTVisitor = class extends antlr4ng_1.AbstractParseTreeVisitor {
      constructor() {
        super(...arguments);
        this.errors = [];
        this.partialUnit = null;
      }
      defaultResult() {
        return null;
      }
      /**
       * Get all errors collected during AST construction.
       */
      getErrors() {
        return this.errors;
      }
      /**
       * Get the partial unit built so far (for error recovery).
       * Returns the last successfully built unit, or null if none.
       */
      getPartialUnit() {
        return this.partialUnit;
      }
      /**
       * Record an error and return a range from the context.
       */
      addError(message, ctx) {
        const range = getRangeFromContext(ctx);
        this.errors.push({
          message,
          line: range.start.line,
          column: range.start.column,
          offset: range.start.offset,
          length: range.end.offset - range.start.offset
        });
      }
      /**
       * Create an error placeholder atom.
       */
      createErrorAtom(ctx) {
        return (0, ast_1.createAtom)((0, ast_1.createPredicateSym)(exports2.ERROR_SYMBOL, 0), [], getRangeFromContext(ctx));
      }
      /**
       * Create an error placeholder variable.
       */
      createErrorVariable(ctx) {
        return (0, ast_1.createVariable)(exports2.ERROR_SYMBOL, getRangeFromContext(ctx));
      }
      /**
       * Create an error placeholder ApplyFn.
       */
      createErrorApplyFn(ctx) {
        return (0, ast_1.createApplyFn)((0, ast_1.createFunctionSym)(`fn:${exports2.ERROR_SYMBOL}`, 0), [], getRangeFromContext(ctx));
      }
      visitStart(ctx) {
        return this.visitProgram(ctx.program());
      }
      visitProgram(ctx) {
        let packageDecl = null;
        const packageDeclCtx = ctx.packageDecl();
        if (packageDeclCtx) {
          try {
            packageDecl = this.visitPackageDecl(packageDeclCtx);
          } catch (e) {
            this.addError(`Failed to parse package declaration: ${e instanceof Error ? e.message : String(e)}`, packageDeclCtx);
          }
        }
        const useDecls = [];
        for (const useDeclCtx of ctx.useDecl()) {
          try {
            useDecls.push(this.visitUseDecl(useDeclCtx));
          } catch (e) {
            this.addError(`Failed to parse use declaration: ${e instanceof Error ? e.message : String(e)}`, useDeclCtx);
          }
        }
        const decls = [];
        for (const declCtx of ctx.decl()) {
          try {
            decls.push(this.visitDecl(declCtx));
          } catch (e) {
            this.addError(`Failed to parse declaration: ${e instanceof Error ? e.message : String(e)}`, declCtx);
          }
        }
        const clauses = [];
        for (const clauseCtx of ctx.clause()) {
          try {
            clauses.push(this.visitClause(clauseCtx));
          } catch (e) {
            this.addError(`Failed to parse clause: ${e instanceof Error ? e.message : String(e)}`, clauseCtx);
          }
        }
        const unit = { packageDecl, useDecls, decls, clauses };
        this.partialUnit = unit;
        return unit;
      }
      visitPackageDecl(ctx) {
        const name = ctx.NAME().getText();
        if (name !== name.toLowerCase()) {
          this.addError(`package names have to be lower-case: ${name}`, ctx);
        }
        const atomsCtx = ctx.atoms();
        const atoms = atomsCtx ? this.visitAtoms(atomsCtx) : null;
        return {
          type: "PackageDecl",
          name,
          atoms,
          range: getRangeFromContext(ctx)
        };
      }
      visitUseDecl(ctx) {
        const name = ctx.NAME().getText();
        const atomsCtx = ctx.atoms();
        const atoms = atomsCtx ? this.visitAtoms(atomsCtx) : null;
        return {
          type: "UseDecl",
          name,
          atoms,
          range: getRangeFromContext(ctx)
        };
      }
      visitDecl(ctx) {
        const atomCtx = ctx.atom();
        const declaredAtom = this.visitAtom(atomCtx);
        const descrCtx = ctx.descrBlock();
        let descr = descrCtx ? this.visitDescrBlock(descrCtx) : null;
        const ctxText = ctx.getText();
        if (ctxText.includes("temporal")) {
          const children = ctx.children ?? [];
          for (const child of children) {
            if ("getText" in child && child.getText() === "temporal") {
              const temporalAtom = (0, ast_1.createAtom)((0, ast_1.createPredicateSym)(ast_1.DESCRIPTORS.TEMPORAL, 0), [], getRangeFromContext(ctx));
              if (descr) {
                descr = [...descr, temporalAtom];
              } else {
                descr = [temporalAtom];
              }
              break;
            }
          }
        }
        const boundsCtxs = ctx.boundsBlock();
        const bounds = boundsCtxs.length > 0 ? boundsCtxs.map((b) => this.visitBoundsBlock(b)) : null;
        const constraintsCtx = ctx.constraintsBlock();
        const constraints = constraintsCtx ? this.visitConstraintsBlock(constraintsCtx) : null;
        return {
          type: "Decl",
          declaredAtom,
          descr,
          bounds,
          constraints,
          range: getRangeFromContext(ctx)
        };
      }
      visitDescrBlock(ctx) {
        return this.visitAtoms(ctx.atoms());
      }
      visitBoundsBlock(ctx) {
        const terms = ctx.term();
        const bounds = terms.map((t) => this.visitTerm(t));
        return {
          bounds,
          range: getRangeFromContext(ctx)
        };
      }
      visitConstraintsBlock(ctx) {
        return this.visitAtoms(ctx.atoms());
      }
      visitAtoms(ctx) {
        return ctx.atom().map((a) => this.visitAtom(a));
      }
      visitAtom(ctx) {
        const termCtx = ctx.term();
        const term = this.visitTerm(termCtx);
        if (term && "predicate" in term && term.type === "Atom") {
          return term;
        }
        if (term && term.type === "Variable") {
          return {
            type: "Atom",
            predicate: (0, ast_1.createPredicateSym)(term.symbol, 0),
            args: [],
            range: term.range
          };
        }
        this.addError(`Expected atom but got ${term?.type ?? "null"}`, ctx);
        return this.createErrorAtom(ctx);
      }
      visitClause(ctx) {
        const atomCtx = ctx.atom();
        const head = this.visitAtom(atomCtx);
        let headTime = null;
        const tempAnnotCtx = ctx.temporalAnnotation();
        if (tempAnnotCtx) {
          headTime = this.visitTemporalAnnotation(tempAnnotCtx);
        }
        const bodyCtx = ctx.clauseBody();
        let premises = null;
        let transform = null;
        if (bodyCtx) {
          const bodyResult = this.visitClauseBody(bodyCtx);
          premises = bodyResult.premises;
          transform = bodyResult.transform;
        }
        return {
          type: "Clause",
          head,
          premises,
          transform,
          headTime,
          range: getRangeFromContext(ctx)
        };
      }
      visitClauseBody(ctx) {
        const literalCtxs = ctx.literalOrFml();
        const premises = literalCtxs.map((l) => this.visitLiteralOrFml(l));
        const transformCtxs = ctx.transform();
        let transform = null;
        if (transformCtxs.length > 0) {
          for (let i = transformCtxs.length - 1; i >= 0; i--) {
            const transformCtx = transformCtxs[i];
            if (transformCtx) {
              const t = this.visitTransform(transformCtx);
              t.next = transform;
              transform = t;
            }
          }
        }
        return { premises, transform };
      }
      visitTransform(ctx) {
        const statements = [];
        const doToken = ctx.DO();
        if (doToken) {
          const termCtx = ctx.term();
          if (termCtx) {
            const fn = this.visitTerm(termCtx);
            if (fn && fn.type === "ApplyFn") {
              statements.push({
                variable: null,
                fn,
                range: getRangeFromContext(ctx)
              });
            }
          }
        }
        const letStmts = ctx.letStmt();
        for (const letCtx of letStmts) {
          statements.push(this.visitLetStmt(letCtx));
        }
        return {
          statements,
          next: null,
          // Will be set by caller when building chain
          range: getRangeFromContext(ctx)
        };
      }
      visitLetStmt(ctx) {
        const varToken = ctx.VARIABLE();
        const variable = {
          type: "Variable",
          symbol: varToken.getText(),
          range: getRangeFromToken(varToken.symbol)
        };
        const termCtx = ctx.term();
        if (!termCtx) {
          this.addError("Expected term in let statement", ctx);
          return {
            variable,
            fn: this.createErrorApplyFn(ctx),
            range: getRangeFromContext(ctx)
          };
        }
        const fn = this.visitTerm(termCtx);
        return {
          variable,
          fn,
          range: getRangeFromContext(ctx)
        };
      }
      visitLiteralOrFml(ctx) {
        const bangToken = ctx.BANG();
        if (bangToken) {
          const termCtx = ctx.term(0);
          if (!termCtx) {
            this.addError("Expected term after negation", ctx);
            return this.createErrorAtom(ctx);
          }
          const term = this.visitTerm(termCtx);
          if (term && term.type === "Atom") {
            const negAtom = {
              type: "NegAtom",
              atom: term,
              range: getRangeFromContext(ctx)
            };
            return negAtom;
          }
          this.addError("Negation must be applied to an atom", ctx);
          return {
            type: "NegAtom",
            atom: this.createErrorAtom(ctx),
            range: getRangeFromContext(ctx)
          };
        }
        let tempOp = null;
        const tempOpCtx = ctx.temporalOperator();
        if (tempOpCtx) {
          tempOp = this.visitTemporalOperator(tempOpCtx);
        }
        let tempAnnot = null;
        const tempAnnotCtx = ctx.temporalAnnotation();
        if (tempAnnotCtx) {
          tempAnnot = this.visitTemporalAnnotation(tempAnnotCtx);
        }
        const termCtxs = ctx.term();
        if (termCtxs.length === 1) {
          const termCtx = termCtxs[0];
          if (!termCtx) {
            this.addError("Expected term", ctx);
            return this.createErrorVariable(ctx);
          }
          const term = this.visitTerm(termCtx);
          if (term && term.type === "Atom" && (tempOp !== null || tempAnnot !== null)) {
            return {
              type: "TemporalLiteral",
              literal: term,
              operator: tempOp,
              interval: tempAnnot,
              range: getRangeFromContext(ctx)
            };
          }
          return term;
        }
        const leftCtx = termCtxs[0];
        const rightCtx = termCtxs[1];
        if (!leftCtx || !rightCtx) {
          this.addError("Expected two terms for comparison", ctx);
          const errorVar = this.createErrorVariable(ctx);
          return { type: "Eq", left: errorVar, right: errorVar, range: getRangeFromContext(ctx) };
        }
        const left = this.visitTerm(leftCtx);
        const right = this.visitTerm(rightCtx);
        const range = getRangeFromContext(ctx);
        if (ctx.EQ()) {
          return { type: "Eq", left, right, range };
        }
        if (ctx.BANGEQ()) {
          return { type: "Ineq", left, right, range };
        }
        if (ctx.LESS()) {
          return (0, ast_1.createAtom)((0, ast_1.createPredicateSym)(":lt", 2), [left, right], range);
        }
        if (ctx.LESSEQ()) {
          return (0, ast_1.createAtom)((0, ast_1.createPredicateSym)(":le", 2), [left, right], range);
        }
        if (ctx.GREATER()) {
          return (0, ast_1.createAtom)((0, ast_1.createPredicateSym)(":gt", 2), [left, right], range);
        }
        if (ctx.GREATEREQ()) {
          return (0, ast_1.createAtom)((0, ast_1.createPredicateSym)(":ge", 2), [left, right], range);
        }
        const firstTermCtx = termCtxs[0];
        if (!firstTermCtx) {
          this.addError("Expected at least one term", ctx);
          return this.createErrorVariable(ctx);
        }
        return this.visitTerm(firstTermCtx);
      }
      visitTerm(ctx) {
        if (ctx instanceof MangleParser_1.VarContext) {
          return this.visitVar(ctx);
        }
        if (ctx instanceof MangleParser_1.ConstContext) {
          return this.visitConst(ctx);
        }
        if (ctx instanceof MangleParser_1.NumContext) {
          return this.visitNum(ctx);
        }
        if (ctx instanceof MangleParser_1.FloatContext) {
          return this.visitFloat(ctx);
        }
        if (ctx instanceof MangleParser_1.StrContext) {
          return this.visitStr(ctx);
        }
        if (ctx instanceof MangleParser_1.BStrContext) {
          return this.visitBStr(ctx);
        }
        if (ctx instanceof MangleParser_1.ListContext) {
          return this.visitList(ctx);
        }
        if (ctx instanceof MangleParser_1.MapContext) {
          return this.visitMap(ctx);
        }
        if (ctx instanceof MangleParser_1.StructContext) {
          return this.visitStruct(ctx);
        }
        if (ctx instanceof MangleParser_1.ApplContext) {
          return this.visitAppl(ctx);
        }
        if (ctx instanceof MangleParser_1.DotTypeContext) {
          return this.visitDotType(ctx);
        }
        return this.visitChildren(ctx);
      }
      visitVar(ctx) {
        const token = ctx.VARIABLE();
        return {
          type: "Variable",
          symbol: token.getText(),
          range: getRangeFromToken(token.symbol)
        };
      }
      visitConst(ctx) {
        const token = ctx.CONSTANT();
        return {
          type: "Constant",
          constantType: "name",
          symbol: token.getText(),
          range: getRangeFromToken(token.symbol)
        };
      }
      visitNum(ctx) {
        const token = ctx.NUMBER();
        const text = token.getText();
        return {
          type: "Constant",
          constantType: "number",
          numValue: parseInt(text, 10),
          range: getRangeFromToken(token.symbol)
        };
      }
      visitFloat(ctx) {
        const token = ctx.FLOAT();
        const text = token.getText();
        return {
          type: "Constant",
          constantType: "float64",
          floatValue: parseFloat(text),
          range: getRangeFromToken(token.symbol)
        };
      }
      visitStr(ctx) {
        const token = ctx.STRING();
        const text = token.getText();
        return {
          type: "Constant",
          constantType: "string",
          symbol: unescapeString(text),
          range: getRangeFromToken(token.symbol)
        };
      }
      visitBStr(ctx) {
        const token = ctx.BYTESTRING();
        const text = token.getText();
        return {
          type: "Constant",
          constantType: "bytes",
          symbol: unescapeByteString(text),
          range: getRangeFromToken(token.symbol)
        };
      }
      visitList(ctx) {
        const termCtxs = ctx.term();
        const args = [];
        for (const termCtx of termCtxs) {
          const term = this.visitTerm(termCtx);
          if (term && (term.type === "Constant" || term.type === "Variable" || term.type === "ApplyFn")) {
            args.push(term);
          }
        }
        return (0, ast_1.createApplyFn)((0, ast_1.createFunctionSym)("fn:list", -1), args, getRangeFromContext(ctx));
      }
      visitMap(ctx) {
        const termCtxs = ctx.term();
        const args = [];
        for (const termCtx of termCtxs) {
          const term = this.visitTerm(termCtx);
          if (term && (term.type === "Constant" || term.type === "Variable" || term.type === "ApplyFn")) {
            args.push(term);
          }
        }
        return (0, ast_1.createApplyFn)((0, ast_1.createFunctionSym)("fn:map", -1), args, getRangeFromContext(ctx));
      }
      visitStruct(ctx) {
        const termCtxs = ctx.term();
        const args = [];
        for (const termCtx of termCtxs) {
          const term = this.visitTerm(termCtx);
          if (term && (term.type === "Constant" || term.type === "Variable" || term.type === "ApplyFn")) {
            args.push(term);
          }
        }
        return (0, ast_1.createApplyFn)((0, ast_1.createFunctionSym)("fn:struct", -1), args, getRangeFromContext(ctx));
      }
      visitDotType(ctx) {
        const typeToken = ctx.DOT_TYPE();
        const typeName = typeToken.getText().slice(1);
        const memberCtxs = ctx.member();
        const args = [];
        for (const memberCtx of memberCtxs) {
          const memberTerms = this.visitMember(memberCtx);
          args.push(...memberTerms);
        }
        return (0, ast_1.createApplyFn)((0, ast_1.createFunctionSym)("fn:" + typeName, -1), args, getRangeFromContext(ctx));
      }
      visitMember(ctx) {
        const termCtxs = ctx.term();
        const baseterms = [];
        for (const termCtx of termCtxs) {
          const term = this.visitTerm(termCtx);
          if (term && (term.type === "Constant" || term.type === "Variable" || term.type === "ApplyFn")) {
            baseterms.push(term);
          }
        }
        if (ctx.getText().startsWith("opt")) {
          return [(0, ast_1.createApplyFn)((0, ast_1.createFunctionSym)("fn:opt", -1), baseterms, getRangeFromContext(ctx))];
        }
        return baseterms;
      }
      visitAppl(ctx) {
        const nameToken = ctx.NAME();
        const name = nameToken.getText();
        const termCtxs = ctx.term();
        const args = termCtxs.map((t) => this.visitTerm(t));
        const range = getRangeFromContext(ctx);
        if (name.startsWith("fn:")) {
          return {
            type: "ApplyFn",
            function: (0, ast_1.createFunctionSym)(name, args.length),
            args,
            range
          };
        }
        return {
          type: "Atom",
          predicate: (0, ast_1.createPredicateSym)(name, args.length),
          args,
          range
        };
      }
      // ========================================================================
      // Temporal Visitor Methods (upstream parse.go:786-896)
      // ========================================================================
      /**
       * Visit a temporal annotation: @[bound] or @[bound, bound]
       * Returns a TemporalInterval.
       * Upstream: parse.go:786-812
       */
      visitTemporalAnnotation(ctx) {
        const boundCtxs = ctx.temporalBound();
        if (boundCtxs.length === 0) {
          this.addError("temporal annotation requires at least one bound", ctx);
          return {
            start: { boundType: "negativeInfinity", range: getRangeFromContext(ctx) },
            end: { boundType: "positiveInfinity", range: getRangeFromContext(ctx) },
            range: getRangeFromContext(ctx)
          };
        }
        let start = this.visitTemporalBound(boundCtxs[0]);
        let end;
        if (boundCtxs.length > 1) {
          end = this.visitTemporalBound(boundCtxs[1]);
        } else {
          end = { ...start };
        }
        if (start.boundType === "variable" && start.variable?.symbol === "_") {
          start = { boundType: "negativeInfinity", range: start.range };
        }
        if (end.boundType === "variable" && end.variable?.symbol === "_") {
          end = { boundType: "positiveInfinity", range: end.range };
        }
        return {
          start,
          end,
          range: getRangeFromContext(ctx)
        };
      }
      /**
       * Visit a temporal bound: TIMESTAMP | DURATION | VARIABLE | 'now'
       * Returns a TemporalBound.
       * Upstream: parse.go:816-849
       */
      visitTemporalBound(ctx) {
        const range = getRangeFromContext(ctx);
        const tsToken = ctx.TIMESTAMP();
        if (tsToken) {
          const text = tsToken.getText();
          const nanos = parseTimestamp(text);
          if (nanos === null) {
            this.addError(`invalid timestamp "${text}"`, ctx);
            return { boundType: "timestamp", value: 0, rawText: text, range };
          }
          return { boundType: "timestamp", value: nanos, rawText: text, range };
        }
        const durToken = ctx.DURATION();
        if (durToken) {
          const text = durToken.getText();
          const nanos = parseDuration(text);
          if (nanos === null) {
            this.addError(`invalid duration "${text}"`, ctx);
            return { boundType: "duration", value: 0, rawText: text, range };
          }
          return { boundType: "duration", value: nanos, rawText: text, range };
        }
        const varToken = ctx.VARIABLE();
        if (varToken) {
          const text = varToken.getText();
          const variable = {
            type: "Variable",
            symbol: text,
            range: getRangeFromToken(varToken.symbol)
          };
          return { boundType: "variable", variable, range };
        }
        if (ctx.getText() === "now") {
          return { boundType: "now", range };
        }
        this.addError("unknown temporal bound", ctx);
        return { boundType: "timestamp", value: 0, range };
      }
      /**
       * Visit a temporal operator: <-[b,b] | [-[b,b] | <+[b,b] | [+[b,b]
       * Returns a TemporalOperator.
       * Upstream: parse.go:853-896
       */
      visitTemporalOperator(ctx) {
        const boundCtxs = ctx.temporalBound();
        if (boundCtxs.length !== 2) {
          this.addError("temporal operator requires exactly two bounds", ctx);
          return {
            operatorType: "diamondMinus",
            interval: {
              start: { boundType: "duration", value: 0, range: getRangeFromContext(ctx) },
              end: { boundType: "duration", value: 0, range: getRangeFromContext(ctx) },
              range: getRangeFromContext(ctx)
            },
            range: getRangeFromContext(ctx)
          };
        }
        const start = this.visitTemporalBound(boundCtxs[0]);
        const end = this.visitTemporalBound(boundCtxs[1]);
        const interval = {
          start,
          end,
          range: getRangeFromContext(ctx)
        };
        let operatorType;
        if (ctx.DIAMONDMINUS()) {
          operatorType = "diamondMinus";
        } else if (ctx.BOXMINUS()) {
          operatorType = "boxMinus";
        } else if (ctx.DIAMONDPLUS()) {
          operatorType = "diamondPlus";
        } else if (ctx.BOXPLUS()) {
          operatorType = "boxPlus";
        } else {
          this.addError("unknown temporal operator", ctx);
          operatorType = "diamondMinus";
        }
        return {
          operatorType,
          interval,
          range: getRangeFromContext(ctx)
        };
      }
    };
    exports2.MangleASTVisitor = MangleASTVisitor;
    function parseTimestamp(s) {
      const date = new Date(s);
      if (!isNaN(date.getTime())) {
        return date.getTime() * 1e6;
      }
      const dateMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
      if (dateMatch) {
        const d = new Date(Date.UTC(parseInt(dateMatch[1], 10), parseInt(dateMatch[2], 10) - 1, parseInt(dateMatch[3], 10)));
        if (!isNaN(d.getTime())) {
          return d.getTime() * 1e6;
        }
      }
      return null;
    }
    function parseDuration(s) {
      if (!s)
        return null;
      const match = /^(-?\d+)(ms|d|h|m|s)$/.exec(s);
      if (!match)
        return null;
      const value = parseInt(match[1], 10);
      const unit = match[2];
      const NS_PER_MS = 1e6;
      const NS_PER_SEC = 1e9;
      const NS_PER_MIN = 60 * NS_PER_SEC;
      const NS_PER_HOUR = 60 * NS_PER_MIN;
      const NS_PER_DAY = 24 * NS_PER_HOUR;
      switch (unit) {
        case "ms":
          return value * NS_PER_MS;
        case "s":
          return value * NS_PER_SEC;
        case "m":
          return value * NS_PER_MIN;
        case "h":
          return value * NS_PER_HOUR;
        case "d":
          return value * NS_PER_DAY;
        default:
          return null;
      }
    }
  }
});

// server/parser/parser.js
var require_parser = __commonJS({
  "server/parser/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = parse;
    exports2.parseClause = parseClause;
    exports2.errorToRange = errorToRange;
    exports2.hasErrors = hasErrors;
    exports2.hasFatalErrors = hasFatalErrors;
    exports2.getErrorCounts = getErrorCounts;
    var antlr4ng_1 = require_dist();
    var MangleLexer_1 = require_MangleLexer();
    var MangleParser_1 = require_MangleParser();
    var visitor_1 = require_visitor();
    var MangleErrorListener = class extends antlr4ng_1.BaseErrorListener {
      constructor() {
        super(...arguments);
        this.errors = [];
        this.source = "parser";
      }
      syntaxError(_recognizer, offendingSymbol, line, charPositionInLine, msg, _e) {
        let length = 1;
        if (offendingSymbol && typeof offendingSymbol === "object" && "text" in offendingSymbol) {
          const sym = offendingSymbol;
          length = sym.text?.length ?? 1;
        }
        this.errors.push({
          message: msg,
          line,
          column: charPositionInLine,
          offset: 0,
          // We don't have offset from ANTLR error listener
          length,
          source: this.source
        });
      }
    };
    function visitorErrorToParseError(error) {
      return {
        message: error.message,
        line: error.line,
        column: error.column,
        offset: error.offset,
        length: error.length,
        source: "parser"
      };
    }
    function parse(source) {
      const errors = [];
      let visitor = null;
      try {
        const inputStream = antlr4ng_1.CharStream.fromString(source);
        const lexer = new MangleLexer_1.MangleLexer(inputStream);
        const lexerErrorListener = new MangleErrorListener();
        lexerErrorListener.source = "lexer";
        lexer.removeErrorListeners();
        lexer.addErrorListener(lexerErrorListener);
        const tokenStream = new antlr4ng_1.CommonTokenStream(lexer);
        const parser = new MangleParser_1.MangleParser(tokenStream);
        const parserErrorListener = new MangleErrorListener();
        parserErrorListener.source = "parser";
        parser.removeErrorListeners();
        parser.addErrorListener(parserErrorListener);
        const tree = parser.start();
        errors.push(...lexerErrorListener.errors);
        errors.push(...parserErrorListener.errors);
        visitor = new visitor_1.MangleASTVisitor();
        const unit = visitor.visit(tree);
        const visitorErrors = visitor.getErrors();
        errors.push(...visitorErrors.map(visitorErrorToParseError));
        return { unit, errors };
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        errors.push({
          message: `Internal parser error: ${message}`,
          line: 1,
          column: 0,
          offset: 0,
          length: 1,
          source: "parser"
        });
        const partialUnit = visitor?.getPartialUnit() ?? null;
        return { unit: partialUnit, errors };
      }
    }
    function parseClause(source) {
      return parse(source);
    }
    function errorToRange(error) {
      const start = {
        line: error.line,
        column: error.column,
        offset: error.offset
      };
      const end = {
        line: error.line,
        column: error.column + error.length,
        offset: error.offset + error.length
      };
      return { start, end };
    }
    function hasErrors(result) {
      return result.errors.length > 0;
    }
    function hasFatalErrors(result) {
      return result.unit === null;
    }
    function getErrorCounts(result) {
      let lexer = 0;
      let parser = 0;
      for (const error of result.errors) {
        if (error.source === "lexer") {
          lexer++;
        } else {
          parser++;
        }
      }
      return { lexer, parser };
    }
  }
});

// server/parser/index.js
var require_parser2 = __commonJS({
  "server/parser/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MangleASTVisitor = exports2.getErrorCounts = exports2.hasFatalErrors = exports2.hasErrors = exports2.errorToRange = exports2.parseClause = exports2.parse = void 0;
    __exportStar(require_ast(), exports2);
    var parser_1 = require_parser();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parser_1.parse;
    } });
    Object.defineProperty(exports2, "parseClause", { enumerable: true, get: function() {
      return parser_1.parseClause;
    } });
    Object.defineProperty(exports2, "errorToRange", { enumerable: true, get: function() {
      return parser_1.errorToRange;
    } });
    Object.defineProperty(exports2, "hasErrors", { enumerable: true, get: function() {
      return parser_1.hasErrors;
    } });
    Object.defineProperty(exports2, "hasFatalErrors", { enumerable: true, get: function() {
      return parser_1.hasFatalErrors;
    } });
    Object.defineProperty(exports2, "getErrorCounts", { enumerable: true, get: function() {
      return parser_1.getErrorCounts;
    } });
    var visitor_1 = require_visitor();
    Object.defineProperty(exports2, "MangleASTVisitor", { enumerable: true, get: function() {
      return visitor_1.MangleASTVisitor;
    } });
  }
});

// server/utils/position.js
var require_position = __commonJS({
  "server/utils/position.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPosition = toPosition;
    exports2.fromPosition = fromPosition;
    exports2.toRange = toRange;
    exports2.fromRange = fromRange;
    exports2.isWithinSourceRange = isWithinSourceRange;
    exports2.isPositionInRange = isPositionInRange;
    exports2.rangesOverlap = rangesOverlap;
    exports2.comparePositions = comparePositions;
    exports2.unionRanges = unionRanges;
    exports2.pointRangeLSP = pointRangeLSP;
    function toPosition(pos) {
      return {
        line: pos.line - 1,
        // Convert 1-indexed to 0-indexed
        character: pos.column
      };
    }
    function fromPosition(pos) {
      return {
        line: pos.line + 1,
        // Convert 0-indexed to 1-indexed
        column: pos.character,
        offset: 0
        // LSP doesn't provide offset
      };
    }
    function toRange(range) {
      return {
        start: toPosition(range.start),
        end: toPosition(range.end)
      };
    }
    function fromRange(range) {
      return {
        start: fromPosition(range.start),
        end: fromPosition(range.end)
      };
    }
    function isWithinSourceRange(line, column, range) {
      if (line < range.start.line || line > range.end.line) {
        return false;
      }
      if (line === range.start.line && column < range.start.column) {
        return false;
      }
      if (line === range.end.line && column >= range.end.column) {
        return false;
      }
      return true;
    }
    function isPositionInRange(pos, range) {
      if (pos.line < range.start.line)
        return false;
      if (pos.line === range.start.line && pos.character < range.start.character)
        return false;
      if (pos.line > range.end.line)
        return false;
      if (pos.line === range.end.line && pos.character >= range.end.character)
        return false;
      return true;
    }
    function rangesOverlap(a, b) {
      if (a.end.line < b.start.line)
        return false;
      if (a.end.line === b.start.line && a.end.character <= b.start.character)
        return false;
      if (b.end.line < a.start.line)
        return false;
      if (b.end.line === a.start.line && b.end.character <= a.start.character)
        return false;
      return true;
    }
    function comparePositions(a, b) {
      if (a.line !== b.line) {
        return a.line - b.line;
      }
      return a.character - b.character;
    }
    function unionRanges(a, b) {
      const start = comparePositions(a.start, b.start) <= 0 ? a.start : b.start;
      const end = comparePositions(a.end, b.end) >= 0 ? a.end : b.end;
      return { start, end };
    }
    function pointRangeLSP(pos) {
      return { start: pos, end: pos };
    }
  }
});

// server/analysis/symbols.js
var require_symbols = __commonJS({
  "server/analysis/symbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SymbolTable = void 0;
    exports2.buildSymbolTable = buildSymbolTable;
    var ast_1 = require_ast();
    var position_1 = require_position();
    function calculatePredicateNameRange(atom) {
      const nameLength = atom.predicate.symbol.length;
      return {
        start: { ...atom.range.start },
        end: {
          line: atom.range.start.line,
          column: atom.range.start.column + nameLength,
          offset: atom.range.start.offset + nameLength
        }
      };
    }
    var SymbolTable = class _SymbolTable {
      constructor() {
        this.predicates = /* @__PURE__ */ new Map();
        this.clauseVariables = /* @__PURE__ */ new Map();
      }
      /**
       * Build a symbol table from a parsed source unit.
       */
      static build(unit) {
        const table = new _SymbolTable();
        for (const decl of unit.decls) {
          table.addDeclaration(decl);
        }
        for (const clause of unit.clauses) {
          table.addClause(clause);
        }
        return table;
      }
      /**
       * Add a declaration to the symbol table.
       */
      addDeclaration(decl) {
        const name = decl.declaredAtom.predicate.symbol;
        const arity = decl.declaredAtom.predicate.arity;
        const key = `${name}/${arity}`;
        let info = this.predicates.get(key);
        const docString = this.extractDocumentation(decl.descr);
        const nameRange = calculatePredicateNameRange(decl.declaredAtom);
        if (!info) {
          info = {
            symbol: decl.declaredAtom.predicate,
            declLocation: decl.range,
            declNameRange: nameRange,
            definitions: [],
            definitionNameRanges: [],
            references: [],
            referenceNameRanges: [],
            documentation: docString,
            isExternal: this.detectIsExternal(decl.descr),
            isPrivate: this.detectIsPrivate(decl.descr)
          };
          this.predicates.set(key, info);
        } else {
          info.declLocation = decl.range;
          info.declNameRange = nameRange;
          info.documentation = docString || info.documentation;
          info.isPrivate = this.detectIsPrivate(decl.descr);
        }
      }
      /**
       * Extract documentation string from descr atoms.
       */
      extractDocumentation(descr) {
        if (!descr || descr.length === 0) {
          return null;
        }
        for (const atom of descr) {
          if (atom.predicate.symbol === "doc" && atom.args.length > 0) {
            const arg = atom.args[0];
            if (arg && arg.type === "Constant" && arg.symbol) {
              return arg.symbol;
            }
          }
        }
        return null;
      }
      /**
       * Detect if a predicate is external from descr atoms.
       * External predicates are typically marked with mode atoms that have '+' (bound) patterns.
       */
      detectIsExternal(descr) {
        if (!descr || descr.length === 0) {
          return false;
        }
        for (const atom of descr) {
          if (atom.predicate.symbol === "external" || atom.predicate.symbol === "mode") {
            return true;
          }
        }
        return false;
      }
      /**
       * Detect if a predicate is private from descr atoms.
       */
      detectIsPrivate(descr) {
        if (!descr || descr.length === 0) {
          return false;
        }
        for (const atom of descr) {
          if (atom.predicate.symbol === "private") {
            return true;
          }
        }
        return false;
      }
      /**
       * Add a clause to the symbol table.
       */
      addClause(clause) {
        const headName = clause.head.predicate.symbol;
        const headArity = clause.head.predicate.arity;
        const headKey = `${headName}/${headArity}`;
        let headInfo = this.predicates.get(headKey);
        if (!headInfo) {
          headInfo = {
            symbol: clause.head.predicate,
            declLocation: null,
            declNameRange: null,
            definitions: [],
            definitionNameRanges: [],
            references: [],
            referenceNameRanges: [],
            documentation: null,
            isExternal: false,
            isPrivate: false
          };
          this.predicates.set(headKey, headInfo);
        }
        headInfo.definitions.push(clause.head.range);
        headInfo.definitionNameRanges.push(calculatePredicateNameRange(clause.head));
        const clauseKey = this.rangeKey(clause.range);
        const variables = /* @__PURE__ */ new Map();
        this.clauseVariables.set(clauseKey, variables);
        this.collectVariables(clause.head, clause.range, variables, true);
        if (clause.premises) {
          for (const premise of clause.premises) {
            if (premise.type === "Atom") {
              const atom = premise;
              if ((0, ast_1.isComparisonAtom)(atom)) {
                for (const arg of atom.args) {
                  if (arg?.type === "Variable") {
                    this.addVariableOccurrence(arg, clause.range, variables, false);
                  }
                }
              } else {
                this.addReference(atom);
                this.collectVariables(atom, clause.range, variables, true);
              }
            } else if (premise.type === "NegAtom") {
              const negAtom = premise;
              this.addReference(negAtom.atom);
              this.collectVariables(negAtom.atom, clause.range, variables, false);
            } else if (premise.type === "Eq" || premise.type === "Ineq") {
              const cmp = premise;
              if (cmp.left?.type === "Variable") {
                this.addVariableOccurrence(cmp.left, clause.range, variables, premise.type === "Eq");
              }
              if (cmp.right?.type === "Variable") {
                this.addVariableOccurrence(cmp.right, clause.range, variables, false);
              }
            }
          }
        }
      }
      /**
       * Add a predicate reference (from body).
       */
      addReference(atom) {
        const name = atom.predicate.symbol;
        const arity = atom.predicate.arity;
        const key = `${name}/${arity}`;
        let info = this.predicates.get(key);
        if (!info) {
          info = {
            symbol: atom.predicate,
            declLocation: null,
            declNameRange: null,
            definitions: [],
            definitionNameRanges: [],
            references: [],
            referenceNameRanges: [],
            documentation: null,
            isExternal: false,
            isPrivate: false
          };
          this.predicates.set(key, info);
        }
        info.references.push(atom.range);
        info.referenceNameRanges.push(calculatePredicateNameRange(atom));
      }
      /**
       * Collect variables from an atom.
       */
      collectVariables(atom, clauseRange, variables, binds) {
        for (const arg of atom.args) {
          if (arg.type === "Variable") {
            this.addVariableOccurrence(arg, clauseRange, variables, binds);
          } else if (arg.type === "ApplyFn") {
            for (const fnArg of arg.args) {
              if (fnArg.type === "Variable") {
                this.addVariableOccurrence(fnArg, clauseRange, variables, false);
              }
            }
          }
        }
      }
      /**
       * Add a variable occurrence.
       */
      addVariableOccurrence(variable, clauseRange, variables, binds) {
        if (variable.symbol === "_") {
          return;
        }
        let info = variables.get(variable.symbol);
        if (!info) {
          info = {
            name: variable.symbol,
            bindingLocation: variable.range,
            occurrences: [],
            clauseRange
          };
          variables.set(variable.symbol, info);
        }
        info.occurrences.push(variable.range);
        if (binds && this.isBefore(variable.range, info.bindingLocation)) {
          info.bindingLocation = variable.range;
        }
      }
      /**
       * Check if range a is before range b.
       */
      isBefore(a, b) {
        if (a.start.line < b.start.line)
          return true;
        if (a.start.line > b.start.line)
          return false;
        return a.start.column < b.start.column;
      }
      /**
       * Get a unique key for a source range.
       */
      rangeKey(range) {
        return `${range.start.line}:${range.start.column}-${range.end.line}:${range.end.column}`;
      }
      // Public query methods
      /**
       * Get predicate info by name and arity.
       */
      getPredicate(name, arity) {
        return this.predicates.get(`${name}/${arity}`);
      }
      /**
       * Get all predicates.
       */
      getAllPredicates() {
        return Array.from(this.predicates.values());
      }
      /**
       * Get predicate names for completion.
       */
      getPredicateNames() {
        return Array.from(this.predicates.keys());
      }
      /**
       * Get predicate info by full name (name/arity format).
       */
      getPredicateInfo(fullName) {
        return this.predicates.get(fullName);
      }
      /**
       * Get all arities for a predicate base name.
       */
      getPredicateArities(baseName) {
        const arities = [];
        for (const [key, info] of this.predicates) {
          if (key.startsWith(baseName + "/")) {
            arities.push(info.symbol.arity);
          }
        }
        return arities;
      }
      /**
       * Find variable info at a given position.
       */
      findVariableAt(line, column) {
        for (const [, variables] of this.clauseVariables) {
          for (const [, info] of variables) {
            for (const occ of info.occurrences) {
              if ((0, position_1.isWithinSourceRange)(line, column, occ)) {
                return info;
              }
            }
          }
        }
        return void 0;
      }
      /**
       * Find predicate info at a given position.
       */
      findPredicateAt(line, column) {
        for (const info of this.predicates.values()) {
          if (info.declLocation && (0, position_1.isWithinSourceRange)(line, column, info.declLocation)) {
            return info;
          }
          for (const def of info.definitions) {
            if ((0, position_1.isWithinSourceRange)(line, column, def)) {
              return info;
            }
          }
          for (const ref of info.references) {
            if ((0, position_1.isWithinSourceRange)(line, column, ref)) {
              return info;
            }
          }
        }
        return void 0;
      }
      /**
       * Get variables for a clause at a given position.
       */
      getClauseVariables(clauseRange) {
        return this.clauseVariables.get(this.rangeKey(clauseRange)) || /* @__PURE__ */ new Map();
      }
    };
    exports2.SymbolTable = SymbolTable;
    function buildSymbolTable(unit) {
      return SymbolTable.build(unit);
    }
  }
});

// server/builtins/predicates.js
var require_predicates = __commonJS({
  "server/builtins/predicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BUILTIN_PREDICATE_MAP = exports2.BUILTIN_PREDICATES = void 0;
    exports2.isBuiltinPredicate = isBuiltinPredicate;
    exports2.getBuiltinPredicate = getBuiltinPredicate;
    exports2.getBuiltinPredicateNames = getBuiltinPredicateNames;
    exports2.BUILTIN_PREDICATES = [
      // String/Name matching predicates
      {
        name: ":match_prefix",
        arity: 2,
        mode: ["input", "input"],
        doc: "Matches name constants that have a given prefix. Usage: :match_prefix(Name, Prefix)"
      },
      {
        name: ":string:starts_with",
        arity: 2,
        mode: ["input", "input"],
        doc: "Matches string constants that have a given prefix. Usage: :string:starts_with(String, Prefix)"
      },
      {
        name: ":string:ends_with",
        arity: 2,
        mode: ["input", "input"],
        doc: "Matches string constants that have a given suffix. Usage: :string:ends_with(String, Suffix)"
      },
      {
        name: ":string:contains",
        arity: 2,
        mode: ["input", "input"],
        doc: "Matches string constants that contain the given substring. Usage: :string:contains(String, Substring)"
      },
      // Filter predicate
      {
        name: ":filter",
        arity: 1,
        mode: ["input"],
        doc: "Turns a boolean function into a predicate. Usage: :filter(BoolExpr)"
      },
      // Comparison predicates
      {
        name: ":lt",
        arity: 2,
        mode: ["input", "input"],
        doc: "Less-than relation on numbers. Usage: :lt(X, Y) means X < Y"
      },
      {
        name: ":le",
        arity: 2,
        mode: ["input", "input"],
        doc: "Less-than-or-equal relation on numbers. Usage: :le(X, Y) means X <= Y"
      },
      {
        name: ":gt",
        arity: 2,
        mode: ["input", "input"],
        doc: "Greater-than relation on numbers. Usage: :gt(X, Y) means X > Y"
      },
      {
        name: ":ge",
        arity: 2,
        mode: ["input", "input"],
        doc: "Greater-than-or-equal relation on numbers. Usage: :ge(X, Y) means X >= Y"
      },
      // List predicates
      {
        name: ":list:member",
        arity: 2,
        mode: ["output", "input"],
        doc: "Checks list membership or binds variable to every element. Usage: :list:member(Element, List)"
      },
      // Distance predicate
      {
        name: ":within_distance",
        arity: 3,
        mode: ["input", "input", "input"],
        doc: "Relation on numbers X, Y, Z satisfying |X - Y| < Z. Usage: :within_distance(X, Y, Z)"
      },
      // Pattern matching predicates
      {
        name: ":match_pair",
        arity: 3,
        mode: ["input", "output", "output"],
        doc: "Matches a pair to its elements. Usage: :match_pair(Pair, First, Second)"
      },
      {
        name: ":match_cons",
        arity: 3,
        mode: ["input", "output", "output"],
        doc: "Matches a list to head and tail. Usage: :match_cons(List, Head, Tail)"
      },
      {
        name: ":match_nil",
        arity: 1,
        mode: ["input"],
        doc: "Matches the empty list. Usage: :match_nil(List)"
      },
      {
        name: ":match_entry",
        arity: 3,
        mode: ["input", "input", "output"],
        doc: "Matches an entry in a map. Usage: :match_entry(Map, Key, Value)"
      },
      {
        name: ":match_field",
        arity: 3,
        mode: ["input", "input", "output"],
        doc: "Matches a field in a struct. Usage: :match_field(Struct, FieldName, Value)"
      },
      // Time comparison predicates
      {
        name: ":time:lt",
        arity: 2,
        mode: ["input", "input"],
        doc: "Less-than relation on time instants. Usage: :time:lt(T1, T2) means T1 < T2"
      },
      {
        name: ":time:le",
        arity: 2,
        mode: ["input", "input"],
        doc: "Less-than-or-equal relation on time instants. Usage: :time:le(T1, T2) means T1 <= T2"
      },
      {
        name: ":time:gt",
        arity: 2,
        mode: ["input", "input"],
        doc: "Greater-than relation on time instants. Usage: :time:gt(T1, T2) means T1 > T2"
      },
      {
        name: ":time:ge",
        arity: 2,
        mode: ["input", "input"],
        doc: "Greater-than-or-equal relation on time instants. Usage: :time:ge(T1, T2) means T1 >= T2"
      },
      // Duration comparison predicates
      {
        name: ":duration:lt",
        arity: 2,
        mode: ["input", "input"],
        doc: "Less-than relation on durations. Usage: :duration:lt(D1, D2) means D1 < D2"
      },
      {
        name: ":duration:le",
        arity: 2,
        mode: ["input", "input"],
        doc: "Less-than-or-equal relation on durations. Usage: :duration:le(D1, D2) means D1 <= D2"
      },
      {
        name: ":duration:gt",
        arity: 2,
        mode: ["input", "input"],
        doc: "Greater-than relation on durations. Usage: :duration:gt(D1, D2) means D1 > D2"
      },
      {
        name: ":duration:ge",
        arity: 2,
        mode: ["input", "input"],
        doc: "Greater-than-or-equal relation on durations. Usage: :duration:ge(D1, D2) means D1 >= D2"
      },
      // Allen's interval algebra predicates (upstream symbols/symbols.go, builtin/temporal.go)
      {
        name: ":interval:before",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A ends before interval B starts. Usage: :interval:before(A, B)"
      },
      {
        name: ":interval:after",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A starts after interval B ends. Usage: :interval:after(A, B)"
      },
      {
        name: ":interval:meets",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A ends exactly when interval B starts. Usage: :interval:meets(A, B)"
      },
      {
        name: ":interval:overlaps",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A overlaps with interval B. Usage: :interval:overlaps(A, B)"
      },
      {
        name: ":interval:during",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A is contained within interval B. Usage: :interval:during(A, B)"
      },
      {
        name: ":interval:contains",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A contains interval B. Usage: :interval:contains(A, B)"
      },
      {
        name: ":interval:starts",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A starts at the same time as B. Usage: :interval:starts(A, B)"
      },
      {
        name: ":interval:finishes",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A finishes at the same time as B. Usage: :interval:finishes(A, B)"
      },
      {
        name: ":interval:equals",
        arity: 2,
        mode: ["input", "input"],
        doc: "Allen's interval relation: interval A equals interval B. Usage: :interval:equals(A, B)"
      }
    ];
    exports2.BUILTIN_PREDICATE_MAP = new Map(exports2.BUILTIN_PREDICATES.map((p) => [p.name, p]));
    function isBuiltinPredicate(name) {
      return exports2.BUILTIN_PREDICATE_MAP.has(name);
    }
    function getBuiltinPredicate(name) {
      return exports2.BUILTIN_PREDICATE_MAP.get(name);
    }
    function getBuiltinPredicateNames() {
      return exports2.BUILTIN_PREDICATES.map((p) => p.name);
    }
  }
});

// server/builtins/functions.js
var require_functions = __commonJS({
  "server/builtins/functions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BUILTIN_FUNCTION_MAP = exports2.ALL_BUILTIN_FUNCTIONS = exports2.TYPE_CONSTRUCTOR_FUNCTIONS = exports2.REDUCER_FUNCTIONS = exports2.BUILTIN_FUNCTIONS = void 0;
    exports2.isBuiltinFunction = isBuiltinFunction;
    exports2.isTypeConstructor = isTypeConstructor;
    exports2.isReducerFunction = isReducerFunction;
    exports2.getBuiltinFunction = getBuiltinFunction;
    exports2.getBuiltinFunctionNames = getBuiltinFunctionNames;
    exports2.getReducerFunctionNames = getReducerFunctionNames;
    exports2.BUILTIN_FUNCTIONS = [
      // Arithmetic functions
      {
        name: "fn:plus",
        arity: -1,
        isReducer: false,
        doc: "Addition. Maps X, Y1, ... to (X + Y1) + Y2 + ... fn:plus(X) returns X."
      },
      {
        name: "fn:minus",
        arity: -1,
        isReducer: false,
        doc: "Subtraction. Maps X, Y1, ... to (X - Y1) - Y2 - ... fn:minus(X) returns -X."
      },
      {
        name: "fn:mult",
        arity: -1,
        isReducer: false,
        doc: "Multiplication. Maps X, Y1, ... to (X * Y1) * Y2 * ... fn:mult(X) returns X."
      },
      {
        name: "fn:div",
        arity: -1,
        isReducer: false,
        doc: "Integer division. Maps X, Y1, ... to (X / Y1) / Y2 / ... fn:div(X) returns 1/X."
      },
      {
        name: "fn:sqrt",
        arity: 1,
        isReducer: false,
        doc: "Square root of a numeric argument."
      },
      // Float arithmetic functions
      {
        name: "fn:float:plus",
        arity: -1,
        isReducer: false,
        doc: "Float addition. Maps X, Y1, ... to (X + Y1) + Y2 + ..."
      },
      {
        name: "fn:float:mult",
        arity: -1,
        isReducer: false,
        doc: "Float multiplication. Maps X, Y1, ... to (X * Y1) * Y2 * ..."
      },
      {
        name: "fn:float:div",
        arity: -1,
        isReducer: false,
        doc: "Float division. Maps X, Y1, ... to (X / Y1) / Y2 / ..."
      },
      // Grouping function (special - used to start a do-transform)
      {
        name: "fn:group_by",
        arity: -1,
        isReducer: false,
        doc: "Groups all tuples by the values of key variables. Empty group_by() treats the whole relation as a group."
      },
      // List functions
      {
        name: "fn:list",
        arity: -1,
        isReducer: false,
        doc: "Constructs a list from the arguments."
      },
      {
        name: "fn:list:append",
        arity: 2,
        isReducer: false,
        doc: "Appends an element to a list. Usage: fn:list:append(List, Element)"
      },
      {
        name: "fn:list:get",
        arity: 2,
        isReducer: false,
        doc: "Returns element at index. Usage: fn:list:get(List, Index)"
      },
      {
        name: "fn:list:contains",
        arity: 2,
        isReducer: false,
        doc: "Returns /true if member is in list. Usage: fn:list:contains(List, Member)"
      },
      {
        name: "fn:list:len",
        arity: 1,
        isReducer: false,
        doc: "Returns the length of a list."
      },
      {
        name: "fn:list:cons",
        arity: 2,
        isReducer: false,
        doc: "Constructs a list from head and tail. Usage: fn:list:cons(Head, Tail)"
      },
      // Pair and tuple functions
      {
        name: "fn:pair",
        arity: 2,
        isReducer: false,
        doc: "Constructs a pair from two elements."
      },
      {
        name: "fn:tuple",
        arity: -1,
        isReducer: false,
        doc: "Acts as identity (one arg), pair (two args), or nested pair (more)."
      },
      {
        name: "fn:some",
        arity: 1,
        isReducer: false,
        doc: "Constructs an element of an option type."
      },
      // Map and struct functions
      {
        name: "fn:map",
        arity: -1,
        isReducer: false,
        doc: "Constructs a map from key-value pairs."
      },
      {
        name: "fn:map:get",
        arity: 2,
        isReducer: false,
        doc: "Returns element at key. Usage: fn:map:get(Map, Key)"
      },
      {
        name: "fn:struct",
        arity: -1,
        isReducer: false,
        doc: "Constructs a struct from field-value pairs."
      },
      {
        name: "fn:struct:get",
        arity: 2,
        isReducer: false,
        doc: "Returns the value of a field. Usage: fn:struct:get(Struct, FieldName)"
      },
      // String functions
      {
        name: "fn:string:concat",
        arity: -1,
        isReducer: false,
        doc: "Concatenates arguments into a single string."
      },
      {
        name: "fn:string:replace",
        arity: 4,
        isReducer: false,
        doc: "Replaces old with new in first n occurrences. Usage: fn:string:replace(Str, Old, New, N)"
      },
      // Conversion functions
      {
        name: "fn:number:to_string",
        arity: 1,
        isReducer: false,
        doc: "Converts a number to a string."
      },
      {
        name: "fn:float64:to_string",
        arity: 1,
        isReducer: false,
        doc: "Converts a float64 to a string."
      },
      {
        name: "fn:name:to_string",
        arity: 1,
        isReducer: false,
        doc: "Converts a name constant to a string."
      },
      {
        name: "fn:name:root",
        arity: 1,
        isReducer: false,
        doc: "Returns the first name part of a name."
      },
      {
        name: "fn:name:tip",
        arity: 1,
        isReducer: false,
        doc: "Returns the last name part of a name."
      },
      {
        name: "fn:name:list",
        arity: 1,
        isReducer: false,
        doc: "Turns a name into a list of name parts."
      },
      // Time functions
      {
        name: "fn:time:now",
        arity: 0,
        isReducer: false,
        doc: "Returns the current time as a time instant."
      },
      {
        name: "fn:time:add",
        arity: 2,
        isReducer: false,
        doc: "Adds a duration to a time instant. Usage: fn:time:add(Time, Duration)"
      },
      {
        name: "fn:time:sub",
        arity: 2,
        isReducer: false,
        doc: "Subtracts a duration from a time instant, or computes the duration between two time instants. Usage: fn:time:sub(Time, DurationOrTime)"
      },
      {
        name: "fn:time:format",
        arity: 2,
        isReducer: false,
        doc: "Formats a time instant as a string with given precision. Usage: fn:time:format(Time, /precision) where precision is /second, /millisecond, /microsecond, or /nanosecond"
      },
      {
        name: "fn:time:format_civil",
        arity: 3,
        isReducer: false,
        doc: "Formats a time instant as a civil datetime string with timezone. Usage: fn:time:format_civil(Time, /precision, Timezone)"
      },
      {
        name: "fn:time:parse_rfc3339",
        arity: 1,
        isReducer: false,
        doc: "Parses an RFC 3339 timestamp string into a time instant. Usage: fn:time:parse_rfc3339(String)"
      },
      {
        name: "fn:time:parse_civil",
        arity: 2,
        isReducer: false,
        doc: "Parses a civil datetime string with timezone into a time instant. Usage: fn:time:parse_civil(String, Timezone)"
      },
      {
        name: "fn:time:year",
        arity: 1,
        isReducer: false,
        doc: "Returns the year of a time instant. Usage: fn:time:year(Time)"
      },
      {
        name: "fn:time:month",
        arity: 1,
        isReducer: false,
        doc: "Returns the month (1-12) of a time instant. Usage: fn:time:month(Time)"
      },
      {
        name: "fn:time:day",
        arity: 1,
        isReducer: false,
        doc: "Returns the day of the month of a time instant. Usage: fn:time:day(Time)"
      },
      {
        name: "fn:time:hour",
        arity: 1,
        isReducer: false,
        doc: "Returns the hour (0-23) of a time instant. Usage: fn:time:hour(Time)"
      },
      {
        name: "fn:time:minute",
        arity: 1,
        isReducer: false,
        doc: "Returns the minute (0-59) of a time instant. Usage: fn:time:minute(Time)"
      },
      {
        name: "fn:time:second",
        arity: 1,
        isReducer: false,
        doc: "Returns the second (0-59) of a time instant. Usage: fn:time:second(Time)"
      },
      {
        name: "fn:time:from_unix_nanos",
        arity: 1,
        isReducer: false,
        doc: "Creates a time instant from Unix nanoseconds. Usage: fn:time:from_unix_nanos(Number)"
      },
      {
        name: "fn:time:to_unix_nanos",
        arity: 1,
        isReducer: false,
        doc: "Returns the Unix nanoseconds of a time instant. Usage: fn:time:to_unix_nanos(Time)"
      },
      {
        name: "fn:time:trunc",
        arity: 2,
        isReducer: false,
        doc: "Truncates a time instant to the given precision. Usage: fn:time:trunc(Time, /precision)"
      },
      // Duration functions
      {
        name: "fn:duration:add",
        arity: 2,
        isReducer: false,
        doc: "Adds two durations. Usage: fn:duration:add(Duration1, Duration2)"
      },
      {
        name: "fn:duration:mult",
        arity: 2,
        isReducer: false,
        doc: "Multiplies a duration by a number. Usage: fn:duration:mult(Duration, Number)"
      },
      {
        name: "fn:duration:hours",
        arity: 1,
        isReducer: false,
        doc: "Returns the number of hours in a duration (as float64). Usage: fn:duration:hours(Duration)"
      },
      {
        name: "fn:duration:minutes",
        arity: 1,
        isReducer: false,
        doc: "Returns the number of minutes in a duration (as float64). Usage: fn:duration:minutes(Duration)"
      },
      {
        name: "fn:duration:seconds",
        arity: 1,
        isReducer: false,
        doc: "Returns the number of seconds in a duration (as float64). Usage: fn:duration:seconds(Duration)"
      },
      {
        name: "fn:duration:nanos",
        arity: 1,
        isReducer: false,
        doc: "Returns the number of nanoseconds in a duration. Usage: fn:duration:nanos(Duration)"
      },
      {
        name: "fn:duration:from_nanos",
        arity: 1,
        isReducer: false,
        doc: "Creates a duration from nanoseconds. Usage: fn:duration:from_nanos(Number)"
      },
      {
        name: "fn:duration:from_hours",
        arity: 1,
        isReducer: false,
        doc: "Creates a duration from hours. Usage: fn:duration:from_hours(Number)"
      },
      {
        name: "fn:duration:from_minutes",
        arity: 1,
        isReducer: false,
        doc: "Creates a duration from minutes. Usage: fn:duration:from_minutes(Number)"
      },
      {
        name: "fn:duration:from_seconds",
        arity: 1,
        isReducer: false,
        doc: "Creates a duration from seconds. Usage: fn:duration:from_seconds(Number)"
      },
      {
        name: "fn:duration:parse",
        arity: 1,
        isReducer: false,
        doc: 'Parses a duration string (e.g., "7d", "24h", "30m", "1s", "500ms") into a duration. Usage: fn:duration:parse(String)'
      },
      // Interval functions (upstream symbols/symbols.go)
      {
        name: "fn:interval:start",
        arity: 1,
        isReducer: false,
        doc: "Returns the start time of an interval. Usage: fn:interval:start(Interval)"
      },
      {
        name: "fn:interval:end",
        arity: 1,
        isReducer: false,
        doc: "Returns the end time of an interval. Usage: fn:interval:end(Interval)"
      },
      {
        name: "fn:interval:duration",
        arity: 1,
        isReducer: false,
        doc: "Returns the duration of an interval (end - start). Usage: fn:interval:duration(Interval)"
      }
    ];
    exports2.REDUCER_FUNCTIONS = [
      {
        name: "fn:collect",
        arity: -1,
        isReducer: true,
        doc: "Collects tuples into a list [tuple_1, ..., tuple_n]."
      },
      {
        name: "fn:collect_distinct",
        arity: -1,
        isReducer: true,
        doc: "Collects tuples into a list with distinct elements."
      },
      {
        name: "fn:collect_to_map",
        arity: 2,
        isReducer: true,
        doc: "Collects key-value pairs into a map. Usage: fn:collect_to_map(Key, Value)"
      },
      {
        name: "fn:pick_any",
        arity: 1,
        isReducer: true,
        doc: "Reduces a set {x_1, ..., x_n} to a single {x_i}."
      },
      {
        name: "fn:max",
        arity: 1,
        isReducer: true,
        doc: "Returns the maximum value from a set of numbers."
      },
      {
        name: "fn:min",
        arity: 1,
        isReducer: true,
        doc: "Returns the minimum value from a set of numbers."
      },
      {
        name: "fn:sum",
        arity: 1,
        isReducer: true,
        doc: "Returns the sum of a set of numbers."
      },
      {
        name: "fn:float:max",
        arity: 1,
        isReducer: true,
        doc: "Returns the maximum value from a set of float64."
      },
      {
        name: "fn:float:min",
        arity: 1,
        isReducer: true,
        doc: "Returns the minimum value from a set of float64."
      },
      {
        name: "fn:float:sum",
        arity: 1,
        isReducer: true,
        doc: "Returns the sum of a set of float64."
      },
      {
        name: "fn:count",
        arity: 0,
        isReducer: true,
        doc: "Returns the count of elements in a set."
      },
      {
        name: "fn:count_distinct",
        arity: 0,
        isReducer: true,
        doc: "Returns the count of unique elements in a set."
      },
      {
        name: "fn:avg",
        arity: 1,
        isReducer: true,
        doc: "Returns the average of a set of numbers."
      }
    ];
    exports2.TYPE_CONSTRUCTOR_FUNCTIONS = [
      {
        name: "fn:Fun",
        arity: -1,
        isReducer: false,
        doc: "Type constructor for function types. fn:Fun(Res, Arg1, ..., ArgN) represents Res <= Arg1, ..., ArgN."
      },
      {
        name: "fn:Rel",
        arity: -1,
        isReducer: false,
        doc: "Type constructor for relation types."
      },
      {
        name: "fn:Singleton",
        arity: 1,
        isReducer: false,
        doc: "Type constructor for singleton types."
      },
      {
        name: "fn:Pair",
        arity: 2,
        isReducer: false,
        doc: "Type constructor for pair types. fn:Pair(T1, T2) is the type of fn:pair(x, y) where x:T1, y:T2."
      },
      {
        name: "fn:Tuple",
        arity: -1,
        isReducer: false,
        doc: "Type constructor for tuple types (more than 2 elements)."
      },
      {
        name: "fn:Option",
        arity: 1,
        isReducer: false,
        doc: "Type constructor for option types. A value of fn:Option(T) is either fn:some(c) for c:T, or fn:none()."
      },
      {
        name: "fn:List",
        arity: 1,
        isReducer: false,
        doc: "Type constructor for list types. fn:List(T) is the type of lists with elements of type T."
      },
      {
        name: "fn:Map",
        arity: 2,
        isReducer: false,
        doc: "Type constructor for map types. fn:Map(K, V) is the type of maps with keys K and values V."
      },
      {
        name: "fn:Struct",
        arity: -1,
        isReducer: false,
        doc: "Type constructor for struct types. fn:Struct(/field1, Type1, /field2, Type2, ...) defines a struct type."
      },
      {
        name: "fn:Union",
        arity: -1,
        isReducer: false,
        doc: "Type constructor for union types. fn:Union(T1, T2, ...) is the union of types T1, T2, ..."
      },
      {
        name: "fn:opt",
        arity: -1,
        isReducer: false,
        doc: "Marks a field as optional inside a struct type expression."
      }
    ];
    exports2.ALL_BUILTIN_FUNCTIONS = [
      ...exports2.BUILTIN_FUNCTIONS,
      ...exports2.REDUCER_FUNCTIONS,
      ...exports2.TYPE_CONSTRUCTOR_FUNCTIONS
    ];
    exports2.BUILTIN_FUNCTION_MAP = new Map(exports2.ALL_BUILTIN_FUNCTIONS.map((f) => [f.name, f]));
    function isBuiltinFunction(name) {
      return exports2.BUILTIN_FUNCTION_MAP.has(name);
    }
    function isTypeConstructor(name) {
      return exports2.TYPE_CONSTRUCTOR_FUNCTIONS.some((f) => f.name === name);
    }
    function isReducerFunction(name) {
      const fn = exports2.BUILTIN_FUNCTION_MAP.get(name);
      return fn !== void 0 && fn.isReducer;
    }
    function getBuiltinFunction(name) {
      return exports2.BUILTIN_FUNCTION_MAP.get(name);
    }
    function getBuiltinFunctionNames() {
      return exports2.ALL_BUILTIN_FUNCTIONS.map((f) => f.name);
    }
    function getReducerFunctionNames() {
      return exports2.REDUCER_FUNCTIONS.map((f) => f.name);
    }
  }
});

// server/analysis/unionfind.js
var require_unionfind = __commonJS({
  "server/analysis/unionfind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnionFind = void 0;
    exports2.initVars = initVars;
    exports2.unifyTerms = unifyTerms;
    exports2.unifyTermsExtend = unifyTermsExtend;
    function termKey(t) {
      switch (t.type) {
        case "Variable":
          return `var:${t.symbol}`;
        case "Constant": {
          const c = t;
          if (c.constantType === "number")
            return `num:${c.numValue}`;
          if (c.constantType === "float64")
            return `float:${c.floatValue}`;
          if (c.constantType === "string")
            return `str:${c.symbol}`;
          if (c.constantType === "bytes")
            return `bytes:${c.symbol}`;
          return `name:${c.symbol}`;
        }
        case "ApplyFn":
          return `fn:${JSON.stringify(t)}`;
        default:
          return `unknown:${JSON.stringify(t)}`;
      }
    }
    function termsEqual(a, b) {
      if (a.type !== b.type)
        return false;
      if (a.type === "Variable" && b.type === "Variable") {
        return a.symbol === b.symbol;
      }
      if (a.type === "Constant" && b.type === "Constant") {
        const ac = a;
        const bc = b;
        if (ac.constantType !== bc.constantType)
          return false;
        if (ac.constantType === "number")
          return ac.numValue === bc.numValue;
        if (ac.constantType === "float64")
          return ac.floatValue === bc.floatValue;
        return ac.symbol === bc.symbol;
      }
      return termKey(a) === termKey(b);
    }
    var UnionFind = class _UnionFind {
      constructor() {
        this.parent = /* @__PURE__ */ new Map();
        this.terms = /* @__PURE__ */ new Map();
      }
      /**
       * Create a new empty UnionFind.
       */
      static create() {
        return new _UnionFind();
      }
      /**
       * Create a copy of this UnionFind.
       */
      copy() {
        const uf = new _UnionFind();
        for (const [k, v] of this.parent) {
          uf.parent.set(k, v);
        }
        for (const [k, v] of this.terms) {
          uf.terms.set(k, v);
        }
        return uf;
      }
      /**
       * Find the representative element from the set of s.
       * Uses path compression (grandparent-pointer halving).
       *
       * Upstream Go equivalent: unionfind.UnionFind.find()
       */
      find(s) {
        const sKey = termKey(s);
        let child = s;
        let childKey = sKey;
        const parentTerm = this.parent.get(childKey);
        if (parentTerm === void 0) {
          return null;
        }
        let parent = parentTerm;
        let parentKey = termKey(parent);
        while (childKey !== parentKey) {
          const grandparent = this.parent.get(parentKey);
          if (grandparent === void 0)
            break;
          this.parent.set(childKey, grandparent);
          child = grandparent;
          childKey = termKey(child);
          parent = this.parent.get(childKey);
          parentKey = termKey(parent);
        }
        return parent;
      }
      /**
       * Adds an edge, making one root point to the other.
       * Constants are preferred as roots (biased union).
       *
       * Upstream Go equivalent: unionfind.UnionFind.union()
       */
      union(s, t) {
        const sroot = this.find(s);
        const troot = this.find(t);
        if (!sroot || !troot)
          return;
        if (sroot.type === "Constant") {
          this.parent.set(termKey(troot), sroot);
        } else {
          this.parent.set(termKey(sroot), troot);
        }
      }
      /**
       * Returns true if variable v can be unified with term t.
       * Updates the union-find sets.
       *
       * Upstream Go equivalent: unionfind.UnionFind.unify()
       */
      unify(v, t) {
        let vroot = this.find(v);
        if (vroot === null) {
          vroot = v;
        }
        let troot = this.find(t);
        if (troot === null) {
          troot = t;
        }
        if (termsEqual(vroot, troot)) {
          return true;
        }
        const vconst = vroot.type === "Constant";
        const tconst = troot.type === "Constant";
        if (vconst && tconst) {
          return false;
        }
        const vKey = termKey(v);
        const tKey = termKey(t);
        this.parent.set(vKey, vroot);
        this.terms.set(vKey, v);
        this.parent.set(tKey, troot);
        this.terms.set(tKey, t);
        this.union(vroot, troot);
        return true;
      }
      /**
       * Get the representative for a variable.
       * Returns the variable itself if not in the union-find.
       *
       * Upstream Go equivalent: unionfind.UnionFind.Get()
       */
      get(v) {
        const res = this.find(v);
        if (res !== null) {
          return res;
        }
        return v;
      }
      /**
       * Check if a variable is bound (has a representative that is either
       * a constant or a bound variable).
       */
      isBound(v, boundVars) {
        const rep = this.get(v);
        if (rep.type === "Constant") {
          return true;
        }
        if (rep.type === "Variable") {
          const repVar = rep;
          if (repVar.symbol !== v.symbol && boundVars.has(repVar.symbol)) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.UnionFind = UnionFind;
    function initVars(vars, ts) {
      if (vars.length !== ts.length) {
        throw new Error("not of equal size");
      }
      const uf = UnionFind.create();
      for (let i = 0; i < vars.length; i++) {
        const v = vars[i];
        const t = ts[i];
        const tKey = termKey(t);
        const vKey = termKey(v);
        uf.unify(v, t);
      }
      return uf;
    }
    function unifyTerms(xs, ys) {
      if (xs.length !== ys.length) {
        throw new Error("not of equal size");
      }
      const uf = UnionFind.create();
      for (let i = 0; i < xs.length; i++) {
        const x = xs[i];
        const y = ys[i];
        if (x.type === "Variable" && x.symbol === "_")
          continue;
        if (y.type === "Variable" && y.symbol === "_")
          continue;
        if (x.type === "Variable") {
          if (!uf.unify(x, y)) {
            throw new Error(`cannot unify ${termKey(x)} ${termKey(y)}`);
          }
        } else if (y.type === "Variable") {
          if (!uf.unify(y, x)) {
            throw new Error(`cannot unify ${termKey(x)} ${termKey(y)}`);
          }
        } else if (!termsEqual(x, y)) {
          throw new Error(`cannot unify ${termKey(x)} ${termKey(y)}`);
        }
      }
      return uf;
    }
    function unifyTermsExtend(xs, ys, base) {
      if (xs.length !== ys.length) {
        throw new Error("not of equal size");
      }
      const uf = base.copy();
      for (let i = 0; i < xs.length; i++) {
        const x = xs[i];
        const y = ys[i];
        if (x.type === "Variable" && x.symbol === "_")
          continue;
        if (y.type === "Variable" && y.symbol === "_")
          continue;
        if (x.type === "Variable") {
          if (!uf.unify(x, y)) {
            throw new Error(`cannot unify ${termKey(x)} ${termKey(y)}`);
          }
        } else if (y.type === "Variable") {
          if (!uf.unify(y, x)) {
            throw new Error(`cannot unify ${termKey(x)} ${termKey(y)}`);
          }
        } else if (!termsEqual(x, y)) {
          throw new Error(`cannot unify ${termKey(x)} ${termKey(y)}`);
        }
      }
      return uf;
    }
  }
});

// server/analysis/rewrite.js
var require_rewrite = __commonJS({
  "server/analysis/rewrite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewriteClause = rewriteClause;
    function collectVars(term, vars) {
      switch (term.type) {
        case "Variable": {
          const v = term;
          if (v.symbol !== "_") {
            vars.add(v.symbol);
          }
          break;
        }
        case "Atom": {
          const atom = term;
          for (const arg of atom.args) {
            collectVars(arg, vars);
          }
          break;
        }
        case "NegAtom": {
          const negAtom = term;
          collectVars(negAtom.atom, vars);
          break;
        }
        case "Eq":
        case "Ineq": {
          const eq = term;
          collectVars(eq.left, vars);
          collectVars(eq.right, vars);
          break;
        }
        case "ApplyFn": {
          const applyFn = term;
          for (const arg of applyFn.args) {
            collectVars(arg, vars);
          }
          break;
        }
      }
    }
    function rewriteClause(clause) {
      if (!clause.premises || clause.premises.length === 0) {
        return clause;
      }
      const boundVars = /* @__PURE__ */ new Set();
      const premises = [];
      const delayNegAtom = [];
      const delayVars = [];
      for (const p of clause.premises) {
        let needsDelay = false;
        switch (p.type) {
          case "Atom": {
            const defVars = /* @__PURE__ */ new Set();
            collectVars(p, defVars);
            for (const v of defVars) {
              boundVars.add(v);
            }
            break;
          }
          case "Eq": {
            const eqVars = /* @__PURE__ */ new Set();
            collectVars(p, eqVars);
            for (const v of eqVars) {
              boundVars.add(v);
            }
            break;
          }
          case "NegAtom": {
            const negVars = /* @__PURE__ */ new Set();
            collectVars(p, negVars);
            const unboundVars = /* @__PURE__ */ new Set();
            for (const v of negVars) {
              if (!boundVars.has(v)) {
                unboundVars.add(v);
              }
            }
            if (unboundVars.size > 0) {
              needsDelay = true;
              delayNegAtom.push(p);
              delayVars.push(unboundVars);
            }
            break;
          }
        }
        if (!needsDelay) {
          premises.push(p);
          const toRemove = [];
          for (let i = 0; i < delayVars.length; i++) {
            const vars = delayVars[i];
            let allBound = true;
            for (const v of vars) {
              if (!boundVars.has(v)) {
                allBound = false;
                break;
              }
            }
            if (allBound) {
              premises.push(delayNegAtom[i]);
              toRemove.unshift(i);
            }
          }
          for (const i of toRemove) {
            delayNegAtom.splice(i, 1);
            delayVars.splice(i, 1);
          }
        }
      }
      return {
        ...clause,
        premises
      };
    }
  }
});

// server/analysis/validation.js
var require_validation = __commonJS({
  "server/analysis/validation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validate = validate;
    var ast_1 = require_ast();
    var predicates_1 = require_predicates();
    var functions_1 = require_functions();
    var symbols_12 = require_symbols();
    var unionfind_1 = require_unionfind();
    var rewrite_1 = require_rewrite();
    var STRING_CONSTANT_PREDICATES = /* @__PURE__ */ new Set([
      ":match_prefix",
      ":string:starts_with",
      ":string:ends_with",
      ":string:contains"
    ]);
    var DESTRUCTURING_PREDICATES = /* @__PURE__ */ new Set([
      ":match_pair",
      ":match_cons"
    ]);
    var FIELD_SELECTOR_PREDICATES = /* @__PURE__ */ new Set([
      ":match_field",
      ":match_entry"
    ]);
    var VALID_ESCAPES = /* @__PURE__ */ new Set(["n", "t", "r", "\\", '"', "'"]);
    function validate(unit) {
      const errors = [];
      const symbolTable = (0, symbols_12.buildSymbolTable)(unit);
      const declaredPredicates = /* @__PURE__ */ new Map();
      for (const decl of unit.decls) {
        const key = `${decl.declaredAtom.predicate.symbol}/${decl.declaredAtom.predicate.arity}`;
        if (declaredPredicates.has(key)) {
          errors.push({
            code: "E044",
            message: `Predicate '${key}' declared more than once`,
            range: decl.range,
            severity: "error"
          });
        }
        declaredPredicates.set(key, decl);
      }
      for (const decl of unit.decls) {
        validateDeclaration(decl, errors);
      }
      for (const clause of unit.clauses) {
        validateClause(clause, symbolTable, errors, declaredPredicates);
      }
      for (const clause of unit.clauses) {
        const pred = clause.head.predicate;
        const predKey = `${pred.symbol}/${pred.arity}`;
        const decl = declaredPredicates.get(predKey);
        if (decl && clause.headTime && !(0, ast_1.isEternalInterval)(clause.headTime)) {
          if (!(0, ast_1.isDeclTemporal)(decl) && !(0, ast_1.isDeclMaybeTemporal)(decl)) {
            errors.push({
              code: "E058",
              message: `Predicate '${pred.symbol}' is not declared temporal but used with temporal annotation`,
              range: clause.head.range,
              severity: "error"
            });
          }
        }
        if (decl && ((0, ast_1.isDeclTemporal)(decl) || (0, ast_1.isDeclMaybeTemporal)(decl))) {
          if (!clause.headTime && clause.premises && clause.premises.length > 0) {
            errors.push({
              code: "E059",
              message: `Temporal predicate '${pred.symbol}' defined without temporal annotation`,
              range: clause.head.range,
              severity: "error"
            });
          }
        }
      }
      validateArityConsistency(unit, errors);
      return { errors, symbolTable };
    }
    function validateDeclaration(decl, errors) {
      const declAtom = decl.declaredAtom;
      const descriptors = decl.descr || [];
      const expectedArgs = /* @__PURE__ */ new Map();
      for (let i = 0; i < declAtom.args.length; i++) {
        const arg = declAtom.args[i];
        if (arg && arg.type !== "Variable") {
          errors.push({
            code: "E024",
            message: `Declaration argument ${i + 1} must be a variable, got ${arg.type}`,
            range: arg.range,
            severity: "error"
          });
        } else if (arg && arg.type === "Variable") {
          expectedArgs.set(arg.symbol, arg);
        }
      }
      if (decl.bounds && decl.bounds.length > 0) {
        for (const boundDecl of decl.bounds) {
          if (boundDecl.bounds.length !== declAtom.args.length) {
            errors.push({
              code: "E025",
              message: `Declaration has ${declAtom.args.length} arguments but ${boundDecl.bounds.length} bounds`,
              range: declAtom.range,
              severity: "error"
            });
          }
          for (let i = 0; i < boundDecl.bounds.length; i++) {
            const bound = boundDecl.bounds[i];
            if (bound && bound.type === "ApplyFn") {
              const applyFn = bound;
              const fnSym = applyFn.function.symbol;
              if (!(0, functions_1.isTypeConstructor)(fnSym)) {
                errors.push({
                  code: "E061",
                  message: `In bound declaration: '${fnSym}' is not a valid type constructor`,
                  range: bound.range,
                  severity: "error"
                });
              }
            }
          }
        }
      }
      let seenDoc = false;
      const expectedArgsForArgCheck = new Map(expectedArgs);
      let hasAnyArgDescr = false;
      for (const descrAtom of descriptors) {
        const sym = descrAtom.predicate.symbol;
        if (sym === "doc") {
          if (seenDoc) {
            errors.push({
              code: "E051",
              message: `descr[] can only have one doc atom`,
              range: descrAtom.range,
              severity: "error"
            });
          }
          seenDoc = true;
          if (descrAtom.args.length === 0) {
            errors.push({
              code: "E052",
              message: `descr atom must not be empty`,
              range: descrAtom.range,
              severity: "error"
            });
            continue;
          }
          for (const docArg of descrAtom.args) {
            if (docArg.type !== "Constant" || docArg.constantType !== "string") {
              errors.push({
                code: "E053",
                message: `expected string constant in doc(), got ${docArg.type}`,
                range: docArg.range,
                severity: "error"
              });
            }
          }
        } else if (sym === "arg") {
          hasAnyArgDescr = true;
          if (descrAtom.args.length < 2) {
            errors.push({
              code: "E054",
              message: `arg atom must have at least 2 args`,
              range: descrAtom.range,
              severity: "error"
            });
            continue;
          }
          const firstArg = descrAtom.args[0];
          if (firstArg.type !== "Variable") {
            errors.push({
              code: "E055",
              message: `arg atom must have variable as first arg, got ${firstArg.type}`,
              range: firstArg.range,
              severity: "error"
            });
            continue;
          }
          const varName = firstArg.symbol;
          if (!expectedArgsForArgCheck.has(varName)) {
            errors.push({
              code: "E056",
              message: `arg atom for an unknown variable ${varName}`,
              range: firstArg.range,
              severity: "error"
            });
            continue;
          }
          expectedArgsForArgCheck.delete(varName);
          for (let i = 1; i < descrAtom.args.length; i++) {
            const argArg = descrAtom.args[i];
            if (argArg.type !== "Constant" || argArg.constantType !== "string") {
              errors.push({
                code: "E053",
                message: `expected string constant in arg(), got ${argArg.type}`,
                range: argArg.range,
                severity: "error"
              });
            }
          }
        }
      }
      const isExternal = descriptors.some((d) => d.predicate.symbol === "external");
      if (isExternal) {
        const modeCount = descriptors.filter((d) => d.predicate.symbol === "mode").length;
        if (modeCount !== 1) {
          errors.push({
            code: "E026",
            message: `External predicate must have exactly one mode declaration, got ${modeCount}`,
            range: declAtom.range,
            severity: "error"
          });
        }
      }
      const isSynthetic = descriptors.some((d) => d.predicate.symbol === "synthetic");
      if (!isSynthetic && hasAnyArgDescr && expectedArgsForArgCheck.size > 0 && expectedArgsForArgCheck.size !== declAtom.args.length) {
        const missingVars = [...expectedArgsForArgCheck.keys()].join(", ");
        errors.push({
          code: "E057",
          message: `missing arg atoms for arguments: ${missingVars}`,
          range: declAtom.range,
          severity: "warning"
        });
      }
      const nameDescr = descriptors.find((d) => d.predicate.symbol === "name");
      if (nameDescr && nameDescr.args.length > 0) {
        const nameArg = nameDescr.args[0];
        if (nameArg && nameArg.type === "Constant") {
          const nameVal = nameArg.symbol ?? "";
          if (nameVal !== nameVal.toLowerCase()) {
            errors.push({
              code: "E031",
              message: `Package name '${nameVal}' must be lowercase`,
              range: nameArg.range,
              severity: "error"
            });
          }
        }
      }
    }
    function validateClause(clause, symbolTable, errors, declaredPredicates) {
      const rewritten = (0, rewrite_1.rewriteClause)(clause);
      const boundVars = /* @__PURE__ */ new Set();
      const headVars = /* @__PURE__ */ new Set();
      const uf = unionfind_1.UnionFind.create();
      collectAtomVariables(rewritten.head, headVars);
      if (rewritten.headTime) {
        if (rewritten.headTime.start.boundType === "variable" && rewritten.headTime.start.variable) {
          headVars.add(rewritten.headTime.start.variable.symbol);
        }
        if (rewritten.headTime.end.boundType === "variable" && rewritten.headTime.end.variable) {
          headVars.add(rewritten.headTime.end.variable.symbol);
        }
      }
      for (const arg of rewritten.head.args) {
        if (arg.type === "Variable" && arg.symbol === "_") {
          errors.push({
            code: "E039",
            message: `Wildcard '_' in head is unusual - this argument will be unbound in derived facts`,
            range: arg.range,
            severity: "warning"
          });
        }
      }
      if (rewritten.transform && (!rewritten.premises || rewritten.premises.length === 0)) {
        errors.push({
          code: "E045",
          message: `Cannot have a transform without a body`,
          range: rewritten.transform.range,
          severity: "error"
        });
      }
      if (!rewritten.premises || rewritten.premises.length === 0) {
        for (const v of headVars) {
          if (v !== "_") {
            errors.push({
              code: "E001",
              message: `Variable '${v}' in fact head must be ground (facts cannot have variables)`,
              range: rewritten.head.range,
              severity: "error"
            });
          }
        }
        return;
      }
      for (const premise of rewritten.premises) {
        validatePremise(premise, boundVars, symbolTable, errors, uf);
      }
      const bodyVars = /* @__PURE__ */ new Set();
      for (const premise of rewritten.premises) {
        collectPremiseVariables(premise, bodyVars);
      }
      if (rewritten.transform) {
        if (rewritten.transform.next) {
          errors.push({
            code: "E048",
            message: "Composing multiple transforms is not supported",
            range: rewritten.transform.next.range,
            severity: "error"
          });
        }
        validateTransform(rewritten.transform, boundVars, errors, bodyVars, headVars);
      }
      for (const v of headVars) {
        if (v === "_")
          continue;
        if (boundVars.has(v))
          continue;
        const dummyVar = { type: "Variable", symbol: v, range: rewritten.head.range };
        if (uf.isBound(dummyVar, boundVars))
          continue;
        errors.push({
          code: "E002",
          message: `Variable '${v}' in head is not bound in the body (range restriction violation)`,
          range: rewritten.head.range,
          severity: "error"
        });
      }
    }
    function validatePremise(premise, boundVars, symbolTable, errors, uf) {
      switch (premise.type) {
        case "Atom": {
          const atom = premise;
          if ((0, ast_1.isComparisonAtom)(atom)) {
            for (const arg of atom.args) {
              const argVars = /* @__PURE__ */ new Set();
              collectTermVariables(arg, argVars);
              for (const v of argVars) {
                if (v !== "_" && !boundVars.has(v)) {
                  errors.push({
                    code: "E004",
                    message: `Variable '${v}' must be bound before comparison`,
                    range: atom.range,
                    severity: "error"
                  });
                }
              }
            }
            validateAtom(atom, boundVars, symbolTable, errors);
          } else {
            validateAtom(atom, boundVars, symbolTable, errors);
            collectAtomVariables(atom, boundVars);
          }
          break;
        }
        case "NegAtom": {
          const negAtom = premise;
          const negVars = /* @__PURE__ */ new Set();
          collectAtomVariables(negAtom.atom, negVars);
          for (const v of negVars) {
            if (v !== "_" && !boundVars.has(v)) {
              errors.push({
                code: "E003",
                message: `Variable '${v}' in negated atom must be bound before the negation`,
                range: negAtom.range,
                severity: "error"
              });
            }
          }
          validateAtom(negAtom.atom, boundVars, symbolTable, errors);
          break;
        }
        case "Eq": {
          const eq = premise;
          handleEquality(eq.left, eq.right, boundVars, errors, eq.range, uf);
          break;
        }
        case "Ineq": {
          const ineq = premise;
          const leftVars = /* @__PURE__ */ new Set();
          const rightVars = /* @__PURE__ */ new Set();
          collectTermVariables(ineq.left, leftVars);
          collectTermVariables(ineq.right, rightVars);
          for (const v of leftVars) {
            if (v !== "_" && !boundVars.has(v)) {
              errors.push({
                code: "E004",
                message: `Variable '${v}' must be bound before comparison`,
                range: ineq.range,
                severity: "error"
              });
            }
          }
          for (const v of rightVars) {
            if (v !== "_" && !boundVars.has(v)) {
              errors.push({
                code: "E004",
                message: `Variable '${v}' must be bound before comparison`,
                range: ineq.range,
                severity: "error"
              });
            }
          }
          break;
        }
        default:
          if ((0, ast_1.isTemporalLiteral)(premise)) {
            const temporal = premise;
            validatePremise(temporal.literal, boundVars, symbolTable, errors);
            if (temporal.interval) {
              if (temporal.interval.start.boundType === "variable" && temporal.interval.start.variable) {
                boundVars.add(temporal.interval.start.variable.symbol);
              }
              if (temporal.interval.end.boundType === "variable" && temporal.interval.end.variable) {
                boundVars.add(temporal.interval.end.variable.symbol);
              }
            }
            if (temporal.operator && temporal.operator.interval) {
              if (temporal.operator.interval.start.boundType === "variable" && temporal.operator.interval.start.variable) {
                boundVars.add(temporal.operator.interval.start.variable.symbol);
              }
              if (temporal.operator.interval.end.boundType === "variable" && temporal.operator.interval.end.variable) {
                boundVars.add(temporal.operator.interval.end.variable.symbol);
              }
            }
            break;
          }
          if ((0, ast_1.isTemporalAtom)(premise)) {
            const ta = premise;
            if (!ta.interval) {
              validatePremise(ta.atom, boundVars, symbolTable, errors);
            } else {
              validatePremise(ta.atom, boundVars, symbolTable, errors);
              if (ta.interval.start.boundType === "variable" && ta.interval.start.variable) {
                boundVars.add(ta.interval.start.variable.symbol);
              }
              if (ta.interval.end.boundType === "variable" && ta.interval.end.variable) {
                boundVars.add(ta.interval.end.variable.symbol);
              }
            }
            break;
          }
          break;
      }
    }
    function validateAtom(atom, boundVars, symbolTable, errors) {
      const predName = atom.predicate.symbol;
      const arity = atom.predicate.arity;
      if (predName.startsWith(":")) {
        if (!(0, predicates_1.isBuiltinPredicate)(predName)) {
          errors.push({
            code: "E005",
            message: `Unknown built-in predicate '${predName}'`,
            range: atom.range,
            severity: "error"
          });
          return;
        }
        const builtin = (0, predicates_1.getBuiltinPredicate)(predName);
        if (builtin && builtin.arity !== arity) {
          errors.push({
            code: "E006",
            message: `Built-in predicate '${predName}' expects ${builtin.arity} arguments, got ${arity}`,
            range: atom.range,
            severity: "error"
          });
        }
        if (builtin) {
          for (let i = 0; i < builtin.mode.length && i < atom.args.length; i++) {
            const mode = builtin.mode[i];
            const arg = atom.args[i];
            if (mode === "input" && arg) {
              const argVars = /* @__PURE__ */ new Set();
              collectTermVariables(arg, argVars);
              for (const v of argVars) {
                if (v !== "_" && !boundVars.has(v)) {
                  errors.push({
                    code: "E007",
                    message: `Argument ${i + 1} of '${predName}' requires bound variable, but '${v}' is unbound`,
                    range: arg.range,
                    severity: "error"
                  });
                }
              }
            }
          }
        }
        if (STRING_CONSTANT_PREDICATES.has(predName) && atom.args.length >= 2) {
          const secondArg = atom.args[1];
          if (secondArg && secondArg.type !== "Constant") {
            errors.push({
              code: "E030",
              message: `Second argument of '${predName}' must be a constant pattern, not a ${secondArg.type}`,
              range: secondArg.range,
              severity: "error"
            });
          }
        }
        if (DESTRUCTURING_PREDICATES.has(predName) && atom.args.length >= 3) {
          const arg2 = atom.args[1];
          const arg3 = atom.args[2];
          if (arg2 && arg2.type !== "Variable") {
            errors.push({
              code: "E033",
              message: `Second argument of '${predName}' must be a variable for destructuring, got ${arg2.type}`,
              range: arg2.range,
              severity: "error"
            });
          }
          if (arg3 && arg3.type !== "Variable") {
            errors.push({
              code: "E033",
              message: `Third argument of '${predName}' must be a variable for destructuring, got ${arg3.type}`,
              range: arg3.range,
              severity: "error"
            });
          }
        }
        if (FIELD_SELECTOR_PREDICATES.has(predName) && atom.args.length >= 2) {
          const fieldArg = atom.args[1];
          if (fieldArg && fieldArg.type !== "Constant") {
            errors.push({
              code: "E034",
              message: `Field selector (argument 2) of '${predName}' must be a constant, got ${fieldArg.type}`,
              range: fieldArg.range,
              severity: "error"
            });
          }
        }
      }
      if (!predName.startsWith(":") && !predName.startsWith("fn:")) {
        const predKey = `${predName}/${arity}`;
        const predInfo = symbolTable.getPredicateInfo(predKey);
        const hasDefs = predInfo && (predInfo.definitions.length > 0 || predInfo.declLocation);
        if (!hasDefs) {
          const availableArities = symbolTable.getPredicateArities(predName);
          const definedArities = availableArities?.filter((a) => {
            const info = symbolTable.getPredicateInfo(`${predName}/${a}`);
            return info && (info.definitions.length > 0 || info.declLocation);
          });
          if (definedArities && definedArities.length > 0 && !definedArities.includes(arity)) {
            errors.push({
              code: "E040",
              message: `Predicate '${predName}' called with ${arity} arguments, but available arities are: ${definedArities.join(", ")}`,
              range: atom.range,
              severity: "error"
            });
          }
        } else {
          if (predInfo.isPrivate) {
            errors.push({
              code: "E041",
              message: `Predicate '${predName}' is marked private and may not be accessible from other packages`,
              range: atom.range,
              severity: "error"
            });
          }
        }
      }
      for (const arg of atom.args) {
        if (arg.type === "ApplyFn") {
          validateApplyFn(arg, boundVars, errors);
        }
        if (arg.type === "Constant") {
          validateNameConstant(arg, errors);
        }
      }
    }
    var COMMON_FUNCTION_CASING_ERRORS = /* @__PURE__ */ new Map([
      ["fn:Sum", "fn:sum"],
      ["fn:Count", "fn:count"],
      ["fn:Max", "fn:max"],
      ["fn:Min", "fn:min"],
      ["fn:Avg", "fn:avg"],
      ["fn:Plus", "fn:plus"],
      ["fn:Minus", "fn:minus"],
      ["fn:Mult", "fn:mult"],
      ["fn:Div", "fn:div"],
      ["fn:Collect", "fn:collect"],
      ["fn:Group_by", "fn:group_by"],
      ["fn:GROUP_BY", "fn:group_by"]
    ]);
    var HALLUCINATED_FUNCTIONS = /* @__PURE__ */ new Map([
      // String functions that don't exist
      ["fn:string_contains", "Mangle has no substring search. Use :match_prefix or implement in Go"],
      ["fn:contains", "Mangle has no contains function. Use :match_prefix for prefix matching"],
      ["fn:substring", "Mangle has no substring function. Process strings in Go"],
      ["fn:match", "Mangle has no regex matching. Use :match_prefix or implement in Go"],
      ["fn:regex", "Mangle has no regex support. Implement pattern matching in Go"],
      ["fn:lower", "Mangle has no case conversion. Normalize strings in Go before loading"],
      ["fn:upper", "Mangle has no case conversion. Normalize strings in Go before loading"],
      ["fn:trim", "Mangle has no trim function. Clean strings in Go before loading"],
      ["fn:split", "Mangle has no split function. Parse strings in Go before loading"],
      ["fn:startswith", "Use the :match_prefix built-in predicate instead"],
      ["fn:endswith", "Mangle has no endswith. Implement in Go or reverse string matching"],
      ["fn:join", "Use fn:string:concat for concatenation"],
      ["fn:format", "Mangle has no format function. Use fn:string:concat or format in Go"],
      // SQL-style aggregates
      ["sum", "Use fn:sum (with fn: prefix) inside a |> let transform"],
      ["count", "Use fn:count (with fn: prefix) inside a |> let transform"],
      ["max", "Use fn:max (with fn: prefix) inside a |> let transform"],
      ["min", "Use fn:min (with fn: prefix) inside a |> let transform"],
      ["avg", "Use fn:avg (with fn: prefix) inside a |> let transform"],
      ["group_by", "Use fn:group_by inside a |> do transform"],
      // Other hallucinations
      ["fn:filter", "Filtering is done with body predicates, not fn:filter"],
      ["fn:if", "Mangle has no conditionals. Use multiple rules instead"],
      ["fn:case", "Mangle has no case expressions. Use multiple rules instead"],
      ["fn:when", "Mangle has no when expressions. Use multiple rules instead"],
      ["fn:otherwise", "Mangle has no otherwise. Use multiple rules with negation"],
      ["fn:null", "Mangle has no NULL. Use closed-world assumption with negation"],
      ["fn:coalesce", "Mangle has no coalesce. Handle missing data with multiple rules"]
    ]);
    function validateApplyFn(applyFn, boundVars, errors) {
      const fnName = applyFn.function.symbol;
      const arity = applyFn.function.arity;
      const correctCasing = COMMON_FUNCTION_CASING_ERRORS.get(fnName);
      if (correctCasing) {
        errors.push({
          code: "E018",
          message: `Function '${fnName}' has wrong casing. Use '${correctCasing}' instead (all lowercase after 'fn:')`,
          range: applyFn.range,
          severity: "error"
        });
        return;
      }
      const hallucination = HALLUCINATED_FUNCTIONS.get(fnName);
      if (hallucination) {
        errors.push({
          code: "E020",
          message: `Function '${fnName}' does not exist in Mangle. ${hallucination}`,
          range: applyFn.range,
          severity: "error"
        });
        return;
      }
      if (!(0, functions_1.isBuiltinFunction)(fnName)) {
        errors.push({
          code: "E008",
          message: `Unknown built-in function '${fnName}'`,
          range: applyFn.range,
          severity: "error"
        });
        return;
      }
      const builtin = (0, functions_1.getBuiltinFunction)(fnName);
      if (builtin && builtin.arity !== -1 && builtin.arity !== arity) {
        errors.push({
          code: "E009",
          message: `Built-in function '${fnName}' expects ${builtin.arity} arguments, got ${arity}`,
          range: applyFn.range,
          severity: "error"
        });
      }
      if (fnName === "fn:struct" || fnName === "fn:map") {
        if (applyFn.args.length % 2 !== 0) {
          const syntax = fnName === "fn:struct" ? "{ /key: value, ... }" : "[ key: value, ... ]";
          errors.push({
            code: "E027",
            message: `${fnName} requires even number of arguments (key-value pairs). Use ${syntax} syntax`,
            range: applyFn.range,
            severity: "error"
          });
        }
      }
      if ((fnName === "fn:div" || fnName === "fn:float:div") && applyFn.args.length >= 2) {
        const divisor = applyFn.args[1];
        if (divisor && divisor.type === "Constant") {
          const constant = divisor;
          if (constant.numValue === 0 || constant.floatValue === 0) {
            errors.push({
              code: "E035",
              message: `Division by zero: divisor is constant 0`,
              range: divisor.range,
              severity: "error"
            });
          }
        }
      }
      if ((0, functions_1.isReducerFunction)(fnName)) {
        const reducerDef = (0, functions_1.getBuiltinFunction)(fnName);
        if (reducerDef && reducerDef.arity === -1 && applyFn.args.length === 0) {
          errors.push({
            code: "E060",
            message: `Reducer function '${fnName}' expects at least one argument`,
            range: applyFn.range,
            severity: "error"
          });
        }
      }
      for (const arg of applyFn.args) {
        const argVars = /* @__PURE__ */ new Set();
        collectTermVariables(arg, argVars);
        for (const v of argVars) {
          if (v !== "_" && !boundVars.has(v)) {
            errors.push({
              code: "E010",
              message: `Variable '${v}' in function '${fnName}' must be bound`,
              range: arg.range,
              severity: "error"
            });
          }
        }
      }
      for (const arg of applyFn.args) {
        if (arg.type === "ApplyFn") {
          validateApplyFn(arg, boundVars, errors);
        }
        if (arg.type === "Constant") {
          validateNameConstant(arg, errors);
        }
      }
    }
    function validateTransform(transform, boundVars, errors, bodyVars, headVars) {
      if (bodyVars) {
        let checkTransform = transform;
        while (checkTransform) {
          for (const stmt of checkTransform.statements) {
            if (stmt.variable && bodyVars.has(stmt.variable.symbol)) {
              errors.push({
                code: "E043",
                message: `Transform redefines variable '${stmt.variable.symbol}' from rule body`,
                range: stmt.variable.range,
                severity: "error"
              });
            }
          }
          checkTransform = checkTransform.next;
        }
      }
      let current = transform;
      let hasGroupBy = false;
      while (current) {
        for (const stmt of current.statements) {
          if (stmt.variable === null) {
            const fnName = stmt.fn.function.symbol;
            if (fnName === "fn:group_by") {
              hasGroupBy = true;
              const groupByVars = /* @__PURE__ */ new Set();
              for (const arg of stmt.fn.args) {
                if (arg.type !== "Variable") {
                  errors.push({
                    code: "E036",
                    message: `Arguments to fn:group_by must be variables, got ${arg.type}`,
                    range: arg.range,
                    severity: "error"
                  });
                } else {
                  const v = arg.symbol;
                  if (groupByVars.has(v)) {
                    errors.push({
                      code: "E037",
                      message: `Duplicate variable '${v}' in fn:group_by - all arguments must be distinct`,
                      range: arg.range,
                      severity: "error"
                    });
                  }
                  groupByVars.add(v);
                }
              }
            } else if (!hasGroupBy) {
              errors.push({
                code: "E011",
                message: `Transform must start with 'do fn:group_by(...)', found '${fnName}'`,
                range: stmt.fn.range,
                severity: "error"
              });
            }
            for (const arg of stmt.fn.args) {
              const argVars = /* @__PURE__ */ new Set();
              collectTermVariables(arg, argVars);
              for (const v of argVars) {
                if (v !== "_" && !boundVars.has(v)) {
                  errors.push({
                    code: "E012",
                    message: `Variable '${v}' in group_by must be bound in the body`,
                    range: arg.range,
                    severity: "error"
                  });
                }
              }
            }
          } else {
            if (stmt.variable.symbol !== "_") {
              boundVars.add(stmt.variable.symbol);
            }
            const fnName = stmt.fn.function.symbol;
            if (hasGroupBy && !(0, functions_1.isReducerFunction)(fnName) && fnName !== "fn:group_by") {
              const groupByVars = /* @__PURE__ */ new Set();
              for (const s of current.statements) {
                if (s.variable === null && s.fn.function.symbol === "fn:group_by") {
                  for (const arg of s.fn.args) {
                    if (arg.type === "Variable") {
                      groupByVars.add(arg.symbol);
                    }
                  }
                  break;
                }
              }
              const transformDefs = /* @__PURE__ */ new Set();
              for (const s of current.statements) {
                if (s === stmt)
                  break;
                if (s.variable && s.variable.symbol !== "_") {
                  transformDefs.add(s.variable.symbol);
                }
              }
              const usedVars = /* @__PURE__ */ new Set();
              collectTermVariables(stmt.fn, usedVars);
              for (const v of usedVars) {
                if (!groupByVars.has(v) && !transformDefs.has(v)) {
                  errors.push({
                    code: "E047",
                    message: `Variable '${v}' in function '${fnName}' must be either part of group_by or defined in the transform`,
                    range: stmt.fn.range,
                    severity: "error"
                  });
                }
              }
            }
            if (hasGroupBy && !(0, functions_1.isReducerFunction)(fnName) && fnName !== "fn:group_by") {
              errors.push({
                code: "E013",
                message: `Function '${fnName}' is not a reducer function; after group_by, use a reducer (e.g. fn:sum, fn:collect, fn:max)`,
                range: stmt.fn.range,
                severity: "warning"
              });
            }
            validateApplyFn(stmt.fn, boundVars, errors);
          }
        }
        current = current.next;
      }
      if (hasGroupBy && headVars) {
        const groupByVarSet = /* @__PURE__ */ new Set();
        const transformDefSet = /* @__PURE__ */ new Set();
        for (const stmt of transform.statements) {
          if (stmt.variable === null && stmt.fn.function.symbol === "fn:group_by") {
            for (const arg of stmt.fn.args) {
              if (arg.type === "Variable") {
                groupByVarSet.add(arg.symbol);
              }
            }
          }
          if (stmt.variable && stmt.variable.symbol !== "_") {
            transformDefSet.add(stmt.variable.symbol);
          }
        }
        for (const v of headVars) {
          if (v === "_")
            continue;
          if (groupByVarSet.has(v))
            continue;
          if (transformDefSet.has(v))
            continue;
          errors.push({
            code: "E049",
            message: `Head variable '${v}' is neither part of group_by nor defined in the transform`,
            range: transform.range,
            severity: "error"
          });
        }
      }
      if (!hasGroupBy && transform.statements.length > 0 && transform.statements[0].variable !== null) {
        for (const stmt of transform.statements.slice(1)) {
          if (stmt.variable === null) {
            errors.push({
              code: "E050",
              message: "All statements in a let-transform must be let-statements",
              range: stmt.fn.range,
              severity: "error"
            });
          } else if ((0, functions_1.isReducerFunction)(stmt.fn.function.symbol)) {
            errors.push({
              code: "E050",
              message: `Reducer function '${stmt.fn.function.symbol}' is not allowed in a let-transform`,
              range: stmt.fn.range,
              severity: "error"
            });
          }
        }
      }
    }
    function handleEquality(left, right, boundVars, errors, range, uf) {
      if (left.type === "Variable" && left.symbol !== "_") {
        const v = left.symbol;
        if (right.type === "Constant" || isGroundOrBound(right, boundVars)) {
          boundVars.add(v);
        }
      }
      if (right.type === "Variable" && right.symbol !== "_") {
        const v = right.symbol;
        if (left.type === "Constant" || isGroundOrBound(left, boundVars)) {
          boundVars.add(v);
        }
      }
      if (left.type === "ApplyFn") {
        const leftVars = /* @__PURE__ */ new Set();
        collectTermVariables(left, leftVars);
        for (const v of leftVars) {
          if (v !== "_" && !boundVars.has(v)) {
            errors.push({
              code: "E014",
              message: `Variable '${v}' in function application must be bound`,
              range,
              severity: "error"
            });
          }
        }
        validateApplyFn(left, boundVars, errors);
        if (right.type === "Variable" && right.symbol !== "_") {
          boundVars.add(right.symbol);
        }
      }
      if (right.type === "ApplyFn") {
        const rightVars = /* @__PURE__ */ new Set();
        collectTermVariables(right, rightVars);
        for (const v of rightVars) {
          if (v !== "_" && !boundVars.has(v)) {
            errors.push({
              code: "E014",
              message: `Variable '${v}' in function application must be bound`,
              range,
              severity: "error"
            });
          }
        }
        validateApplyFn(right, boundVars, errors);
        if (left.type === "Variable" && left.symbol !== "_") {
          boundVars.add(left.symbol);
        }
      }
      if (left.type === "Constant") {
        validateNameConstant(left, errors);
      }
      if (right.type === "Constant") {
        validateNameConstant(right, errors);
      }
      if (uf && left.type === "Variable" && right.type === "Variable") {
        const leftVar = left;
        const rightVar = right;
        if (leftVar.symbol !== "_" && rightVar.symbol !== "_") {
          uf.unify(leftVar, rightVar);
        }
      }
    }
    function isGroundOrBound(term, boundVars) {
      if (term.type === "Constant") {
        return true;
      }
      if (term.type === "Variable") {
        const v = term.symbol;
        return v === "_" || boundVars.has(v);
      }
      if (term.type === "ApplyFn") {
        const applyFn = term;
        return applyFn.args.every((arg) => isGroundOrBound(arg, boundVars));
      }
      return false;
    }
    function validateNameConstant(constant, errors) {
      if (constant.constantType === "name" && constant.symbol) {
        const name = constant.symbol;
        if (name.includes("//")) {
          errors.push({
            code: "E032",
            message: `Name constant '${name}' contains empty part (double slash)`,
            range: constant.range,
            severity: "error"
          });
        }
        if (name.length > 1 && name.endsWith("/")) {
          errors.push({
            code: "E032",
            message: `Name constant '${name}' has trailing slash`,
            range: constant.range,
            severity: "error"
          });
        }
        if (name === "/") {
          errors.push({
            code: "E032",
            message: `Name constant must be non-empty after '/'`,
            range: constant.range,
            severity: "error"
          });
        }
      }
      if (constant.constantType === "string" && constant.symbol) {
        validateStringEscapes(constant.symbol, constant.range, errors);
      }
    }
    function validateStringEscapes(str, range, errors) {
      let i = 0;
      while (i < str.length) {
        if (str[i] === "\\") {
          if (i + 1 >= str.length) {
            errors.push({
              code: "E038",
              message: `Invalid escape sequence: backslash at end of string`,
              range,
              severity: "error"
            });
            break;
          }
          const next = str[i + 1];
          if (next === "x") {
            if (i + 3 >= str.length) {
              errors.push({
                code: "E038",
                message: `Invalid hex escape: \\x requires two hex digits`,
                range,
                severity: "error"
              });
            }
            i += 4;
          } else if (next === "u") {
            if (i + 2 >= str.length || str[i + 2] !== "{") {
              errors.push({
                code: "E038",
                message: `Invalid unicode escape: \\u must be followed by {hex}`,
                range,
                severity: "error"
              });
            }
            let j = i + 3;
            while (j < str.length && str[j] !== "}")
              j++;
            if (j >= str.length) {
              errors.push({
                code: "E038",
                message: `Invalid unicode escape: missing closing brace`,
                range,
                severity: "error"
              });
            }
            i = j + 1;
          } else if (VALID_ESCAPES.has(next)) {
            i += 2;
          } else {
            errors.push({
              code: "E038",
              message: `Invalid escape sequence: \\${next}`,
              range,
              severity: "error"
            });
            i += 2;
          }
        } else {
          i++;
        }
      }
    }
    function collectAtomVariables(atom, vars) {
      for (const arg of atom.args) {
        collectTermVariables(arg, vars);
      }
    }
    function collectTermVariables(term, vars) {
      switch (term.type) {
        case "Variable": {
          const v = term;
          if (v.symbol !== "_") {
            vars.add(v.symbol);
          }
          break;
        }
        case "ApplyFn": {
          const applyFn = term;
          for (const arg of applyFn.args) {
            collectTermVariables(arg, vars);
          }
          break;
        }
        case "Constant":
          break;
      }
    }
    function collectPremiseVariables(premise, vars) {
      switch (premise.type) {
        case "Atom": {
          const atom = premise;
          collectAtomVariables(atom, vars);
          break;
        }
        case "NegAtom": {
          const negAtom = premise;
          collectAtomVariables(negAtom.atom, vars);
          break;
        }
        case "Eq": {
          const eq = premise;
          collectTermVariables(eq.left, vars);
          collectTermVariables(eq.right, vars);
          break;
        }
        case "Ineq": {
          const ineq = premise;
          collectTermVariables(ineq.left, vars);
          collectTermVariables(ineq.right, vars);
          break;
        }
        default:
          if ((0, ast_1.isTemporalLiteral)(premise)) {
            const temporal = premise;
            collectPremiseVariables(temporal.literal, vars);
            if (temporal.interval) {
              if (temporal.interval.start.variable) {
                vars.add(temporal.interval.start.variable.symbol);
              }
              if (temporal.interval.end.variable) {
                vars.add(temporal.interval.end.variable.symbol);
              }
            }
            if (temporal.operator && temporal.operator.interval) {
              if (temporal.operator.interval.start.variable) {
                vars.add(temporal.operator.interval.start.variable.symbol);
              }
              if (temporal.operator.interval.end.variable) {
                vars.add(temporal.operator.interval.end.variable.symbol);
              }
            }
            break;
          }
          if ((0, ast_1.isTemporalAtom)(premise)) {
            const ta = premise;
            collectAtomVariables(ta.atom, vars);
            if (ta.interval) {
              if (ta.interval.start.variable) {
                vars.add(ta.interval.start.variable.symbol);
              }
              if (ta.interval.end.variable) {
                vars.add(ta.interval.end.variable.symbol);
              }
            }
            break;
          }
          collectTermVariables(premise, vars);
          break;
      }
    }
    function validateArityConsistency(unit, errors) {
      const predicateArities = /* @__PURE__ */ new Map();
      for (const clause of unit.clauses) {
        const name = clause.head.predicate.symbol;
        const arity = clause.head.predicate.arity;
        if (!predicateArities.has(name)) {
          predicateArities.set(name, /* @__PURE__ */ new Set());
        }
        predicateArities.get(name).add(arity);
      }
      for (const decl of unit.decls) {
        const name = decl.declaredAtom.predicate.symbol;
        const arity = decl.declaredAtom.predicate.arity;
        const arities = predicateArities.get(name);
        if (arities && !arities.has(arity)) {
          errors.push({
            code: "E046",
            message: `Declaration arity ${arity} doesn't match clause arities: ${[...arities].join(", ")}`,
            range: decl.range,
            severity: "error"
          });
        }
      }
    }
  }
});

// server/analysis/stratification.js
var require_stratification = __commonJS({
  "server/analysis/stratification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStratification = checkStratification;
    exports2.checkUnboundedRecursion = checkUnboundedRecursion;
    exports2.checkCartesianExplosion = checkCartesianExplosion;
    exports2.checkLateFiltering = checkLateFiltering;
    exports2.checkLateNegation = checkLateNegation;
    exports2.checkMultipleIndependentVars = checkMultipleIndependentVars;
    exports2.checkTemporalRecursion = checkTemporalRecursion;
    var ast_1 = require_ast();
    function checkStratification(unit) {
      const errors = [];
      const edges = buildDependencyGraph(unit);
      const sccs = findSCCs(edges);
      for (const scc of sccs) {
        const firstNode = scc[0];
        if (!firstNode)
          continue;
        if (scc.length > 1 || hasSelfLoop(firstNode, edges)) {
          const negativeEdge = findNegativeEdgeInSCC(scc, edges);
          if (negativeEdge) {
            errors.push({
              code: "E015",
              message: `Stratification violation: negation cycle detected involving predicates: ${scc.join(" -> ")}`,
              range: negativeEdge.range,
              severity: "error",
              cycle: scc
            });
          }
        }
      }
      return errors;
    }
    function buildDependencyGraph(unit) {
      const edges = [];
      for (const clause of unit.clauses) {
        const headPred = predicateKey(clause.head.predicate);
        if (clause.premises) {
          for (const premise of clause.premises) {
            addEdgesFromPremise(headPred, premise, clause.head.range, edges, clause);
          }
        }
      }
      return edges;
    }
    function isLetTransform(transform) {
      if (!transform) {
        return true;
      }
      const firstStmt = transform.statements[0];
      return firstStmt?.variable !== null;
    }
    function addEdgesFromPremise(headPred, premise, range, edges, clause) {
      switch (premise.type) {
        case "Atom": {
          const atom = premise;
          const bodyPred = predicateKey(atom.predicate);
          if (!atom.predicate.symbol.startsWith(":")) {
            const isNegative = !isLetTransform(clause.transform);
            edges.push({
              from: headPred,
              to: bodyPred,
              isNegative,
              range: atom.range
            });
          }
          break;
        }
        case "NegAtom": {
          const negAtom = premise;
          const bodyPred = predicateKey(negAtom.atom.predicate);
          if (!negAtom.atom.predicate.symbol.startsWith(":")) {
            edges.push({
              from: headPred,
              to: bodyPred,
              isNegative: true,
              range: negAtom.range
            });
          }
          break;
        }
        default: {
          if ((0, ast_1.isTemporalLiteral)(premise)) {
            const temporal = premise;
            addEdgesFromPremise(headPred, temporal.literal, range, edges, clause);
          }
          break;
        }
      }
    }
    function predicateKey(pred) {
      return `${pred.symbol}/${pred.arity}`;
    }
    function findSCCs(edges) {
      const adj = /* @__PURE__ */ new Map();
      const allNodes = /* @__PURE__ */ new Set();
      for (const edge of edges) {
        allNodes.add(edge.from);
        allNodes.add(edge.to);
        const neighbors = adj.get(edge.from) || [];
        neighbors.push(edge.to);
        adj.set(edge.from, neighbors);
      }
      let index = 0;
      const indices = /* @__PURE__ */ new Map();
      const lowlinks = /* @__PURE__ */ new Map();
      const onStack = /* @__PURE__ */ new Set();
      const stack = [];
      const sccs = [];
      function strongConnect(node) {
        indices.set(node, index);
        lowlinks.set(node, index);
        index++;
        stack.push(node);
        onStack.add(node);
        const neighbors = adj.get(node) || [];
        for (const neighbor of neighbors) {
          if (!indices.has(neighbor)) {
            strongConnect(neighbor);
            lowlinks.set(node, Math.min(lowlinks.get(node), lowlinks.get(neighbor)));
          } else if (onStack.has(neighbor)) {
            lowlinks.set(node, Math.min(lowlinks.get(node), indices.get(neighbor)));
          }
        }
        if (lowlinks.get(node) === indices.get(node)) {
          const scc = [];
          let w;
          do {
            w = stack.pop();
            onStack.delete(w);
            scc.push(w);
          } while (w !== node);
          sccs.push(scc);
        }
      }
      for (const node of allNodes) {
        if (!indices.has(node)) {
          strongConnect(node);
        }
      }
      return sccs;
    }
    function hasSelfLoop(node, edges) {
      return edges.some((e) => e.from === node && e.to === node);
    }
    function findNegativeEdgeInSCC(scc, edges) {
      const sccSet = new Set(scc);
      for (const edge of edges) {
        if (edge.isNegative && sccSet.has(edge.from) && sccSet.has(edge.to)) {
          return edge;
        }
      }
      return null;
    }
    function checkUnboundedRecursion(unit) {
      const warnings = [];
      const predicateClauses = /* @__PURE__ */ new Map();
      for (const clause of unit.clauses) {
        const key = predicateKey(clause.head.predicate);
        const clauses = predicateClauses.get(key) || [];
        clauses.push(clause);
        predicateClauses.set(key, clauses);
      }
      for (const [predKey, clauses] of predicateClauses) {
        const recursiveClauses = clauses.filter((c) => isRecursive(c, predKey));
        if (recursiveClauses.length > 0) {
          const firstRecursive = recursiveClauses[0];
          if (!firstRecursive)
            continue;
          const hasBaseCase = clauses.some((c) => !isRecursive(c, predKey));
          if (!hasBaseCase) {
            warnings.push({
              code: "E016",
              message: `Predicate '${predKey}' has recursive rules but no base case - may not terminate`,
              range: firstRecursive.head.range,
              severity: "warning",
              cycle: [predKey]
            });
          }
          for (const clause of recursiveClauses) {
            if (hasUnboundedGeneration(clause, predKey)) {
              warnings.push({
                code: "E017",
                message: `Recursive rule may generate unbounded values - ensure termination condition exists`,
                range: clause.head.range,
                severity: "warning",
                cycle: [predKey]
              });
            }
          }
        }
      }
      return warnings;
    }
    function isRecursive(clause, predKey) {
      if (!clause.premises)
        return false;
      for (const premise of clause.premises) {
        if (premise.type === "Atom") {
          const atom = premise;
          if (predicateKey(atom.predicate) === predKey) {
            return true;
          }
        }
      }
      return false;
    }
    function hasUnboundedGeneration(clause, predKey) {
      if (!clause.premises)
        return false;
      let hasArithmeticIncrement = false;
      for (const premise of clause.premises) {
        if (premise.type === "Eq") {
          const eq = premise;
          if (eq.right.type === "ApplyFn") {
            const fn = eq.right;
            if (fn.function.symbol === "fn:plus" || fn.function.symbol === "fn:minus") {
              hasArithmeticIncrement = true;
            }
          }
        }
      }
      if (hasArithmeticIncrement) {
        const hasComparison = clause.premises.some((p) => (0, ast_1.isComparisonAtom)(p));
        if (!hasComparison) {
          return true;
        }
      }
      return false;
    }
    function checkCartesianExplosion(unit) {
      const warnings = [];
      for (const clause of unit.clauses) {
        if (!clause.premises || clause.premises.length < 2) {
          continue;
        }
        const atoms = [];
        for (const premise of clause.premises) {
          if (premise.type === "Atom") {
            const atom = premise;
            if (atom.predicate.symbol.startsWith(":")) {
              continue;
            }
            const vars = /* @__PURE__ */ new Set();
            for (const arg of atom.args) {
              collectVarsFromTerm(arg, vars);
            }
            atoms.push({ atom, vars });
          }
        }
        for (let i = 0; i < atoms.length - 1; i++) {
          const current = atoms[i];
          const next = atoms[i + 1];
          if (!current || !next)
            continue;
          let hasSharedVar = false;
          for (const v of current.vars) {
            if (v !== "_" && next.vars.has(v)) {
              hasSharedVar = true;
              break;
            }
          }
          if (!hasSharedVar && current.vars.size > 0 && next.vars.size > 0) {
            warnings.push({
              code: "E019",
              message: `Potential Cartesian explosion: predicates '${current.atom.predicate.symbol}' and '${next.atom.predicate.symbol}' have no shared variables. Consider reordering body atoms to join on shared variables first.`,
              range: next.atom.range,
              severity: "warning",
              cycle: [current.atom.predicate.symbol, next.atom.predicate.symbol]
            });
          }
        }
      }
      return warnings;
    }
    function collectVarsFromTerm(term, vars) {
      switch (term.type) {
        case "Variable": {
          const v = term;
          vars.add(v.symbol);
          break;
        }
        case "ApplyFn": {
          const fn = term;
          for (const arg of fn.args) {
            collectVarsFromTerm(arg, vars);
          }
          break;
        }
      }
    }
    function checkLateFiltering(unit) {
      const warnings = [];
      for (const clause of unit.clauses) {
        if (!clause.premises || clause.premises.length < 3) {
          continue;
        }
        let predicateCount = 0;
        let allVarsSoFar = /* @__PURE__ */ new Set();
        for (const premise of clause.premises) {
          if (premise.type === "Ineq") {
            if (predicateCount >= 2) {
              const cmp = premise;
              warnings.push({
                code: "E021",
                message: `Late filtering: comparison appears after ${predicateCount} predicates. Consider moving filters earlier to reduce intermediate result size.`,
                range: cmp.range,
                severity: "warning",
                cycle: []
              });
            }
          } else if (premise.type === "Atom") {
            const atom = premise;
            const predSymbol = atom.predicate.symbol;
            if (predSymbol === ":lt" || predSymbol === ":le" || predSymbol === ":gt" || predSymbol === ":ge") {
              if (predicateCount >= 2) {
                warnings.push({
                  code: "E021",
                  message: `Late filtering: comparison appears after ${predicateCount} predicates. Consider moving filters earlier to reduce intermediate result size.`,
                  range: atom.range,
                  severity: "warning",
                  cycle: []
                });
              }
            } else if (!predSymbol.startsWith(":")) {
              predicateCount++;
            }
          }
        }
      }
      return warnings;
    }
    function checkLateNegation(unit) {
      const warnings = [];
      for (const clause of unit.clauses) {
        if (!clause.premises || clause.premises.length < 3) {
          continue;
        }
        let predicateCount = 0;
        for (const premise of clause.premises) {
          if (premise.type === "NegAtom") {
            if (predicateCount >= 2) {
              const negAtom = premise;
              const negVars = /* @__PURE__ */ new Set();
              for (const arg of negAtom.atom.args) {
                collectVarsFromTerm(arg, negVars);
              }
              const firstPremise = clause.premises[0];
              if (firstPremise && firstPremise.type === "Atom") {
                const firstAtom = firstPremise;
                const firstVars = /* @__PURE__ */ new Set();
                for (const arg of firstAtom.args) {
                  collectVarsFromTerm(arg, firstVars);
                }
                let allBound = true;
                for (const v of negVars) {
                  if (v !== "_" && !firstVars.has(v)) {
                    allBound = false;
                    break;
                  }
                }
                if (allBound) {
                  warnings.push({
                    code: "E022",
                    message: `Late negation: '!${negAtom.atom.predicate.symbol}' appears after ${predicateCount} predicates but its variables are bound by the first predicate. Consider moving negation earlier to filter sooner.`,
                    range: negAtom.range,
                    severity: "warning",
                    cycle: []
                  });
                }
              }
            }
          } else if (premise.type === "Atom") {
            const atom = premise;
            if (!atom.predicate.symbol.startsWith(":")) {
              predicateCount++;
            }
          }
        }
      }
      return warnings;
    }
    function checkMultipleIndependentVars(unit) {
      const warnings = [];
      for (const clause of unit.clauses) {
        if (!clause.premises || clause.premises.length < 3) {
          continue;
        }
        const predicates = [];
        for (const premise of clause.premises) {
          if (premise.type === "Atom") {
            const atom = premise;
            if (!atom.predicate.symbol.startsWith(":")) {
              const vars = /* @__PURE__ */ new Set();
              for (const arg of atom.args) {
                collectVarsFromTerm(arg, vars);
              }
              predicates.push({ atom, vars });
            }
          }
        }
        if (predicates.length < 3)
          continue;
        const first = predicates[0];
        const second = predicates[1];
        const third = predicates[2];
        if (!first || !second || !third)
          continue;
        let firstSecondShare = false;
        for (const v of first.vars) {
          if (v !== "_" && second.vars.has(v)) {
            firstSecondShare = true;
            break;
          }
        }
        let thirdShares = false;
        const firstTwoVars = /* @__PURE__ */ new Set([...first.vars, ...second.vars]);
        for (const v of third.vars) {
          if (v !== "_" && firstTwoVars.has(v)) {
            thirdShares = true;
            break;
          }
        }
        if (!firstSecondShare && !thirdShares && first.vars.size > 0 && second.vars.size > 0 && third.vars.size > 0) {
          warnings.push({
            code: "E023",
            message: `Massive Cartesian product: predicates '${first.atom.predicate.symbol}', '${second.atom.predicate.symbol}', and '${third.atom.predicate.symbol}' have no shared variables. This creates N\xD7M\xD7K combinations. Reorder to use joining predicates first.`,
            range: third.atom.range,
            severity: "warning",
            // Performance warning, not a semantic error
            cycle: [first.atom.predicate.symbol, second.atom.predicate.symbol, third.atom.predicate.symbol]
          });
        }
      }
      return warnings;
    }
    function checkTemporalRecursion(unit) {
      const warnings = [];
      const temporalPreds = /* @__PURE__ */ new Set();
      for (const decl of unit.decls) {
        if (decl.descr?.some((d) => d.predicate.symbol === ast_1.DESCRIPTORS.TEMPORAL)) {
          temporalPreds.add(predicateKey(decl.declaredAtom.predicate));
        }
      }
      for (const clause of unit.clauses) {
        if (clause.headTime) {
          temporalPreds.add(predicateKey(clause.head.predicate));
        }
      }
      if (temporalPreds.size === 0) {
        return warnings;
      }
      const edges = buildDependencyGraph(unit);
      const sccs = findSCCs(edges);
      for (const scc of sccs) {
        if (scc.length === 1) {
          const pred = scc[0];
          if (temporalPreds.has(pred) && hasSelfLoop(pred, edges)) {
            warnings.push({
              code: "E048",
              message: `Self-recursive temporal predicate '${pred}' may cause interval explosion; ensure coalescing or use interval limits`,
              range: findPredicateRange(unit, pred),
              severity: "warning",
              cycle: [pred]
            });
          }
        } else {
          const hasTemporalPred = scc.some((p) => temporalPreds.has(p));
          if (hasTemporalPred) {
            const temporalPredInScc = scc.find((p) => temporalPreds.has(p)) ?? scc[0];
            warnings.push({
              code: "E049",
              message: `Mutual recursion through temporal predicates may cause non-termination; ${scc.length} predicates in cycle: ${scc.join(" -> ")}`,
              range: findPredicateRange(unit, temporalPredInScc),
              severity: "error",
              cycle: scc
            });
          }
        }
      }
      for (const clause of unit.clauses) {
        const headKey = predicateKey(clause.head.predicate);
        if (!temporalPreds.has(headKey) || !clause.premises)
          continue;
        for (const premise of clause.premises) {
          if ((0, ast_1.isTemporalLiteral)(premise)) {
            const temporal = premise;
            if (temporal.operator) {
              const opType = temporal.operator.operatorType;
              if (opType === "diamondPlus" || opType === "boxPlus") {
                let litPredKey = null;
                if (temporal.literal.type === "Atom") {
                  litPredKey = predicateKey(temporal.literal.predicate);
                } else if (temporal.literal.type === "NegAtom") {
                  litPredKey = predicateKey(temporal.literal.atom.predicate);
                }
                if (litPredKey && isInSameSCC(headKey, litPredKey, sccs)) {
                  warnings.push({
                    code: "E050",
                    message: `Future operator in recursive temporal rule may cause unbounded fact generation`,
                    range: temporal.range,
                    severity: "error",
                    cycle: [headKey, litPredKey]
                  });
                }
              }
            }
          }
        }
      }
      return warnings;
    }
    function isInSameSCC(pred1, pred2, sccs) {
      for (const scc of sccs) {
        if (scc.includes(pred1) && scc.includes(pred2)) {
          return true;
        }
      }
      return false;
    }
    function findPredicateRange(unit, predKey) {
      for (const clause of unit.clauses) {
        if (predicateKey(clause.head.predicate) === predKey) {
          return clause.head.range;
        }
      }
      return { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 0, offset: 0 } };
    }
  }
});

// server/analysis/index.js
var require_analysis = __commonJS({
  "server/analysis/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_symbols(), exports2);
    __exportStar(require_validation(), exports2);
    __exportStar(require_stratification(), exports2);
    __exportStar(require_unionfind(), exports2);
    __exportStar(require_rewrite(), exports2);
  }
});

// server/services/hover.js
var require_hover = __commonJS({
  "server/services/hover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHover = getHover;
    var node_12 = require_node3();
    var predicates_1 = require_predicates();
    var functions_1 = require_functions();
    var position_1 = require_position();
    function getHover(unit, symbolTable, position) {
      const line = position.line + 1;
      const column = position.character;
      const varInfo = symbolTable.findVariableAt(line, column);
      if (varInfo) {
        return createVariableHover(varInfo);
      }
      const builtinHover = findBuiltinAtPosition(unit, line, column);
      if (builtinHover) {
        return builtinHover;
      }
      const predInfo = symbolTable.findPredicateAt(line, column);
      if (predInfo) {
        return createPredicateHover(predInfo);
      }
      return null;
    }
    function createPredicateHover(info) {
      const lines = [];
      lines.push(`**${info.symbol.symbol}/${info.symbol.arity}**`);
      lines.push("");
      if (info.documentation) {
        lines.push(info.documentation);
        lines.push("");
      }
      if (info.definitions.length > 0) {
        lines.push(`*Defined in ${info.definitions.length} clause(s)*`);
      }
      if (info.declLocation) {
        lines.push(`*Declared at line ${info.declLocation.start.line}*`);
      }
      if (info.references.length > 0) {
        lines.push(`*Referenced ${info.references.length} time(s)*`);
      }
      return {
        contents: {
          kind: node_12.MarkupKind.Markdown,
          value: lines.join("\n")
        }
      };
    }
    function createVariableHover(info) {
      const lines = [];
      lines.push(`**Variable: ${info.name}**`);
      lines.push("");
      lines.push(`*Bound at line ${info.bindingLocation.start.line}*`);
      lines.push(`*${info.occurrences.length} occurrence(s) in this clause*`);
      return {
        contents: {
          kind: node_12.MarkupKind.Markdown,
          value: lines.join("\n")
        }
      };
    }
    function findBuiltinAtPosition(unit, line, column) {
      for (const clause of unit.clauses) {
        const hover = findBuiltinInClause(clause, line, column);
        if (hover) {
          return hover;
        }
      }
      return null;
    }
    function findBuiltinInClause(clause, line, column) {
      const headHover = findBuiltinInAtom(clause.head, line, column);
      if (headHover)
        return headHover;
      if (clause.premises) {
        for (const premise of clause.premises) {
          const premiseHover = findBuiltinInTerm(premise, line, column);
          if (premiseHover)
            return premiseHover;
        }
      }
      if (clause.transform) {
        let transform = clause.transform;
        while (transform) {
          for (const stmt of transform.statements) {
            const fnHover = findBuiltinInApplyFn(stmt.fn, line, column);
            if (fnHover)
              return fnHover;
          }
          transform = transform.next;
        }
      }
      return null;
    }
    function findBuiltinInTerm(term, line, column) {
      if (term.type === "Atom") {
        return findBuiltinInAtom(term, line, column);
      }
      if (term.type === "NegAtom") {
        return findBuiltinInAtom(term.atom, line, column);
      }
      if (term.type === "ApplyFn") {
        return findBuiltinInApplyFn(term, line, column);
      }
      if (term.type === "TemporalLiteral") {
        const temporal = term;
        if (temporal.literal.type === "Atom") {
          return findBuiltinInAtom(temporal.literal, line, column);
        }
        if (temporal.literal.type === "NegAtom") {
          return findBuiltinInAtom(temporal.literal.atom, line, column);
        }
      }
      return null;
    }
    function findBuiltinInAtom(atom, line, column) {
      for (const arg of atom.args) {
        if (arg.type === "ApplyFn") {
          const fnHover = findBuiltinInApplyFn(arg, line, column);
          if (fnHover)
            return fnHover;
        }
      }
      if (atom.predicate.symbol.startsWith(":")) {
        const predicateNameRange = calculateNameRange(atom.range, atom.predicate.symbol);
        if ((0, position_1.isWithinSourceRange)(line, column, predicateNameRange)) {
          const builtin = (0, predicates_1.getBuiltinPredicate)(atom.predicate.symbol);
          if (builtin) {
            return createBuiltinPredicateHover(builtin.name, builtin.doc, builtin.arity, builtin.mode);
          }
        }
      }
      return null;
    }
    function findBuiltinInApplyFn(applyFn, line, column) {
      for (const arg of applyFn.args) {
        if (arg.type === "ApplyFn") {
          const fnHover = findBuiltinInApplyFn(arg, line, column);
          if (fnHover)
            return fnHover;
        }
      }
      const functionNameRange = calculateNameRange(applyFn.range, applyFn.function.symbol);
      if ((0, position_1.isWithinSourceRange)(line, column, functionNameRange)) {
        const builtin = (0, functions_1.getBuiltinFunction)(applyFn.function.symbol);
        if (builtin) {
          return createBuiltinFunctionHover(builtin.name, builtin.doc, builtin.arity, builtin.isReducer);
        }
      }
      return null;
    }
    function createBuiltinPredicateHover(name, doc, arity, mode) {
      const lines = [];
      lines.push(`**Built-in Predicate: ${name}/${arity}**`);
      lines.push("");
      lines.push(doc);
      lines.push("");
      lines.push(`*Mode: (${mode.join(", ")})*`);
      return {
        contents: {
          kind: node_12.MarkupKind.Markdown,
          value: lines.join("\n")
        }
      };
    }
    function createBuiltinFunctionHover(name, doc, arity, isReducer) {
      const lines = [];
      const arityStr = arity === -1 ? "variadic" : `${arity}`;
      lines.push(`**Built-in Function: ${name}** (${arityStr})`);
      lines.push("");
      lines.push(doc);
      if (isReducer) {
        lines.push("");
        lines.push("*This is a reducer function (used in aggregations)*");
      }
      return {
        contents: {
          kind: node_12.MarkupKind.Markdown,
          value: lines.join("\n")
        }
      };
    }
    function calculateNameRange(expressionRange, name) {
      return {
        start: expressionRange.start,
        end: {
          line: expressionRange.start.line,
          column: expressionRange.start.column + name.length,
          offset: expressionRange.start.offset + name.length
        }
      };
    }
  }
});

// server/services/completion.js
var require_completion = __commonJS({
  "server/services/completion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCompletions = getCompletions;
    exports2.resolveCompletion = resolveCompletion;
    var node_12 = require_node3();
    var ast_1 = require_ast();
    var predicates_1 = require_predicates();
    var functions_1 = require_functions();
    function getCompletions(document, unit, symbolTable, position) {
      const items = [];
      const lineText = document.getText({
        start: { line: position.line, character: 0 },
        end: position
      });
      const context = analyzeContext(lineText, position);
      const replaceRange = {
        start: context.replaceStart,
        end: position
      };
      switch (context.type) {
        case "builtin-predicate":
          items.push(...getBuiltinPredicateCompletions(context.prefix, replaceRange));
          break;
        case "function":
          items.push(...getBuiltinFunctionCompletions(context.prefix, replaceRange));
          break;
        case "transform-do":
          items.push(...getTransformDoCompletions(replaceRange));
          break;
        case "transform-let":
          items.push(...getReducerFunctionCompletions(replaceRange));
          break;
        case "general":
        default:
          if (symbolTable) {
            items.push(...getPredicateCompletions(symbolTable, context.prefix, replaceRange));
          }
          items.push(...getKeywordCompletions(replaceRange));
          items.push(...getBuiltinPredicateCompletions(context.prefix, replaceRange));
          if (unit) {
            items.push(...getVariableCompletions(unit, position, context.prefix, replaceRange));
          }
          break;
      }
      return items;
    }
    function analyzeContext(lineText, position) {
      const fnMatch = lineText.match(/fn:(\w*)$/);
      if (fnMatch) {
        const prefixStart = lineText.length - fnMatch[0].length;
        return {
          type: "function",
          prefix: fnMatch[1] || "",
          replaceStart: { line: position.line, character: prefixStart }
        };
      }
      const colonMatch = lineText.match(/:(\w*)$/);
      if (colonMatch) {
        if (isInsideString(lineText)) {
          return analyzeGeneralContext(lineText, position);
        }
        const beforeColon = lineText.slice(0, lineText.length - colonMatch[0].length);
        if (beforeColon.match(/\/[\w\/]*$/)) {
          return analyzeGeneralContext(lineText, position);
        }
        const nestedBuiltinMatch = lineText.match(/:(\w+:)?(\w*)$/);
        if (nestedBuiltinMatch) {
          const fullMatch = nestedBuiltinMatch[0];
          const prefixStart2 = lineText.length - fullMatch.length;
          return {
            type: "builtin-predicate",
            prefix: fullMatch.slice(1),
            // Remove leading ':'
            replaceStart: { line: position.line, character: prefixStart2 }
          };
        }
        const prefixStart = lineText.length - colonMatch[0].length;
        return {
          type: "builtin-predicate",
          prefix: colonMatch[1] || "",
          replaceStart: { line: position.line, character: prefixStart }
        };
      }
      if (/\|>\s*do\s+$/.test(lineText)) {
        return {
          type: "transform-do",
          prefix: "",
          replaceStart: position
          // No text to replace
        };
      }
      if (/let\s+\w+\s*=\s*$/.test(lineText)) {
        return {
          type: "transform-let",
          prefix: "",
          replaceStart: position
          // No text to replace
        };
      }
      return analyzeGeneralContext(lineText, position);
    }
    function analyzeGeneralContext(lineText, position) {
      const wordMatch = lineText.match(/(\w*)$/);
      const prefix = wordMatch?.[1] ?? "";
      const prefixStart = lineText.length - prefix.length;
      return {
        type: "general",
        prefix,
        replaceStart: { line: position.line, character: prefixStart }
      };
    }
    function isInsideString(lineText) {
      let inString = false;
      let stringChar = "";
      let i = 0;
      while (i < lineText.length) {
        const char = lineText[i];
        if (inString) {
          if (char === "\\" && i + 1 < lineText.length) {
            i += 2;
            continue;
          }
          if (char === stringChar) {
            inString = false;
          }
        } else {
          if (char === '"' || char === "'") {
            inString = true;
            stringChar = char;
          }
        }
        i++;
      }
      return inString;
    }
    function getBuiltinPredicateCompletions(prefix, replaceRange) {
      return predicates_1.BUILTIN_PREDICATES.filter((p) => p.name.includes(prefix)).map((pred, index) => ({
        label: pred.name,
        kind: node_12.CompletionItemKind.Function,
        detail: `Built-in predicate (${pred.mode.join(", ")})`,
        documentation: pred.doc,
        textEdit: node_12.TextEdit.replace(replaceRange, createPredicateSnippet(pred.name, pred.arity)),
        insertTextFormat: node_12.InsertTextFormat.Snippet,
        sortText: `0${index.toString().padStart(3, "0")}`
        // Sort built-ins first
      }));
    }
    function getBuiltinFunctionCompletions(prefix, replaceRange) {
      return functions_1.ALL_BUILTIN_FUNCTIONS.filter((f) => f.name.replace("fn:", "").startsWith(prefix)).map((fn, index) => ({
        label: fn.name,
        kind: node_12.CompletionItemKind.Function,
        detail: fn.isReducer ? "Reducer function" : "Built-in function",
        documentation: fn.doc,
        textEdit: node_12.TextEdit.replace(replaceRange, createFunctionSnippet(fn.name, fn.arity)),
        insertTextFormat: node_12.InsertTextFormat.Snippet,
        sortText: `0${index.toString().padStart(3, "0")}`
      }));
    }
    function getTransformDoCompletions(replaceRange) {
      return [
        {
          label: "fn:group_by",
          kind: node_12.CompletionItemKind.Function,
          detail: "Group tuples by key variables",
          documentation: "Groups all tuples by the values of key variables. Empty group_by() treats the whole relation as a group.",
          textEdit: node_12.TextEdit.replace(replaceRange, "fn:group_by(${1:Key})"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "000"
          // First
        },
        ...functions_1.ALL_BUILTIN_FUNCTIONS.filter((f) => f.name !== "fn:group_by").map((fn, index) => ({
          label: fn.name,
          kind: node_12.CompletionItemKind.Function,
          detail: fn.isReducer ? "Reducer function" : "Built-in function",
          documentation: fn.doc,
          textEdit: node_12.TextEdit.replace(replaceRange, createFunctionSnippet(fn.name, fn.arity)),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: `1${index.toString().padStart(3, "0")}`
        }))
      ];
    }
    function getReducerFunctionCompletions(replaceRange) {
      return functions_1.REDUCER_FUNCTIONS.map((fn, index) => ({
        label: fn.name,
        kind: node_12.CompletionItemKind.Function,
        detail: "Reducer function",
        documentation: fn.doc,
        textEdit: node_12.TextEdit.replace(replaceRange, createFunctionSnippet(fn.name, fn.arity)),
        insertTextFormat: node_12.InsertTextFormat.Snippet,
        sortText: `0${index.toString().padStart(3, "0")}`
      }));
    }
    function getPredicateCompletions(symbolTable, prefix, replaceRange) {
      return symbolTable.getAllPredicates().filter((p) => !p.symbol.symbol.startsWith(":")).filter((p) => p.symbol.symbol.startsWith(prefix)).map((pred, index) => ({
        label: pred.symbol.symbol,
        kind: node_12.CompletionItemKind.Method,
        detail: `${pred.symbol.symbol}/${pred.symbol.arity}`,
        documentation: pred.documentation || void 0,
        textEdit: node_12.TextEdit.replace(replaceRange, createPredicateSnippet(pred.symbol.symbol, pred.symbol.arity)),
        insertTextFormat: node_12.InsertTextFormat.Snippet,
        sortText: `1${index.toString().padStart(3, "0")}`
      }));
    }
    function getVariableCompletions(unit, position, prefix, replaceRange) {
      const clause = findClauseAtPosition(unit, position);
      if (!clause) {
        return [];
      }
      const variables = (0, ast_1.collectClauseVariables)(clause);
      const items = [];
      let index = 0;
      for (const varName of Array.from(variables)) {
        if (varName === "_") {
          continue;
        }
        if (prefix && !varName.startsWith(prefix)) {
          continue;
        }
        items.push({
          label: varName,
          kind: node_12.CompletionItemKind.Variable,
          detail: "Variable",
          textEdit: node_12.TextEdit.replace(replaceRange, varName),
          insertTextFormat: node_12.InsertTextFormat.PlainText,
          sortText: `2${index.toString().padStart(3, "0")}`
        });
        index++;
      }
      return items;
    }
    function findClauseAtPosition(unit, position) {
      const sourcePos = {
        line: position.line + 1,
        column: position.character,
        offset: 0
        // Not used for containment check
      };
      for (const clause of unit.clauses) {
        if ((0, ast_1.containsPosition)(clause.range, sourcePos)) {
          return clause;
        }
      }
      return null;
    }
    function getKeywordCompletions(replaceRange) {
      return [
        {
          label: "Decl",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Declare a predicate",
          textEdit: node_12.TextEdit.replace(replaceRange, "Decl ${1:predicate}(${2:Args})."),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "300"
        },
        {
          label: "Package",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Package declaration",
          textEdit: node_12.TextEdit.replace(replaceRange, "Package ${1:name}."),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "301"
        },
        {
          label: "Use",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Import package",
          textEdit: node_12.TextEdit.replace(replaceRange, "Use ${1:package}."),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "302"
        },
        {
          label: "bound",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Type bound constraint",
          textEdit: node_12.TextEdit.replace(replaceRange, "bound([${1:type}])"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "303"
        },
        {
          label: "descr",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Description block",
          textEdit: node_12.TextEdit.replace(replaceRange, "descr(${1:description})"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "304"
        },
        {
          label: "let",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Let binding in transform",
          textEdit: node_12.TextEdit.replace(replaceRange, "let ${1:Var} = ${2:fn:reducer}"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "305"
        },
        {
          label: "do",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Do statement in transform",
          textEdit: node_12.TextEdit.replace(replaceRange, "do ${1:fn:group_by(Key)}"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "306"
        },
        {
          label: "private",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Mark predicate as private",
          textEdit: node_12.TextEdit.replace(replaceRange, "private"),
          insertTextFormat: node_12.InsertTextFormat.PlainText,
          sortText: "307"
        },
        {
          label: "external",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Mark predicate as external",
          textEdit: node_12.TextEdit.replace(replaceRange, "external"),
          insertTextFormat: node_12.InsertTextFormat.PlainText,
          sortText: "308"
        },
        {
          label: "temporal",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Mark predicate as temporal",
          textEdit: node_12.TextEdit.replace(replaceRange, "temporal"),
          insertTextFormat: node_12.InsertTextFormat.PlainText,
          sortText: "309"
        },
        {
          label: "now",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Current evaluation time (temporal bound)",
          textEdit: node_12.TextEdit.replace(replaceRange, "now"),
          insertTextFormat: node_12.InsertTextFormat.PlainText,
          sortText: "309a"
        },
        {
          label: "@[",
          kind: node_12.CompletionItemKind.Snippet,
          detail: "Temporal interval annotation",
          documentation: "Temporal annotation: @[start, end] or @[T] for a point interval",
          textEdit: node_12.TextEdit.replace(replaceRange, "@[${1:Start}, ${2:End}]"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "309b"
        },
        {
          label: "<-[",
          kind: node_12.CompletionItemKind.Snippet,
          detail: "Diamond minus (eventually in the past)",
          documentation: "Temporal operator: <-[start, end] - there exists a time in the past interval where the predicate holds",
          textEdit: node_12.TextEdit.replace(replaceRange, "<-[${1:0s}, ${2:duration}] ${3:predicate}(${4:args})"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "309c"
        },
        {
          label: "[-[",
          kind: node_12.CompletionItemKind.Snippet,
          detail: "Box minus (always in the past)",
          documentation: "Temporal operator: [-[start, end] - for all times in the past interval, the predicate holds",
          textEdit: node_12.TextEdit.replace(replaceRange, "[-[${1:0s}, ${2:duration}] ${3:predicate}(${4:args})"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "309d"
        },
        {
          label: "<+[",
          kind: node_12.CompletionItemKind.Snippet,
          detail: "Diamond plus (eventually in the future)",
          documentation: "Temporal operator: <+[start, end] - there exists a time in the future interval where the predicate holds",
          textEdit: node_12.TextEdit.replace(replaceRange, "<+[${1:0s}, ${2:duration}] ${3:predicate}(${4:args})"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "309e"
        },
        {
          label: "[+[",
          kind: node_12.CompletionItemKind.Snippet,
          detail: "Box plus (always in the future)",
          documentation: "Temporal operator: [+[start, end] - for all times in the future interval, the predicate holds",
          textEdit: node_12.TextEdit.replace(replaceRange, "[+[${1:0s}, ${2:duration}] ${3:predicate}(${4:args})"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "309f"
        },
        {
          label: "mode",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Mode declaration for predicate",
          textEdit: node_12.TextEdit.replace(replaceRange, "mode(${1:+,-})"),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "310"
        },
        {
          label: "doc",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Documentation string",
          textEdit: node_12.TextEdit.replace(replaceRange, 'doc("${1:description}")'),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "311"
        },
        {
          label: "arg",
          kind: node_12.CompletionItemKind.Keyword,
          detail: "Argument documentation",
          textEdit: node_12.TextEdit.replace(replaceRange, 'arg("${1:name}", "${2:description}")'),
          insertTextFormat: node_12.InsertTextFormat.Snippet,
          sortText: "312"
        }
      ];
    }
    function createPredicateSnippet(name, arity) {
      if (arity === 0) {
        return name;
      }
      const args = Array.from({ length: arity }, (_, i) => `\${${i + 1}:arg${i + 1}}`);
      return `${name}(${args.join(", ")})`;
    }
    function createFunctionSnippet(name, arity) {
      if (arity === 0) {
        return `${name}()`;
      }
      if (arity === -1) {
        return `${name}(\${1:args})`;
      }
      const args = Array.from({ length: arity }, (_, i) => `\${${i + 1}:arg${i + 1}}`);
      return `${name}(${args.join(", ")})`;
    }
    function resolveCompletion(item) {
      return item;
    }
  }
});

// server/services/definition.js
var require_definition = __commonJS({
  "server/services/definition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefinition = getDefinition;
    function getDefinition(uri, symbolTable, position) {
      const line = position.line + 1;
      const column = position.character;
      const predInfo = symbolTable.findPredicateAt(line, column);
      if (predInfo) {
        const locations = [];
        if (predInfo.declLocation) {
          const range = predInfo.declNameRange || predInfo.declLocation;
          locations.push(createLocation(uri, range));
        }
        const defs = predInfo.definitionNameRanges || predInfo.definitions;
        for (const def of defs) {
          locations.push(createLocation(uri, def));
        }
        if (locations.length === 0)
          return null;
        if (locations.length === 1)
          return locations[0];
        return locations;
      }
      const varInfo = symbolTable.findVariableAt(line, column);
      if (varInfo) {
        return createLocation(uri, varInfo.bindingLocation);
      }
      return null;
    }
    function createLocation(uri, range) {
      return {
        uri,
        range: {
          start: { line: range.start.line - 1, character: range.start.column },
          end: { line: range.end.line - 1, character: range.end.column }
        }
      };
    }
  }
});

// server/services/references.js
var require_references = __commonJS({
  "server/services/references.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findReferences = findReferences;
    function findReferences(uri, symbolTable, position, context) {
      const line = position.line + 1;
      const column = position.character;
      const varInfo = symbolTable.findVariableAt(line, column);
      if (varInfo) {
        const locations = [];
        for (const occ of varInfo.occurrences) {
          locations.push(createLocation(uri, occ));
        }
        if (!context.includeDeclaration) {
          return locations.filter((loc) => !(loc.range.start.line === varInfo.bindingLocation.start.line - 1 && loc.range.start.character === varInfo.bindingLocation.start.column));
        }
        return locations;
      }
      const predInfo = symbolTable.findPredicateAt(line, column);
      if (predInfo) {
        const locations = [];
        if (context.includeDeclaration && predInfo.declLocation) {
          const range = predInfo.declNameRange || predInfo.declLocation;
          locations.push(createLocation(uri, range));
        }
        const defs = predInfo.definitionNameRanges || predInfo.definitions;
        for (const def of defs) {
          locations.push(createLocation(uri, def));
        }
        const refs = predInfo.referenceNameRanges || predInfo.references;
        for (const ref of refs) {
          locations.push(createLocation(uri, ref));
        }
        return locations;
      }
      return [];
    }
    function createLocation(uri, range) {
      return {
        uri,
        range: {
          start: { line: range.start.line - 1, character: range.start.column },
          end: { line: range.end.line - 1, character: range.end.column }
        }
      };
    }
  }
});

// server/services/symbols.js
var require_symbols2 = __commonJS({
  "server/services/symbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDocumentSymbols = getDocumentSymbols;
    var node_12 = require_node3();
    function getDocumentSymbols(unit) {
      const symbols = [];
      const predicateGroups = /* @__PURE__ */ new Map();
      for (const clause of unit.clauses) {
        const key = `${clause.head.predicate.symbol}/${clause.head.predicate.arity}`;
        const group = predicateGroups.get(key);
        if (group) {
          group.push(clause);
        } else {
          predicateGroups.set(key, [clause]);
        }
      }
      if (unit.packageDecl) {
        symbols.push({
          name: `Package: ${unit.packageDecl.name}`,
          kind: node_12.SymbolKind.Package,
          range: convertRange(unit.packageDecl.range),
          selectionRange: convertRange(unit.packageDecl.range)
        });
      }
      for (const useDecl of unit.useDecls) {
        symbols.push({
          name: `Use: ${useDecl.name}`,
          kind: node_12.SymbolKind.Module,
          range: convertRange(useDecl.range),
          selectionRange: convertRange(useDecl.range),
          detail: "import"
        });
      }
      if (unit.decls.length > 0) {
        const declSymbols = unit.decls.map((decl) => createDeclSymbol(decl));
        const declsRange = combineRanges(unit.decls.map((d) => d.range));
        symbols.push({
          name: "Declarations",
          kind: node_12.SymbolKind.Namespace,
          range: convertRange(declsRange),
          selectionRange: convertRange(declsRange),
          children: declSymbols
        });
      }
      for (const [key, clauses] of predicateGroups) {
        const firstClause = clauses[0];
        if (!firstClause)
          continue;
        const clauseSymbols = clauses.map((clause, index) => createClauseSymbol(clause, index));
        const groupRange = combineRanges(clauses.map((c) => c.range));
        symbols.push({
          name: key,
          kind: node_12.SymbolKind.Function,
          range: convertRange(groupRange),
          selectionRange: convertRange(firstClause.head.range),
          detail: `${clauses.length} clause(s)`,
          children: clauseSymbols.length > 0 ? clauseSymbols : void 0
        });
      }
      return symbols;
    }
    function createDeclSymbol(decl) {
      const name = decl.declaredAtom.predicate.symbol;
      const arity = decl.declaredAtom.predicate.arity;
      return {
        name: `${name}/${arity}`,
        kind: node_12.SymbolKind.Class,
        range: convertRange(decl.range),
        selectionRange: convertRange(decl.declaredAtom.range),
        detail: "Declaration"
      };
    }
    function createClauseSymbol(clause, index) {
      const name = clause.head.predicate.symbol;
      const isFact = !clause.premises || clause.premises.length === 0;
      const detail = isFact ? "fact" : `rule (${clause.premises?.length || 0} premises)`;
      const clauseSymbol = {
        name: `${name} [${index + 1}]`,
        kind: isFact ? node_12.SymbolKind.Field : node_12.SymbolKind.Function,
        range: convertRange(clause.range),
        selectionRange: convertRange(clause.head.range),
        detail
      };
      if (clause.transform) {
        const transformSymbol = {
          name: "transform",
          kind: node_12.SymbolKind.Operator,
          range: convertRange(clause.transform.range),
          selectionRange: convertRange(clause.transform.range),
          detail: "aggregation"
        };
        clauseSymbol.children = [transformSymbol];
      }
      return clauseSymbol;
    }
    function convertRange(range) {
      return {
        start: { line: range.start.line - 1, character: range.start.column },
        end: { line: range.end.line - 1, character: range.end.column }
      };
    }
    function combineRanges(ranges) {
      if (ranges.length === 0) {
        return { start: { line: 1, column: 0, offset: 0 }, end: { line: 1, column: 0, offset: 0 } };
      }
      let minLine = Infinity, minCol = Infinity, minOffset = Infinity;
      let maxLine = 0, maxCol = 0, maxOffset = 0;
      for (const range of ranges) {
        if (range.start.line < minLine || range.start.line === minLine && range.start.column < minCol) {
          minLine = range.start.line;
          minCol = range.start.column;
          minOffset = range.start.offset;
        }
        if (range.end.line > maxLine || range.end.line === maxLine && range.end.column > maxCol) {
          maxLine = range.end.line;
          maxCol = range.end.column;
          maxOffset = range.end.offset;
        }
      }
      return {
        start: { line: minLine, column: minCol, offset: minOffset },
        end: { line: maxLine, column: maxCol, offset: maxOffset }
      };
    }
  }
});

// server/services/formatting.js
var require_formatting = __commonJS({
  "server/services/formatting.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatDocument = formatDocument;
    var ast_1 = require_ast();
    function extractComments(text) {
      const comments = /* @__PURE__ */ new Map();
      const lines = text.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line === void 0)
          continue;
        const commentIndex = line.indexOf("#");
        if (commentIndex !== -1) {
          const beforeHash = line.substring(0, commentIndex);
          const quoteCount = (beforeHash.match(/"/g) || []).length;
          if (quoteCount % 2 === 0) {
            comments.set(i + 1, line.substring(commentIndex));
          }
        }
      }
      return comments;
    }
    function insertComments(formatted, comments) {
      if (comments.size === 0) {
        return formatted;
      }
      const formattedLines = formatted.split("\n");
      const result = [];
      const usedComments = /* @__PURE__ */ new Set();
      for (let i = 0; i < formattedLines.length; i++) {
        const line = formattedLines[i];
        if (line !== void 0) {
          result.push(line);
        }
      }
      const sortedCommentLines = Array.from(comments.keys()).sort((a, b) => a - b);
      const standaloneComments = [];
      for (const lineNum of sortedCommentLines) {
        if (!usedComments.has(lineNum)) {
          const comment = comments.get(lineNum);
          if (comment) {
            standaloneComments.push(comment);
          }
        }
      }
      if (standaloneComments.length > 0) {
        const lastNonEmpty = result.length - 1;
        for (const comment of standaloneComments) {
          result.splice(lastNonEmpty, 0, comment);
        }
      }
      return result.join("\n");
    }
    function formatDocument(document, unit, options) {
      const originalText = document.getText();
      const comments = extractComments(originalText);
      let formatted = formatSourceUnit(unit, options);
      formatted = insertComments(formatted, comments);
      return [{
        range: {
          start: { line: 0, character: 0 },
          end: { line: document.lineCount, character: 0 }
        },
        newText: formatted
      }];
    }
    function formatSourceUnit(unit, options) {
      const lines = [];
      const indent = options.insertSpaces ? " ".repeat(options.tabSize) : "	";
      if (unit.packageDecl) {
        lines.push(`Package ${unit.packageDecl.name}.`);
        lines.push("");
      }
      for (const useDecl of unit.useDecls) {
        lines.push(`Use ${useDecl.name}.`);
      }
      if (unit.useDecls.length > 0) {
        lines.push("");
      }
      for (const decl of unit.decls) {
        lines.push(formatDecl(decl, indent));
      }
      if (unit.decls.length > 0) {
        lines.push("");
      }
      const predicateGroups = /* @__PURE__ */ new Map();
      for (const clause of unit.clauses) {
        const key = clause.head.predicate.symbol;
        const group = predicateGroups.get(key);
        if (group) {
          group.push(clause);
        } else {
          predicateGroups.set(key, [clause]);
        }
      }
      let isFirst = true;
      for (const [, clauses] of predicateGroups) {
        if (!isFirst) {
          lines.push("");
        }
        isFirst = false;
        for (const clause of clauses) {
          lines.push(formatClause(clause, indent));
        }
      }
      return lines.join("\n") + "\n";
    }
    function formatDecl(decl, indent) {
      const atom = formatAtom(decl.declaredAtom);
      let result = `Decl ${atom}`;
      if (decl.descr && decl.descr.length > 0) {
        const descrParts = decl.descr.map((a) => formatAtom(a));
        result += `
${indent}descr [`;
        for (let i = 0; i < descrParts.length; i++) {
          result += `
${indent}    ${descrParts[i]}${i < descrParts.length - 1 ? "," : ""}`;
        }
        result += `
${indent}]`;
      }
      if (decl.bounds && decl.bounds.length > 0) {
        for (const boundDecl of decl.bounds) {
          const boundsStr = boundDecl.bounds.map(formatTerm).join(", ");
          result += `
${indent}bound [${boundsStr}]`;
        }
      }
      result += ".";
      return result;
    }
    function formatClause(clause, indent) {
      let head = formatAtom(clause.head);
      if (clause.headTime && !(0, ast_1.isEternalInterval)(clause.headTime)) {
        head += (0, ast_1.temporalIntervalToString)(clause.headTime);
      }
      if (!clause.premises || clause.premises.length === 0) {
        if (clause.transform) {
          return `${head} |> ${formatTransform(clause.transform, indent)}.`;
        }
        return `${head}.`;
      }
      const premises = clause.premises.map(formatTerm);
      const singleLine = `${head} :- ${premises.join(", ")}`;
      if (singleLine.length <= 80 && !clause.transform) {
        return `${singleLine}.`;
      }
      let result = `${head} :-
`;
      for (let i = 0; i < premises.length; i++) {
        const isLast = i === premises.length - 1;
        result += `${indent}${premises[i]}${isLast ? "" : ","}
`;
      }
      if (clause.transform) {
        result += `${indent}|> ${formatTransform(clause.transform, indent)}`;
      }
      result = result.trimEnd() + ".";
      return result;
    }
    function formatAtom(atom) {
      const pred = atom.predicate.symbol;
      if (atom.args.length === 0) {
        return `${pred}()`;
      }
      const args = atom.args.map(formatTerm).join(", ");
      return `${pred}(${args})`;
    }
    function formatTerm(term) {
      switch (term.type) {
        case "Variable":
          return term.symbol;
        case "Constant": {
          const c = term;
          switch (c.constantType) {
            case "name":
              return c.symbol ?? "";
            case "string":
              return `"${escapeString(c.symbol ?? "")}"`;
            case "bytes":
              return `b"${escapeString(c.symbol ?? "")}"`;
            case "number":
              return (c.numValue ?? 0).toString();
            case "float64":
              return (c.floatValue ?? 0).toString();
            case "list": {
              if (!c.fst) {
                return "[]";
              }
              const elements = [];
              let current = c;
              while (current && current.fst) {
                elements.push(formatTerm(current.fst));
                current = current.snd;
              }
              return `[${elements.join(", ")}]`;
            }
            case "map":
            case "struct": {
              if (!c.fst) {
                return c.constantType === "map" ? "[]" : "{}";
              }
              return c.constantType === "map" ? "[...]" : "{...}";
            }
            case "pair": {
              const fstStr = c.fst ? formatTerm(c.fst) : "";
              const sndStr = c.snd ? formatTerm(c.snd) : "";
              return `fn:pair(${fstStr}, ${sndStr})`;
            }
            case "time": {
              if (c.numValue !== void 0) {
                const ms = c.numValue / 1e6;
                const iso = new Date(ms).toISOString();
                return `fn:time:parse_rfc3339("${iso}")`;
              }
              return 'fn:time:parse_rfc3339("?")';
            }
            case "duration": {
              if (c.symbol)
                return `fn:duration:parse("${c.symbol}")`;
              if (c.numValue !== void 0)
                return `fn:duration:parse("${c.numValue}ns")`;
              return 'fn:duration:parse("?")';
            }
            default:
              return c.symbol ?? "";
          }
        }
        case "ApplyFn": {
          const fn = term;
          if (fn.function.symbol === "fn:list") {
            const elements = fn.args.map(formatTerm).join(", ");
            return `[${elements}]`;
          }
          if (fn.function.symbol === "fn:map") {
            const pairs = [];
            for (let i = 0; i < fn.args.length; i += 2) {
              const key = fn.args[i];
              const value = fn.args[i + 1];
              if (key && value) {
                pairs.push(`${formatTerm(key)}: ${formatTerm(value)}`);
              }
            }
            return `[${pairs.join(", ")}]`;
          }
          if (fn.function.symbol === "fn:struct") {
            const pairs = [];
            for (let i = 0; i < fn.args.length; i += 2) {
              const key = fn.args[i];
              const value = fn.args[i + 1];
              if (key && value) {
                pairs.push(`${formatTerm(key)}: ${formatTerm(value)}`);
              }
            }
            return `{${pairs.join(", ")}}`;
          }
          const fnName = fn.function.symbol;
          const args = fn.args.map(formatTerm).join(", ");
          return `${fnName}(${args})`;
        }
        case "Atom": {
          const atom = term;
          if ((0, ast_1.isLtAtom)(atom) && atom.args.length === 2) {
            const left = atom.args[0];
            const right = atom.args[1];
            if (left && right) {
              return `${formatTerm(left)} < ${formatTerm(right)}`;
            }
          }
          if ((0, ast_1.isLeAtom)(atom) && atom.args.length === 2) {
            const left = atom.args[0];
            const right = atom.args[1];
            if (left && right) {
              return `${formatTerm(left)} <= ${formatTerm(right)}`;
            }
          }
          if ((0, ast_1.isGtAtom)(atom) && atom.args.length === 2) {
            const left = atom.args[0];
            const right = atom.args[1];
            if (left && right) {
              return `${formatTerm(left)} > ${formatTerm(right)}`;
            }
          }
          if ((0, ast_1.isGeAtom)(atom) && atom.args.length === 2) {
            const left = atom.args[0];
            const right = atom.args[1];
            if (left && right) {
              return `${formatTerm(left)} >= ${formatTerm(right)}`;
            }
          }
          return formatAtom(atom);
        }
        case "NegAtom": {
          const neg = term;
          return `!${formatAtom(neg.atom)}`;
        }
        case "TemporalLiteral": {
          const tl = term;
          let result = "";
          if (tl.operator) {
            result += (0, ast_1.temporalOperatorToString)(tl.operator) + " ";
          }
          if (tl.literal.type === "NegAtom") {
            result += `!${formatAtom(tl.literal.atom)}`;
          } else {
            result += formatAtom(tl.literal);
          }
          if (tl.interval && !(0, ast_1.isEternalInterval)(tl.interval)) {
            result += (0, ast_1.temporalIntervalToString)(tl.interval);
          }
          return result;
        }
        case "TemporalAtom": {
          const ta = term;
          let result = formatAtom(ta.atom);
          if (ta.interval && !(0, ast_1.isEternalInterval)(ta.interval)) {
            result += (0, ast_1.temporalIntervalToString)(ta.interval);
          }
          return result;
        }
        case "Eq": {
          const eq = term;
          return `${formatTerm(eq.left)} = ${formatTerm(eq.right)}`;
        }
        case "Ineq": {
          const ineq = term;
          return `${formatTerm(ineq.left)} != ${formatTerm(ineq.right)}`;
        }
        case "Lt": {
          const lt = term;
          return `${formatTerm(lt.left)} < ${formatTerm(lt.right)}`;
        }
        case "Le": {
          const le = term;
          return `${formatTerm(le.left)} <= ${formatTerm(le.right)}`;
        }
        case "Gt": {
          const gt = term;
          return `${formatTerm(gt.left)} > ${formatTerm(gt.right)}`;
        }
        case "Ge": {
          const ge = term;
          return `${formatTerm(ge.left)} >= ${formatTerm(ge.right)}`;
        }
        default:
          return "";
      }
    }
    function formatTransform(transform, indent) {
      const parts = [];
      let current = transform;
      while (current) {
        for (const stmt of current.statements) {
          parts.push(formatTransformStmt(stmt));
        }
        current = current.next;
      }
      return parts.join(", ");
    }
    function formatTransformStmt(stmt) {
      const fn = formatApplyFn(stmt.fn);
      if (stmt.variable === null) {
        return `do ${fn}`;
      }
      return `let ${stmt.variable.symbol} = ${fn}`;
    }
    function formatApplyFn(fn) {
      const fnName = fn.function.symbol;
      const args = fn.args.map(formatTerm).join(", ");
      return `${fnName}(${args})`;
    }
    function escapeString(s) {
      return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
    }
  }
});

// server/services/rename.js
var require_rename = __commonJS({
  "server/services/rename.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareRename = prepareRename;
    exports2.doRename = doRename;
    var position_1 = require_position();
    function prepareRename(unit, symbolTable, position) {
      const line = position.line + 1;
      const column = position.character;
      const varInfo = symbolTable.findVariableAt(line, column);
      if (varInfo) {
        if (varInfo.name === "_") {
          return null;
        }
        for (const occ of varInfo.occurrences) {
          if ((0, position_1.isWithinSourceRange)(line, column, occ)) {
            return convertRange(occ);
          }
        }
      }
      const predInfo = symbolTable.findPredicateAt(line, column);
      if (predInfo) {
        if (predInfo.symbol.symbol.startsWith(":")) {
          return null;
        }
        if (predInfo.declNameRange && (0, position_1.isWithinSourceRange)(line, column, predInfo.declNameRange)) {
          return convertRange(predInfo.declNameRange);
        }
        for (const nameRange of predInfo.definitionNameRanges) {
          if ((0, position_1.isWithinSourceRange)(line, column, nameRange)) {
            return convertRange(nameRange);
          }
        }
        for (const nameRange of predInfo.referenceNameRanges) {
          if ((0, position_1.isWithinSourceRange)(line, column, nameRange)) {
            return convertRange(nameRange);
          }
        }
      }
      return null;
    }
    function isValidPredicateName(name) {
      if (name.length === 0) {
        return false;
      }
      if (name.startsWith(":")) {
        return true;
      }
      const firstChar = name.charAt(0);
      return firstChar >= "a" && firstChar <= "z";
    }
    function doRename(uri, unit, symbolTable, position, newName) {
      const line = position.line + 1;
      const column = position.character;
      const edits = [];
      const varInfo = symbolTable.findVariableAt(line, column);
      if (varInfo) {
        if (varInfo.name === "_") {
          return null;
        }
        if (!/^[A-Z_][A-Za-z0-9_]*$/.test(newName)) {
          return null;
        }
        for (const occ of varInfo.occurrences) {
          edits.push({
            range: convertRange(occ),
            newText: newName
          });
        }
        return {
          changes: {
            [uri]: edits
          }
        };
      }
      const predInfo = symbolTable.findPredicateAt(line, column);
      if (predInfo) {
        if (predInfo.symbol.symbol.startsWith(":")) {
          return null;
        }
        let isOnPredicateName = false;
        if (predInfo.declNameRange && (0, position_1.isWithinSourceRange)(line, column, predInfo.declNameRange)) {
          isOnPredicateName = true;
        }
        for (const nameRange of predInfo.definitionNameRanges) {
          if ((0, position_1.isWithinSourceRange)(line, column, nameRange)) {
            isOnPredicateName = true;
            break;
          }
        }
        if (!isOnPredicateName) {
          for (const nameRange of predInfo.referenceNameRanges) {
            if ((0, position_1.isWithinSourceRange)(line, column, nameRange)) {
              isOnPredicateName = true;
              break;
            }
          }
        }
        if (!isOnPredicateName) {
          return null;
        }
        if (!isValidPredicateName(newName)) {
          return null;
        }
        if (predInfo.declNameRange) {
          edits.push({
            range: convertRange(predInfo.declNameRange),
            newText: newName
          });
        }
        for (const nameRange of predInfo.definitionNameRanges) {
          edits.push({
            range: convertRange(nameRange),
            newText: newName
          });
        }
        for (const nameRange of predInfo.referenceNameRanges) {
          edits.push({
            range: convertRange(nameRange),
            newText: newName
          });
        }
        return {
          changes: {
            [uri]: edits
          }
        };
      }
      return null;
    }
    function convertRange(range) {
      return {
        start: { line: range.start.line - 1, character: range.start.column },
        end: { line: range.end.line - 1, character: range.end.column }
      };
    }
  }
});

// server/services/index.js
var require_services = __commonJS({
  "server/services/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.doRename = exports2.prepareRename = exports2.formatDocument = exports2.getDocumentSymbols = exports2.findReferences = exports2.getDefinition = exports2.resolveCompletion = exports2.getCompletions = exports2.getHover = void 0;
    var hover_1 = require_hover();
    Object.defineProperty(exports2, "getHover", { enumerable: true, get: function() {
      return hover_1.getHover;
    } });
    var completion_1 = require_completion();
    Object.defineProperty(exports2, "getCompletions", { enumerable: true, get: function() {
      return completion_1.getCompletions;
    } });
    Object.defineProperty(exports2, "resolveCompletion", { enumerable: true, get: function() {
      return completion_1.resolveCompletion;
    } });
    var definition_1 = require_definition();
    Object.defineProperty(exports2, "getDefinition", { enumerable: true, get: function() {
      return definition_1.getDefinition;
    } });
    var references_1 = require_references();
    Object.defineProperty(exports2, "findReferences", { enumerable: true, get: function() {
      return references_1.findReferences;
    } });
    var symbols_12 = require_symbols2();
    Object.defineProperty(exports2, "getDocumentSymbols", { enumerable: true, get: function() {
      return symbols_12.getDocumentSymbols;
    } });
    var formatting_1 = require_formatting();
    Object.defineProperty(exports2, "formatDocument", { enumerable: true, get: function() {
      return formatting_1.formatDocument;
    } });
    var rename_1 = require_rename();
    Object.defineProperty(exports2, "prepareRename", { enumerable: true, get: function() {
      return rename_1.prepareRename;
    } });
    Object.defineProperty(exports2, "doRename", { enumerable: true, get: function() {
      return rename_1.doRename;
    } });
  }
});

// server/server.js
Object.defineProperty(exports, "__esModule", { value: true });
exports.startServer = startServer;
var node_1 = require_node3();
var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
var index_1 = require_parser2();
var index_2 = require_analysis();
var symbols_1 = require_symbols();
var index_3 = require_services();
var connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all);
var documents = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
var documentStates = /* @__PURE__ */ new Map();
var validationTimeouts = /* @__PURE__ */ new Map();
var defaultSettings = {
  maxNumberOfProblems: 100,
  enableSemanticAnalysis: true
};
var globalSettings = defaultSettings;
var documentSettings = /* @__PURE__ */ new Map();
var hasConfigurationCapability = false;
var hasWorkspaceFolderCapability = false;
connection.onInitialize((params) => {
  const capabilities = params.capabilities;
  hasConfigurationCapability = !!(capabilities.workspace && !!capabilities.workspace.configuration);
  hasWorkspaceFolderCapability = !!(capabilities.workspace && !!capabilities.workspace.workspaceFolders);
  const result = {
    capabilities: {
      textDocumentSync: node_1.TextDocumentSyncKind.Incremental,
      // Completion support
      completionProvider: {
        resolveProvider: true,
        triggerCharacters: [":", "(", ",", "|", "/", "."]
      },
      // Hover support
      hoverProvider: true,
      // Go to definition
      definitionProvider: true,
      // Find references
      referencesProvider: true,
      // Document symbols (outline)
      documentSymbolProvider: true,
      // Document formatting
      documentFormattingProvider: true,
      // Rename
      renameProvider: {
        prepareProvider: true
      }
    }
  };
  if (hasWorkspaceFolderCapability) {
    result.capabilities.workspace = {
      workspaceFolders: {
        supported: true
      }
    };
  }
  return result;
});
connection.onInitialized(() => {
  if (hasConfigurationCapability) {
    connection.client.register(node_1.DidChangeConfigurationNotification.type, void 0);
  }
  if (hasWorkspaceFolderCapability) {
    connection.workspace.onDidChangeWorkspaceFolders((_event) => {
      connection.console.log("Workspace folder change event received.");
    });
  }
  connection.console.log("Mangle LSP server initialized.");
});
connection.onDidChangeConfiguration((change) => {
  if (hasConfigurationCapability) {
    documentSettings.clear();
  } else {
    globalSettings = change.settings.mangle || defaultSettings;
  }
  documents.all().forEach(validateDocument);
});
function getDocumentSettings(uri) {
  if (!hasConfigurationCapability) {
    return Promise.resolve(globalSettings);
  }
  let result = documentSettings.get(uri);
  if (!result) {
    result = connection.workspace.getConfiguration({
      scopeUri: uri,
      section: "mangle"
    });
    documentSettings.set(uri, result);
  }
  return result;
}
documents.onDidOpen((event) => {
  validateDocument(event.document);
});
documents.onDidChangeContent((change) => {
  scheduleValidation(change.document);
});
function scheduleValidation(document) {
  const uri = document.uri;
  const existing = validationTimeouts.get(uri);
  if (existing) {
    clearTimeout(existing);
  }
  const timeout = setTimeout(() => {
    validationTimeouts.delete(uri);
    validateDocument(document);
  }, 200);
  validationTimeouts.set(uri, timeout);
}
documents.onDidClose((event) => {
  const uri = event.document.uri;
  const timeout = validationTimeouts.get(uri);
  if (timeout) {
    clearTimeout(timeout);
    validationTimeouts.delete(uri);
  }
  documentSettings.delete(uri);
  documentStates.delete(uri);
  connection.sendDiagnostics({ uri, diagnostics: [] });
});
async function validateDocument(document) {
  const settings = await getDocumentSettings(document.uri);
  const text = document.getText();
  const parseResult = (0, index_1.parse)(text);
  let validationResult = null;
  if (parseResult.unit && settings.enableSemanticAnalysis) {
    validationResult = (0, index_2.validate)(parseResult.unit);
  }
  documentStates.set(document.uri, {
    uri: document.uri,
    version: document.version,
    parseResult,
    validationResult
  });
  const diagnostics = [];
  for (const error of parseResult.errors) {
    if (diagnostics.length >= settings.maxNumberOfProblems) {
      break;
    }
    diagnostics.push(parseErrorToDiagnostic(error));
  }
  if (validationResult) {
    for (const error of validationResult.errors) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(semanticErrorToDiagnostic(error));
    }
  }
  if (parseResult.unit && settings.enableSemanticAnalysis) {
    const stratErrors = (0, index_2.checkStratification)(parseResult.unit);
    for (const error of stratErrors) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(stratificationErrorToDiagnostic(error));
    }
    const recursionWarnings = (0, index_2.checkUnboundedRecursion)(parseResult.unit);
    for (const warning of recursionWarnings) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(stratificationErrorToDiagnostic(warning));
    }
    const cartesianWarnings = (0, index_2.checkCartesianExplosion)(parseResult.unit);
    for (const warning of cartesianWarnings) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(stratificationErrorToDiagnostic(warning));
    }
    const lateFilterWarnings = (0, index_2.checkLateFiltering)(parseResult.unit);
    for (const warning of lateFilterWarnings) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(stratificationErrorToDiagnostic(warning));
    }
    const lateNegationWarnings = (0, index_2.checkLateNegation)(parseResult.unit);
    for (const warning of lateNegationWarnings) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(stratificationErrorToDiagnostic(warning));
    }
    const multiIndepWarnings = (0, index_2.checkMultipleIndependentVars)(parseResult.unit);
    for (const warning of multiIndepWarnings) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(stratificationErrorToDiagnostic(warning));
    }
    const temporalWarnings = (0, index_2.checkTemporalRecursion)(parseResult.unit);
    for (const warning of temporalWarnings) {
      if (diagnostics.length >= settings.maxNumberOfProblems) {
        break;
      }
      diagnostics.push(stratificationErrorToDiagnostic(warning));
    }
  }
  connection.sendDiagnostics({ uri: document.uri, diagnostics });
}
function parseErrorToDiagnostic(error) {
  return {
    severity: node_1.DiagnosticSeverity.Error,
    range: {
      start: { line: error.line - 1, character: error.column },
      end: { line: error.line - 1, character: error.column + error.length }
    },
    message: error.message,
    source: error.source === "lexer" ? "mangle-lexer" : "mangle-parse"
  };
}
function semanticErrorToDiagnostic(error) {
  let severity;
  switch (error.severity) {
    case "error":
      severity = node_1.DiagnosticSeverity.Error;
      break;
    case "warning":
      severity = node_1.DiagnosticSeverity.Warning;
      break;
    case "info":
      severity = node_1.DiagnosticSeverity.Information;
      break;
    default:
      severity = node_1.DiagnosticSeverity.Error;
  }
  return {
    severity,
    range: {
      start: { line: error.range.start.line - 1, character: error.range.start.column },
      end: { line: error.range.end.line - 1, character: error.range.end.column }
    },
    message: error.message,
    source: "mangle-semantic",
    code: error.code
  };
}
function stratificationErrorToDiagnostic(error) {
  let severity;
  switch (error.severity) {
    case "error":
      severity = node_1.DiagnosticSeverity.Error;
      break;
    case "warning":
      severity = node_1.DiagnosticSeverity.Warning;
      break;
    default:
      severity = node_1.DiagnosticSeverity.Error;
  }
  return {
    severity,
    range: {
      start: { line: error.range.start.line - 1, character: error.range.start.column },
      end: { line: error.range.end.line - 1, character: error.range.end.column }
    },
    message: error.message,
    source: "mangle-stratification",
    code: error.code
  };
}
function getSymbolTable(state) {
  if (state.validationResult) {
    return state.validationResult.symbolTable;
  }
  if (state.parseResult.unit) {
    return (0, symbols_1.buildSymbolTable)(state.parseResult.unit);
  }
  return null;
}
connection.onHover((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    if (!state || !state.parseResult.unit) {
      return null;
    }
    const symbolTable = getSymbolTable(state);
    if (!symbolTable) {
      return null;
    }
    return (0, index_3.getHover)(state.parseResult.unit, symbolTable, params.position);
  } catch (e) {
    connection.console.error(`Hover error: ${e}`);
    return null;
  }
});
connection.onCompletion((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    const document = documents.get(params.textDocument.uri);
    if (!document) {
      return [];
    }
    const symbolTable = state ? getSymbolTable(state) : null;
    const unit = state?.parseResult.unit || null;
    return (0, index_3.getCompletions)(document, unit, symbolTable, params.position);
  } catch (e) {
    connection.console.error(`Completion error: ${e}`);
    return [];
  }
});
connection.onCompletionResolve((item) => {
  try {
    return (0, index_3.resolveCompletion)(item);
  } catch (e) {
    connection.console.error(`Completion resolve error: ${e}`);
    return item;
  }
});
connection.onDefinition((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    if (!state || !state.parseResult.unit) {
      return null;
    }
    const symbolTable = getSymbolTable(state);
    if (!symbolTable) {
      return null;
    }
    return (0, index_3.getDefinition)(params.textDocument.uri, symbolTable, params.position);
  } catch (e) {
    connection.console.error(`Definition error: ${e}`);
    return null;
  }
});
connection.onReferences((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    if (!state || !state.parseResult.unit) {
      return [];
    }
    const symbolTable = getSymbolTable(state);
    if (!symbolTable) {
      return [];
    }
    return (0, index_3.findReferences)(params.textDocument.uri, symbolTable, params.position, params.context);
  } catch (e) {
    connection.console.error(`References error: ${e}`);
    return [];
  }
});
connection.onDocumentSymbol((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    if (!state || !state.parseResult.unit) {
      return [];
    }
    return (0, index_3.getDocumentSymbols)(state.parseResult.unit);
  } catch (e) {
    connection.console.error(`Document symbols error: ${e}`);
    return [];
  }
});
connection.onDocumentFormatting((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    const document = documents.get(params.textDocument.uri);
    if (!state || !state.parseResult.unit || !document) {
      return [];
    }
    return (0, index_3.formatDocument)(document, state.parseResult.unit, params.options);
  } catch (e) {
    connection.console.error(`Formatting error: ${e}`);
    return [];
  }
});
connection.onPrepareRename((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    if (!state || !state.parseResult.unit) {
      return null;
    }
    const symbolTable = getSymbolTable(state);
    if (!symbolTable) {
      return null;
    }
    return (0, index_3.prepareRename)(state.parseResult.unit, symbolTable, params.position);
  } catch (e) {
    connection.console.error(`Prepare rename error: ${e}`);
    return null;
  }
});
connection.onRenameRequest((params) => {
  try {
    const state = documentStates.get(params.textDocument.uri);
    if (!state || !state.parseResult.unit) {
      return null;
    }
    const symbolTable = getSymbolTable(state);
    if (!symbolTable) {
      return null;
    }
    return (0, index_3.doRename)(params.textDocument.uri, state.parseResult.unit, symbolTable, params.position, params.newName);
  } catch (e) {
    connection.console.error(`Rename error: ${e}`);
    return null;
  }
});
connection.onRequest("mangle/getDiagnostics", (params) => {
  try {
    const state = documentStates.get(params.uri);
    if (!state) {
      return {
        uri: params.uri,
        parseErrors: [],
        semanticErrors: [],
        stratificationErrors: []
      };
    }
    const parseErrors = state.parseResult.errors.map((e) => ({
      code: "P001",
      source: e.source === "lexer" ? "mangle-lexer" : "mangle-parse",
      message: e.message,
      range: {
        start: { line: e.line, column: e.column },
        end: { line: e.line, column: e.column + e.length }
      }
    }));
    const semanticErrors = state.validationResult?.errors.map((e) => ({
      code: e.code,
      source: "mangle-semantic",
      severity: e.severity,
      message: e.message,
      range: {
        start: { line: e.range.start.line, column: e.range.start.column },
        end: { line: e.range.end.line, column: e.range.end.column }
      }
    })) || [];
    let stratificationErrors = [];
    if (state.parseResult.unit) {
      const stratErrors = (0, index_2.checkStratification)(state.parseResult.unit);
      stratificationErrors = stratErrors.map((e) => ({
        code: e.code,
        source: "mangle-stratification",
        severity: e.severity,
        message: e.message,
        range: {
          start: { line: e.range.start.line, column: e.range.start.column },
          end: { line: e.range.end.line, column: e.range.end.column }
        },
        cycle: e.cycle
      }));
    }
    return {
      uri: params.uri,
      parseErrors,
      semanticErrors,
      stratificationErrors
    };
  } catch (e) {
    connection.console.error(`mangle/getDiagnostics error: ${e}`);
    return {
      uri: params.uri,
      parseErrors: [],
      semanticErrors: [],
      stratificationErrors: [],
      error: String(e)
    };
  }
});
connection.onRequest("mangle/checkFiles", async (params) => {
  const results = [];
  for (const uri of params.uris) {
    const state = documentStates.get(uri);
    if (state) {
      const diagnostics = await connection.sendRequest("mangle/getDiagnostics", { uri });
      results.push({ uri, ...diagnostics });
    }
  }
  return { files: results };
});
connection.onRequest("mangle/getStructuredSymbols", (params) => {
  try {
    const state = documentStates.get(params.uri);
    if (!state || !state.parseResult.unit) {
      return {
        uri: params.uri,
        predicates: [],
        declarations: [],
        clauses: []
      };
    }
    const symbolTable = getSymbolTable(state);
    if (!symbolTable) {
      return {
        uri: params.uri,
        predicates: [],
        declarations: [],
        clauses: []
      };
    }
    const predicates = symbolTable.getAllPredicates().map((info) => ({
      name: info.symbol.symbol,
      arity: info.symbol.arity,
      isExternal: info.isExternal,
      isPrivate: info.isPrivate,
      declLocation: info.declLocation ? {
        start: { line: info.declLocation.start.line, column: info.declLocation.start.column },
        end: { line: info.declLocation.end.line, column: info.declLocation.end.column }
      } : null,
      definitionCount: info.definitions.length,
      referenceCount: info.references.length
    }));
    const declarations = state.parseResult.unit.decls.map((d) => ({
      predicate: `${d.declaredAtom.predicate.symbol}/${d.declaredAtom.predicate.arity}`,
      range: {
        start: { line: d.range.start.line, column: d.range.start.column },
        end: { line: d.range.end.line, column: d.range.end.column }
      }
    }));
    const clauses = state.parseResult.unit.clauses.map((c) => ({
      head: `${c.head.predicate.symbol}/${c.head.predicate.arity}`,
      isFact: !c.premises || c.premises.length === 0,
      hasTransform: !!c.transform,
      range: {
        start: { line: c.head.range.start.line, column: c.head.range.start.column },
        end: { line: c.head.range.end.line, column: c.head.range.end.column }
      }
    }));
    return {
      uri: params.uri,
      predicates,
      declarations,
      clauses
    };
  } catch (e) {
    connection.console.error(`mangle/getStructuredSymbols error: ${e}`);
    return {
      uri: params.uri,
      predicates: [],
      declarations: [],
      clauses: [],
      error: String(e)
    };
  }
});
connection.onRequest("mangle/getAST", (params) => {
  try {
    const state = documentStates.get(params.uri);
    if (!state || !state.parseResult.unit) {
      return {
        uri: params.uri,
        ast: null,
        error: state ? "Parse errors present" : "Document not found"
      };
    }
    const unit = state.parseResult.unit;
    return {
      uri: params.uri,
      ast: {
        packageDecl: unit.packageDecl,
        useDecls: unit.useDecls,
        declCount: unit.decls.length,
        clauseCount: unit.clauses.length
      }
    };
  } catch (e) {
    connection.console.error(`mangle/getAST error: ${e}`);
    return {
      uri: params.uri,
      ast: null,
      error: String(e)
    };
  }
});
connection.onRequest("mangle/batchLookup", async (params) => {
  const results = [];
  for (const query of params.queries) {
    const result = {
      id: query.id,
      type: query.type,
      uri: query.uri,
      result: null
    };
    try {
      const state = documentStates.get(query.uri);
      const document = documents.get(query.uri);
      switch (query.type) {
        case "hover": {
          if (!state?.parseResult.unit || query.line === void 0 || query.column === void 0) {
            result.result = null;
            break;
          }
          const symbolTable = getSymbolTable(state);
          if (!symbolTable) {
            result.result = null;
            break;
          }
          const position = { line: query.line - 1, character: query.column };
          result.result = (0, index_3.getHover)(state.parseResult.unit, symbolTable, position);
          break;
        }
        case "definition": {
          if (!state?.parseResult.unit || query.line === void 0 || query.column === void 0) {
            result.result = { locations: [] };
            break;
          }
          const symbolTable = getSymbolTable(state);
          if (!symbolTable) {
            result.result = { locations: [] };
            break;
          }
          const position = { line: query.line - 1, character: query.column };
          const def = (0, index_3.getDefinition)(query.uri, symbolTable, position);
          result.result = { locations: def ? Array.isArray(def) ? def : [def] : [] };
          break;
        }
        case "references": {
          if (!state?.parseResult.unit || query.line === void 0 || query.column === void 0) {
            result.result = { locations: [] };
            break;
          }
          const symbolTable = getSymbolTable(state);
          if (!symbolTable) {
            result.result = { locations: [] };
            break;
          }
          const position = { line: query.line - 1, character: query.column };
          const refs = (0, index_3.findReferences)(query.uri, symbolTable, position, { includeDeclaration: query.includeDeclaration ?? true });
          result.result = { locations: refs };
          break;
        }
        case "completion": {
          if (!document || query.line === void 0 || query.column === void 0) {
            result.result = { items: [] };
            break;
          }
          const symbolTable = state ? getSymbolTable(state) : null;
          const unit = state?.parseResult.unit || null;
          const position = { line: query.line - 1, character: query.column };
          const items = (0, index_3.getCompletions)(document, unit, symbolTable, position);
          result.result = { items };
          break;
        }
        case "symbols": {
          if (!state?.parseResult.unit) {
            result.result = { symbols: [] };
            break;
          }
          const symbols = (0, index_3.getDocumentSymbols)(state.parseResult.unit);
          result.result = { symbols };
          break;
        }
        case "diagnostics": {
          const diagResult = await connection.sendRequest("mangle/getDiagnostics", { uri: query.uri });
          result.result = diagResult;
          break;
        }
        case "format": {
          if (!state?.parseResult.unit || !document) {
            result.result = { edits: [] };
            break;
          }
          const edits = (0, index_3.formatDocument)(document, state.parseResult.unit, { tabSize: 4, insertSpaces: true });
          result.result = { edits };
          break;
        }
        default:
          result.error = `Unknown query type: ${query.type}`;
      }
    } catch (e) {
      result.error = String(e);
    }
    results.push(result);
  }
  return { results };
});
connection.onRequest("mangle/getFileInfo", async (params) => {
  try {
    const state = documentStates.get(params.uri);
    const document = documents.get(params.uri);
    if (!state) {
      return {
        uri: params.uri,
        exists: false,
        error: "Document not found in cache"
      };
    }
    const diagResult = await connection.sendRequest("mangle/getDiagnostics", { uri: params.uri });
    const symbols = state.parseResult.unit ? (0, index_3.getDocumentSymbols)(state.parseResult.unit) : [];
    const symbolTable = getSymbolTable(state);
    const predicates = symbolTable ? symbolTable.getAllPredicates().map((info) => ({
      name: info.symbol.symbol,
      arity: info.symbol.arity,
      isExternal: info.isExternal,
      isPrivate: info.isPrivate,
      definitionCount: info.definitions.length,
      referenceCount: info.references.length
    })) : [];
    const ast = state.parseResult.unit ? {
      packageDecl: state.parseResult.unit.packageDecl,
      useDecls: state.parseResult.unit.useDecls,
      declCount: state.parseResult.unit.decls.length,
      clauseCount: state.parseResult.unit.clauses.length
    } : null;
    return {
      uri: params.uri,
      exists: true,
      version: state.version,
      hasSyntaxErrors: state.parseResult.errors.length > 0,
      hasSemanticErrors: (state.validationResult?.errors.length ?? 0) > 0,
      diagnostics: diagResult,
      symbols,
      predicates,
      ast,
      lineCount: document?.lineCount ?? 0
    };
  } catch (e) {
    return {
      uri: params.uri,
      exists: false,
      error: String(e)
    };
  }
});
connection.onRequest("mangle/checkAll", async () => {
  const files = [];
  let totalErrors = 0;
  let totalWarnings = 0;
  let totalInfo = 0;
  for (const [uri, state] of documentStates) {
    const diagResult = await connection.sendRequest("mangle/getDiagnostics", { uri });
    const fileResult = {
      uri,
      ...diagResult
    };
    files.push(fileResult);
    const parseErrors = diagResult.parseErrors?.length ?? 0;
    const semanticErrors = diagResult.semanticErrors?.filter((e) => e.severity === "error")?.length ?? 0;
    const semanticWarnings = diagResult.semanticErrors?.filter((e) => e.severity === "warning")?.length ?? 0;
    const semanticInfo = diagResult.semanticErrors?.filter((e) => e.severity === "info")?.length ?? 0;
    const stratErrors = diagResult.stratificationErrors?.filter((e) => e.severity === "error")?.length ?? 0;
    const stratWarnings = diagResult.stratificationErrors?.filter((e) => e.severity === "warning")?.length ?? 0;
    totalErrors += parseErrors + semanticErrors + stratErrors;
    totalWarnings += semanticWarnings + stratWarnings;
    totalInfo += semanticInfo;
  }
  return {
    files,
    summary: {
      totalFiles: files.length,
      totalErrors,
      totalWarnings,
      totalInfo
    }
  };
});
connection.onRequest("mangle/getWorkspaceSummary", async () => {
  const allPredicates = /* @__PURE__ */ new Map();
  const fileInfos = [];
  for (const [uri, state] of documentStates) {
    const symbolTable = getSymbolTable(state);
    if (symbolTable) {
      for (const pred of symbolTable.getAllPredicates()) {
        const key = `${pred.symbol.symbol}/${pred.symbol.arity}`;
        if (!allPredicates.has(key)) {
          allPredicates.set(key, {
            arity: pred.symbol.arity,
            definedIn: [],
            referencedIn: []
          });
        }
        const info = allPredicates.get(key);
        if (pred.definitions.length > 0) {
          info.definedIn.push(uri);
        }
        if (pred.references.length > 0) {
          info.referencedIn.push(uri);
        }
      }
    }
    fileInfos.push({
      uri,
      hasSyntaxErrors: state.parseResult.errors.length > 0,
      hasSemanticErrors: (state.validationResult?.errors.length ?? 0) > 0,
      declCount: state.parseResult.unit?.decls.length ?? 0,
      clauseCount: state.parseResult.unit?.clauses.length ?? 0
    });
  }
  const predicates = Array.from(allPredicates.entries()).map(([name, info]) => ({
    name,
    arity: info.arity,
    definedIn: info.definedIn,
    referencedIn: info.referencedIn
  }));
  return {
    files: fileInfos,
    predicates,
    totalFiles: fileInfos.length,
    totalPredicates: predicates.length
  };
});
connection.onShutdown(() => {
  connection.console.log("Mangle LSP server shutting down");
  for (const timeout of validationTimeouts.values()) {
    clearTimeout(timeout);
  }
  validationTimeouts.clear();
  documentStates.clear();
  documentSettings.clear();
});
connection.onExit(() => {
  process.exit(0);
});
documents.listen(connection);
connection.listen();
function startServer() {
  connection.console.log("Mangle LSP server started.");
}
